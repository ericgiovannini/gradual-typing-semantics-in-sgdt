{-# OPTIONS --guarded --rewriting #-}

{-# OPTIONS --allow-unsolved-metas #-}


module Semantics.Concrete.DoublePoset.Constructions where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function hiding (_$_)
open import Cubical.Foundations.Structure
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Transport

open import Cubical.Data.Bool
open import Cubical.Data.Nat renaming (‚Ñï to Nat)
open import Cubical.Data.Unit.Properties
open import Cubical.Data.Sigma.Base
open import Cubical.Data.Sigma.Properties
open import Cubical.Data.Sum.Base
open import Cubical.Data.Sum.Properties
open import Cubical.Data.Empty.Base

open import Cubical.Relation.Binary.Base

open import Semantics.Concrete.DoublePoset.Base
open import Semantics.Concrete.DoublePoset.Morphism
open import Semantics.Concrete.DoublePoset.Convenience
open import Semantics.Concrete.DoublePoset.DPMorProofs

open import Common.Later
open import Common.LaterProperties

open BinaryRelation

private
  variable
    ‚Ñì ‚Ñì' ‚Ñì'' : Level
    ‚ÑìX ‚Ñì'X ‚Ñì''X : Level
    ‚ÑìY ‚Ñì'Y ‚Ñì''Y : Level
    ‚ÑìZ ‚Ñì'Z ‚Ñì''Z : Level
    ‚Ñì1 ‚Ñì'1 ‚Ñì''1 : Level
    ‚Ñì2 ‚Ñì'2 ‚Ñì''2 : Level
    ‚ÑìA ‚Ñì'A ‚Ñì''A : Level
    ‚ÑìB ‚Ñì'B ‚Ñì''B : Level

    ‚Ñì‚â§A ‚Ñì‚âàA : Level

    X : PosetBisim ‚ÑìX ‚Ñì'X ‚Ñì''X
    Y : PosetBisim ‚ÑìY ‚Ñì'Y ‚Ñì''Y
    Z : PosetBisim ‚ÑìZ ‚Ñì'Z ‚Ñì''Z


-- Constructions not involving later


-- Turning a Set into a predomain with ordering and bisimilarity given by equality.

flat : hSet ‚Ñì -> PosetBisim ‚Ñì ‚Ñì ‚Ñì
flat h = ‚ü® h ‚ü© , (posetbisimstr
                   (str h) _‚â°_
                   (isorderingrelation (str h) (Œª _ ‚Üí refl)
                     (Œª a b c a‚â°b b‚â°c ‚Üí a ‚â°‚ü® a‚â°b ‚ü© b ‚â°‚ü® b‚â°c ‚ü© c ‚àé)
                     Œª x y p q ‚Üí p)
                   _‚â°_ (isbisim (Œª _ ‚Üí refl) (Œª a b x ‚Üí sym x) (str h)))


ùîπ : PosetBisim ‚Ñì-zero ‚Ñì-zero ‚Ñì-zero
ùîπ = flat (Bool , isSetBool)

‚Ñï : PosetBisim ‚Ñì-zero ‚Ñì-zero ‚Ñì-zero
‚Ñï = flat (Nat , isSet‚Ñï)

-- Any function defined on Nat as a flat dbposet is monotone
flatNatFun-monotone : (f : Nat -> Nat) -> monotone {X = ‚Ñï} {Y = ‚Ñï} f
flatNatFun-monotone f {n} {m} n‚â°m = cong f n‚â°m


flatNatFun-preserve‚âà : (f : Nat -> Nat) -> preserve‚âà {X = ‚Ñï} {Y = ‚Ñï} f
flatNatFun-preserve‚âà f {n} {m} n‚âàm = cong f n‚âàm



-- Constant functions induce morphisms of predomains
Const : (Y : PosetBisim ‚ÑìY ‚Ñì'Y ‚Ñì''Y) ‚Üí (y : ‚ü® Y ‚ü©) ‚Üí {X : PosetBisim ‚ÑìX ‚Ñì'X ‚Ñì''X} ‚Üí PBMor X Y
Const Y y .PBMor.f = Œª _ ‚Üí y
Const Y y .PBMor.isMon = Œª x1‚â§x2 ‚Üí (Y .snd .PosetBisimStr.is-refl) y
Const Y y .PBMor.pres‚âà = Œª x1‚âàx2 ‚Üí (Y .snd .PosetBisimStr.is-refl-Bisim) y


-- The terminal object in the category of predomains

UnitPB : PosetBisim ‚Ñì-zero ‚Ñì-zero ‚Ñì-zero
UnitPB = flat (Unit , isSetUnit)


-- unique morphism into UnitP
UnitPB! : {A : PosetBisim ‚Ñì ‚Ñì' ‚Ñì''} -> PBMor A UnitPB
UnitPB! = record { f = Œª _ ‚Üí tt ; isMon = Œª _ ‚Üí refl ; pres‚âà = Œª _ ‚Üí refl }


LiftPosetBisim : {‚Ñì1 ‚Ñì'1 ‚Ñì''1 : Level} (X : PosetBisim ‚Ñì1 ‚Ñì'1 ‚Ñì''1) ->
  (‚Ñì2 ‚Ñì'2 ‚Ñì''2 : Level) -> PosetBisim (‚Ñì-max ‚Ñì1 ‚Ñì2) (‚Ñì-max ‚Ñì'1 ‚Ñì'2) (‚Ñì-max ‚Ñì''1 ‚Ñì''2)
LiftPosetBisim {‚Ñì1 = ‚Ñì1} {‚Ñì'1 = ‚Ñì'1} {‚Ñì''1 = ‚Ñì''1} X ‚Ñì2 ‚Ñì'2 ‚Ñì''2 =
  (Lift {i = ‚Ñì1} {j = ‚Ñì2} ‚ü® X ‚ü©) ,
  posetbisimstr
    (isOfHLevelLift 2 X.is-set )
    (Œª {(lift x) (lift y) ‚Üí Lift {i = ‚Ñì'1} {j = ‚Ñì'2} (x X.‚â§ y)})
    (isorderingrelation
      (Œª {(lift x) (lift y) (lift p) (lift q) ‚Üí cong lift (X.is-prop-valued x y p q)})
      (Œª {(lift x) ‚Üí lift (X.is-refl x)})
      (Œª {(lift x) (lift y) (lift z) (lift x‚â§y) (lift y‚â§z) ->
      lift (X.is-trans x y z x‚â§y y‚â§z)})
      Œª {(lift x) (lift y) (lift x‚â§y) (lift y‚â§x) ->
      cong lift (X.is-antisym x y x‚â§y y‚â§x)})
    (Œª {(lift x) (lift y) ‚Üí Lift {i = ‚Ñì''1} {j = ‚Ñì''2} (x X.‚âà y)})
    (isbisim
      (Œª {(lift x) ‚Üí lift (X.is-refl-Bisim x)})
      (Œª {(lift x) (lift y) (lift (x‚âày)) ‚Üí lift (X.is-sym x y x‚âày)})
      Œª {(lift x) (lift y) (lift p) (lift q) ‚Üí
        cong lift (X.is-prop-valued-Bisim x y p q)})
  where
    module X = PosetBisimStr (X .snd)


-- Product of predomains

-- We can't use Cubical.Data.Prod.Base for products, because this version of _√ó_
-- is not a subtype of the degenerate sigma type Œ£ A (Œª _ ‚Üí B), and this is needed
-- when we define the lookup function.
-- So we instead use Cubical.Data.Sigma.

-- These aren't included in Cubical.Data.Sigma, so we copy the
-- definitions from Cubical.Data.Prod.Base.
proj‚ÇÅ : {‚Ñì ‚Ñì' : Level} {A : Type ‚Ñì} {B : Type ‚Ñì'} ‚Üí A √ó B ‚Üí A
proj‚ÇÅ (x , _) = x

proj‚ÇÇ : {‚Ñì ‚Ñì' : Level} {A : Type ‚Ñì} {B : Type ‚Ñì'} ‚Üí A √ó B ‚Üí B
proj‚ÇÇ (_ , x) = x

infixl 21 _√ódp_
_√ódp_ : PosetBisim ‚ÑìA ‚Ñì'A ‚Ñì''A  -> PosetBisim ‚ÑìB ‚Ñì'B ‚Ñì''B -> PosetBisim (‚Ñì-max ‚ÑìA ‚ÑìB) (‚Ñì-max ‚Ñì'A ‚Ñì'B) (‚Ñì-max ‚Ñì''A ‚Ñì''B)
_√ódp_ {‚Ñì'A = ‚Ñì'A} {‚Ñì''A = ‚Ñì''A} {‚Ñì'B = ‚Ñì'B} {‚Ñì''B = ‚Ñì''B} A B  =
  ‚ü® A ‚ü© √ó ‚ü® B ‚ü© ,
  posetbisimstr
    (isSet√ó A.is-set B.is-set)
    order
    (isorderingrelation order-prop-valued order-refl order-trans order-antisym)
    bisim
    (isbisim bisim-refl bisim-sym bisim-prop-valued)
  where
    module A = PosetBisimStr (A .snd)
    module B = PosetBisimStr (B .snd)

    order : ‚ü® A ‚ü© √ó ‚ü® B ‚ü© -> ‚ü® A ‚ü© √ó ‚ü® B ‚ü© -> Type (‚Ñì-max ‚Ñì'A ‚Ñì'B)
    order (a1 , b1) (a2 , b2) = (a1 A.‚â§ a2) √ó (b1 B.‚â§ b2)

    order-prop-valued : isPropValued order
    order-prop-valued (a1 , b1) (a2 , b2) = isProp√ó
      (prop-valued-‚â§ A a1 a2)
      (prop-valued-‚â§ B b1 b2)

    order-refl : isRefl order
    order-refl = Œª (a , b) ‚Üí reflexive-‚â§ A a , reflexive-‚â§ B b

    order-trans : isTrans order
    order-trans (a1 , b1) (a2 , b2) (a3 , b3) (a1‚â§a2 , b1‚â§b2) (a2‚â§a3 , b2‚â§b3) =
      (transitive-‚â§ A a1 a2 a3 a1‚â§a2 a2‚â§a3) ,
      (transitive-‚â§ B b1 b2 b3 b1‚â§b2 b2‚â§b3)

    order-antisym : isAntisym order
    order-antisym (a1 , b1) (a2 , b2) (a1‚â§a2 , b1‚â§b2) (a2‚â§a1 , b2‚â§b1) =
      ‚â°-√ó (antisym-‚â§ A a1 a2 a1‚â§a2 a2‚â§a1)
          (antisym-‚â§ B b1 b2 b1‚â§b2 b2‚â§b1)

    bisim : ‚ü® A ‚ü© √ó ‚ü® B ‚ü© -> ‚ü® A ‚ü© √ó ‚ü® B ‚ü© -> Type (‚Ñì-max ‚Ñì''A ‚Ñì''B)
    bisim (a1 , b1) (a2 , b2) = (a1 A.‚âà a2) √ó (b1 B.‚âà b2)

    bisim-refl : isRefl bisim
    bisim-refl = Œª (a , b) ‚Üí (reflexive-‚âà A a) , reflexive-‚âà B b

    bisim-sym : isSym bisim
    bisim-sym = Œª (a1 , b1) (a2 , b2) (a1‚âàa2 , b1‚âàb2) ‚Üí
      sym-‚âà A a1 a2 a1‚âàa2 , sym-‚âà B b1 b2 b1‚âàb2

    bisim-prop-valued : isPropValued bisim
    bisim-prop-valued (a1 , b1) (a2 , b2) = isProp√ó
      (prop-valued-‚âà A a1 a2) (prop-valued-‚âà B b1 b2)

œÄ1 : {A : PosetBisim ‚ÑìA ‚Ñì'A ‚Ñì''A} {B : PosetBisim ‚ÑìB ‚Ñì'B ‚Ñì''B} -> PBMor (A √ódp B) A
œÄ1 {A = A} {B = B} = record {
  f = g ;
  isMon = g-mon ;
  pres‚âà = g-bisim }
  where
    g : ‚ü® A √ódp B ‚ü© -> ‚ü® A ‚ü©
    g (a , b) = a

    g-mon  : {p1 p2 : ‚ü® A √ódp B ‚ü©} ‚Üí rel-‚â§ (A √ódp B) p1 p2 ‚Üí rel-‚â§ A (g p1) (g p2)
    g-mon {Œ≥1 , a1} {Œ≥2 , a2} (a1‚â§a2 , b1‚â§b2) = a1‚â§a2

    g-bisim : {p1 p2 : ‚ü® A √ódp B ‚ü©} ‚Üí rel-‚âà (A √ódp B) p1 p2 ‚Üí rel-‚âà A (g p1) (g p2)
    g-bisim {Œ≥1 , a1} {Œ≥2 , a2} (a1‚âàa2 , b1‚âàb2) = a1‚âàa2

œÄ2 : {A : PosetBisim ‚ÑìA ‚Ñì'A ‚Ñì''A} {B : PosetBisim ‚ÑìB ‚Ñì'B ‚Ñì''B} -> PBMor (A √ódp B) B
œÄ2 {A = A} {B = B} = record {
  f = g ;
  isMon = g-mon ;
  pres‚âà = g-bisim }
  where
    g : ‚ü® A √ódp B ‚ü© -> ‚ü® B ‚ü©
    g (a , b) = b

    g-mon  : {p1 p2 : ‚ü® A √ódp B ‚ü©} ‚Üí rel-‚â§ (A √ódp B) p1 p2 ‚Üí rel-‚â§ B (g p1) (g p2)
    g-mon {Œ≥1 , a1} {Œ≥2 , a2} (a1‚â§a2 , b1‚â§b2) = b1‚â§b2

    g-bisim : {p1 p2 : ‚ü® A √ódp B ‚ü©} ‚Üí rel-‚âà (A √ódp B) p1 p2 ‚Üí rel-‚âà B (g p1) (g p2)
    g-bisim {Œ≥1 , a1} {Œ≥2 , a2} (a1‚âàa2 , b1‚âàb2) = b1‚âàb2

√ó-intro : PBMor X Y ‚Üí PBMor X Z ‚Üí PBMor X (Y √ódp Z)
√ó-intro g h = record {
  f = Œª x ‚Üí g.f x , h.f x
  ; isMon = Œª x‚â§y ‚Üí (g.isMon x‚â§y) , (h.isMon x‚â§y)
  ; pres‚âà = Œª x‚âày ‚Üí (g.pres‚âà x‚âày) , (h.pres‚âà x‚âày)
  } where
  module g = PBMor g
  module h = PBMor h

PBMorCurry' : {X Y Z : PosetBisim ‚Ñì ‚Ñì' ‚Ñì''} ->
  PBMor (Z √ódp X) Y -> ‚ü® Z ‚ü© -> PBMor X Y
PBMorCurry' {Z = Z} g z = record {
  f = Œª x ‚Üí g $ (z , x) ;
  isMon = Œª {x1} {x2} x1‚â§x2 ‚Üí PBMor.isMon g (reflexive-‚â§ Z z , x1‚â§x2) ;
  pres‚âà = Œª {x1} {x2} x1‚âàx2 ‚Üí PBMor.pres‚âà g (reflexive-‚âà Z z , x1‚âàx2)  }

PBMorCurry : {X Y Z : PosetBisim ‚Ñì ‚Ñì' ‚Ñì''} ->
  PBMor (Z √ódp X) Y -> PBMor Z (IntHom X Y)
PBMorCurry {X = X} {Y = Y} {Z = Z} g = record {
  f = Œª z ‚Üí PBMorCurry' {X = X} {Y = Y} {Z = Z} g z ;
  isMon = Œª {z} {z'} z‚â§z' ‚Üí Œª x ‚Üí PBMor.isMon g (z‚â§z' , reflexive-‚â§ X x) ;
  pres‚âà = Œª {z} {z'} z‚âàz' x x' x‚âàx' ‚Üí PBMor.pres‚âà g (z‚âàz' , x‚âàx') }


-- Coproduct of predomains

_‚äép_ : PosetBisim ‚ÑìA ‚Ñì'A ‚Ñì''A  -> PosetBisim ‚ÑìB ‚Ñì'B ‚Ñì''B -> PosetBisim (‚Ñì-max ‚ÑìA ‚ÑìB) (‚Ñì-max ‚Ñì'A ‚Ñì'B) (‚Ñì-max ‚Ñì''A ‚Ñì''B)
_‚äép_ {‚Ñì'A = ‚Ñì'A} {‚Ñì''A = ‚Ñì''A} {‚Ñì'B = ‚Ñì'B}  {‚Ñì''B = ‚Ñì''B} A B =
  (‚ü® A ‚ü© ‚äé ‚ü® B ‚ü©) ,
  posetbisimstr
    (isSet‚äé (A.is-set) (B.is-set))
    order (isorderingrelation order-prop-valued order-refl order-trans order-antisym)
    bisim (isbisim bisim-refl bisim-sym bisim-prop-valued)
  where
    module A = PosetBisimStr (A .snd)
    module B = PosetBisimStr (B .snd)

    order : ‚ü® A ‚ü© ‚äé ‚ü® B ‚ü© -> ‚ü® A ‚ü© ‚äé ‚ü® B ‚ü© -> Type (‚Ñì-max ‚Ñì'A ‚Ñì'B)
    order (inl a1) (inl a2) = Lift {j = ‚Ñì'B} (a1 A.‚â§ a2)
    order (inl a1) (inr b1) = ‚ä•*
    order (inr b1) (inl a1) = ‚ä•*
    order (inr b1) (inr b2) = Lift {j = ‚Ñì'A} (b1 B.‚â§ b2)

    order-prop-valued : isPropValued order
    order-prop-valued (inl a1) (inl a2) = isOfHLevelLift 1 (prop-valued-‚â§ A a1 a2)
    order-prop-valued (inr b1) (inr b2) = isOfHLevelLift 1 (prop-valued-‚â§ B b1 b2)

    order-refl : isRefl order
    order-refl (inl a) = lift (reflexive-‚â§ A a)
    order-refl (inr b) = lift (reflexive-‚â§ B b)

    order-trans : isTrans order
    order-trans (inl a1) (inl a2) (inl a3) a1‚â§a2 a2‚â§a3 =
      lift (transitive-‚â§ A a1 a2 a3 (lower a1‚â§a2) (lower a2‚â§a3))
    order-trans (inr b1) (inr b2) (inr b3) b1‚â§b2 b2‚â§b3 =
      lift (transitive-‚â§ B b1 b2 b3 (lower b1‚â§b2) (lower b2‚â§b3))

    order-antisym : isAntisym order
    order-antisym (inl a1) (inl a2) a‚â§b b‚â§a =
      cong inl (antisym-‚â§ A _ _ (lower a‚â§b) (lower b‚â§a))
    order-antisym (inr b1) (inr b2) a‚â§b b‚â§a =
      cong inr (antisym-‚â§ B _ _ (lower a‚â§b) (lower b‚â§a))

    bisim : ‚ü® A ‚ü© ‚äé ‚ü® B ‚ü© -> ‚ü® A ‚ü© ‚äé ‚ü® B ‚ü© -> Type (‚Ñì-max ‚Ñì''A ‚Ñì''B)
    bisim (inl a1) (inl a2) = Lift {j = ‚Ñì''B} (a1 A.‚âà a2)
    bisim (inl a1) (inr b1) = ‚ä•*
    bisim (inr b1) (inl a1) = ‚ä•*
    bisim (inr b1) (inr b2) = Lift {j = ‚Ñì''A} (b1 B.‚âà b2)

    bisim-refl : isRefl bisim
    bisim-refl = Œª { (inl a) ‚Üí lift (reflexive-‚âà A a) ;
                     (inr b) ‚Üí lift (reflexive-‚âà B b) }

    bisim-sym : isSym bisim
    bisim-sym = Œª { (inl a1) (inl a2) a1‚âàa2 ‚Üí lift (sym-‚âà A a1 a2 (lower a1‚âàa2)) ;
                    (inr b1) (inr b2) b1‚âàb2 ‚Üí lift (sym-‚âà B b1 b2 (lower b1‚âàb2))}

    bisim-prop-valued : isPropValued bisim
    bisim-prop-valued (inl a1) (inl a2) = isOfHLevelLift 1 (prop-valued-‚âà A a1 a2)
    bisim-prop-valued (inr b1) (inr b2) = isOfHLevelLift 1 (prop-valued-‚âà B b1 b2)


œÉ1 : {A : PosetBisim ‚ÑìA ‚Ñì'A ‚Ñì''A} {B : PosetBisim ‚ÑìB ‚Ñì'B ‚Ñì''B} -> ‚ü® A ==> (A ‚äép B) ‚ü©
œÉ1 = record {
  f = Œª a ‚Üí inl a ;
  isMon = Œª {x} {y} x‚â§y ‚Üí lift x‚â§y ;
  pres‚âà = Œª {x} {y} x‚âày ‚Üí lift x‚âày }

œÉ2 : {A : PosetBisim ‚ÑìA ‚Ñì'A ‚Ñì''A} {B : PosetBisim ‚ÑìB ‚Ñì'B ‚Ñì''B} -> ‚ü® B ==> (A ‚äép B) ‚ü©
œÉ2 = record {
  f = Œª a ‚Üí inr a ;
  isMon = Œª {x} {y} x‚â§y ‚Üí lift x‚â§y ;
  pres‚âà = Œª {x} {y} x‚âày ‚Üí lift x‚âày }


open PosetBisimStr


-- Indexed product of predomains (must be at the same universe levels)


Œ†P : (X : Type ‚ÑìX){‚Ñì ‚Ñì‚â§ ‚Ñì‚âà : Level} ‚Üí (A : X ‚Üí PosetBisim ‚Ñì ‚Ñì‚â§ ‚Ñì‚âà) ‚Üí
  PosetBisim (‚Ñì-max ‚ÑìX ‚Ñì) (‚Ñì-max ‚ÑìX ‚Ñì‚â§) (‚Ñì-max ‚ÑìX ‚Ñì‚âà)
Œ†P X A = (‚àÄ (x : X) ‚Üí ‚ü® A x ‚ü©) ,
  posetbisimstr (isSetŒ† Œª x ‚Üí A x .snd .is-set) ord isOrdering bisim isBisimilarity

  where
    ord : _ ‚Üí _ ‚Üí Type _
    ord as bs = ‚àÄ x ‚Üí A x .snd  .PosetBisimStr._‚â§_ (as x) (bs x)

    ord-prop-valued : isPropValued ord
    ord-prop-valued as bs p q =
      funExt (Œª x ‚Üí A x .snd .is-prop-valued (as x) (bs x) (p x) (q x))

    ord-refl : isRefl ord
    ord-refl as x = A x .snd .is-refl (as x)

    ord-trans : isTrans ord
    ord-trans as bs cs as‚â§bs bs‚â§cs x =
      A x .snd .is-trans (as x) (bs x) (cs x) (as‚â§bs x) (bs‚â§cs x)

    ord-antisym : isAntisym ord
    ord-antisym as bs as‚â§bs bs‚â§as =
      funExt (Œª x ‚Üí A x .snd .is-antisym (as x) (bs x) (as‚â§bs x) (bs‚â§as x))

    isOrdering = isorderingrelation ord-prop-valued ord-refl ord-trans ord-antisym

    bisim : _ ‚Üí _ ‚Üí Type _
    bisim as bs = ‚àÄ x ‚Üí A x .snd .PosetBisimStr._‚âà_ (as x) (bs x)

    bisim-prop-valued : isPropValued bisim
    bisim-prop-valued as bs p q =
      funExt (Œª x ‚Üí A x .snd .is-prop-valued-Bisim (as x) (bs x) (p x) (q x))

    bisim-refl : isRefl bisim
    bisim-refl as x = A x .snd .is-refl-Bisim (as x)

    bisim-sym : isSym bisim
    bisim-sym as bs as‚âàbs x = A x .snd .is-sym (as x) (bs x) (as‚âàbs x)

    isBisimilarity = isbisim bisim-refl bisim-sym bisim-prop-valued


-- Intro and elim for Œ†
module _ {X : Type ‚ÑìX} {‚Ñì ‚Ñì‚â§ ‚Ñì‚âà : Level} {B : X ‚Üí PosetBisim ‚Ñì ‚Ñì‚â§ ‚Ñì‚âà} where

  Œ†-intro : {A : PosetBisim ‚ÑìA ‚Ñì‚â§A ‚Ñì‚âàA} ‚Üí
    ((x : X) ‚Üí PBMor A (B x)) ‚Üí
    PBMor A (Œ†P X B)
  Œ†-intro fs .PBMor.f a x = PBMor.f (fs x) a
  Œ†-intro fs .PBMor.isMon a‚ÇÅ‚â§a‚ÇÇ x = PBMor.isMon (fs x) a‚ÇÅ‚â§a‚ÇÇ
  Œ†-intro fs .PBMor.pres‚âà a‚ÇÅ‚âàa‚ÇÇ x = PBMor.pres‚âà (fs x) a‚ÇÅ‚âàa‚ÇÇ

  Œ†-elim : (x : X) ‚Üí PBMor (Œ†P X B) (B x)
  Œ†-elim x .PBMor.f bs = bs x
  Œ†-elim x .PBMor.isMon {x = as} {y = bs} as‚â§bs = as‚â§bs x
  Œ†-elim x .PBMor.pres‚âà {x = as} {y = bs} as‚âàbs = as‚âàbs x

-- Action of Œ† on a family of morphisms
Œ†-mor : ‚àÄ {‚Ñì ‚Ñì‚â§ ‚Ñì‚âà}
  (X : Type ‚ÑìX) ‚Üí
  (A B : X ‚Üí PosetBisim ‚Ñì ‚Ñì‚â§ ‚Ñì‚âà) ‚Üí
  ((x : X) ‚Üí PBMor (A x) (B x)) ‚Üí
  PBMor (Œ†P X A) (Œ†P X B)
Œ†-mor X A B fs = Œ†-intro (Œª y ‚Üí (fs y) ‚àòp (Œ†-elim {B = A} y))
  


-- Œ£ for predomains (i.e. a Type-indexed coproduct of predomains)

Œ£P : (X : hSet ‚ÑìX) ‚Üí {‚Ñì ‚Ñì‚â§ ‚Ñì‚âà : Level} ‚Üí
  (B : ‚ü® X ‚ü© ‚Üí PosetBisim ‚Ñì ‚Ñì‚â§ ‚Ñì‚âà) ‚Üí
  PosetBisim (‚Ñì-max ‚ÑìX ‚Ñì) (‚Ñì-max ‚ÑìX ‚Ñì‚â§) (‚Ñì-max ‚ÑìX ‚Ñì‚âà)
Œ£P X B = (Œ£[ x ‚àà ‚ü® X ‚ü© ] ‚ü® B x ‚ü©) ,
  (posetbisimstr (isSetŒ£ (X .snd) (Œª x ‚Üí B x .snd .is-set))
    ord (isorderingrelation ord-prop-valued ord-refl ord-trans ord-antisym)
    bisim (isbisim bisim-refl bisim-sym bisim-prop-valued))

  where

    ord : _ ‚Üí _ ‚Üí Type _
    ord (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) =
      Œ£[ eq ‚àà (x‚ÇÅ ‚â° x‚ÇÇ) ] (rel-‚â§ (B x‚ÇÇ) (subst (Œª x ‚Üí ‚ü® B x ‚ü©) eq b‚ÇÅ) b‚ÇÇ)

    ord-prop-valued : isPropValued ord
    ord-prop-valued (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) (eq , b‚ÇÅ‚â§b‚ÇÇ) (eq' , b‚ÇÅ‚â§b‚ÇÇ') =
      Œ£PathP ((X .snd x‚ÇÅ x‚ÇÇ eq eq') ,
              (isProp‚ÜíPathP (Œª i ‚Üí B x‚ÇÇ .snd .is-prop-valued _ _) b‚ÇÅ‚â§b‚ÇÇ b‚ÇÅ‚â§b‚ÇÇ'))

    ord-refl : isRefl ord
    ord-refl (x , b) = refl ,
      subst
        (Œª y ‚Üí rel-‚â§ (B x) y b)
        (sym (substRefl {B = Œª x ‚Üí ‚ü® B x ‚ü©} b))
        (B x .snd .is-refl b)

    ord-trans : isTrans ord
    ord-trans (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) (x‚ÇÉ , b‚ÇÉ) (x‚ÇÅ‚â°x‚ÇÇ , b‚ÇÅ‚ÇÇ‚â§b‚ÇÇ) (x‚ÇÇ‚â°x‚ÇÉ , b‚ÇÇ‚ÇÉ‚â§b‚ÇÉ) =
      (x‚ÇÅ‚â°x‚ÇÇ ‚àô x‚ÇÇ‚â°x‚ÇÉ) ,
      transport (Œª i ‚Üí rel-‚â§ (B x‚ÇÉ) (sym (substComposite T x‚ÇÅ‚â°x‚ÇÇ x‚ÇÇ‚â°x‚ÇÉ b‚ÇÅ) i) b‚ÇÉ) lem
        where
          T : ‚ü® X ‚ü© ‚Üí Type _
          T = Œª x ‚Üí ‚ü® B x ‚ü©
        
          b‚ÇÅ‚ÇÉ  = subst T (x‚ÇÅ‚â°x‚ÇÇ ‚àô x‚ÇÇ‚â°x‚ÇÉ) b‚ÇÅ
          b‚ÇÅ‚ÇÇ  = subst T x‚ÇÅ‚â°x‚ÇÇ b‚ÇÅ
          b‚ÇÅ‚ÇÇ‚ÇÉ = subst T x‚ÇÇ‚â°x‚ÇÉ b‚ÇÅ‚ÇÇ
          b‚ÇÇ‚ÇÉ  = subst T x‚ÇÇ‚â°x‚ÇÉ b‚ÇÇ
          
          b‚ÇÅ‚ÇÇ‚ÇÉ‚â§b‚ÇÇ‚ÇÉ : rel-‚â§ (B x‚ÇÉ) b‚ÇÅ‚ÇÇ‚ÇÉ b‚ÇÇ‚ÇÉ
          b‚ÇÅ‚ÇÇ‚ÇÉ‚â§b‚ÇÇ‚ÇÉ = rel-transport-‚â§ (cong B x‚ÇÇ‚â°x‚ÇÉ) b‚ÇÅ‚ÇÇ‚â§b‚ÇÇ

          -- Goal: b‚ÇÅ‚ÇÉ (B x‚ÇÉ).‚â§ b‚ÇÉ
          -- Know: b‚ÇÅ‚ÇÉ = b‚ÇÅ‚ÇÇ‚ÇÉ by substComposite
          --
          -- STS b‚ÇÅ‚ÇÇ‚ÇÉ (B x‚ÇÉ).‚â§ b‚ÇÉ
          -- By transitivity STS b‚ÇÅ‚ÇÇ‚ÇÉ ‚â§ b‚ÇÇ‚ÇÉ ‚â§ b‚ÇÉ.
          -- The latter is true by assumption, and the former
          -- follows by assumption b‚ÇÅ‚ÇÇ‚â§b‚ÇÇ and the fact that B x‚ÇÇ ‚â° B x‚ÇÉ.
          lem : rel-‚â§ (B x‚ÇÉ) b‚ÇÅ‚ÇÇ‚ÇÉ b‚ÇÉ
          lem = B x‚ÇÉ .snd .is-trans b‚ÇÅ‚ÇÇ‚ÇÉ b‚ÇÇ‚ÇÉ b‚ÇÉ b‚ÇÅ‚ÇÇ‚ÇÉ‚â§b‚ÇÇ‚ÇÉ b‚ÇÇ‚ÇÉ‚â§b‚ÇÉ
         
    
    ord-antisym : isAntisym ord
    ord-antisym (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) (x‚ÇÅ‚â°x‚ÇÇ , b‚ÇÅ‚ÇÇ‚â§b‚ÇÇ) (x‚ÇÇ‚â°x‚ÇÅ , b‚ÇÇ‚ÇÅ‚â§b‚ÇÅ) =
      Œ£PathP (x‚ÇÅ‚â°x‚ÇÇ , toPathP eq)
        where
          T : ‚ü® X ‚ü© ‚Üí Type _
          T = Œª x ‚Üí ‚ü® B x ‚ü©
          
          b‚ÇÅ‚ÇÇ  = subst T x‚ÇÅ‚â°x‚ÇÇ b‚ÇÅ
          b‚ÇÅ‚ÇÇ‚ÇÅ = subst T x‚ÇÇ‚â°x‚ÇÅ b‚ÇÅ‚ÇÇ
          b‚ÇÇ‚ÇÅ  = subst T x‚ÇÇ‚â°x‚ÇÅ b‚ÇÇ
          b‚ÇÇ‚ÇÅ‚ÇÇ = subst T x‚ÇÅ‚â°x‚ÇÇ b‚ÇÇ‚ÇÅ

          pf-inverse : x‚ÇÅ‚â°x‚ÇÇ ‚â° sym x‚ÇÇ‚â°x‚ÇÅ
          pf-inverse = X .snd x‚ÇÅ x‚ÇÇ x‚ÇÅ‚â°x‚ÇÇ (sym x‚ÇÇ‚â°x‚ÇÅ)

          b‚ÇÇ‚ÇÅ‚ÇÇ‚â§b‚ÇÅ‚ÇÇ : rel-‚â§ (B x‚ÇÇ) b‚ÇÇ‚ÇÅ‚ÇÇ b‚ÇÅ‚ÇÇ
          b‚ÇÇ‚ÇÅ‚ÇÇ‚â§b‚ÇÅ‚ÇÇ = rel-transport-‚â§ (cong B x‚ÇÅ‚â°x‚ÇÇ) b‚ÇÇ‚ÇÅ‚â§b‚ÇÅ

          b‚ÇÇ‚ÇÅ‚ÇÇ‚â°b‚ÇÇ : b‚ÇÇ‚ÇÅ‚ÇÇ ‚â° b‚ÇÇ
          b‚ÇÇ‚ÇÅ‚ÇÇ‚â°b‚ÇÇ = let e1 = (Œª i ‚Üí subst T (pf-inverse i) b‚ÇÇ‚ÇÅ) in
                    let e2 = subst‚ÅªSubst T x‚ÇÇ‚â°x‚ÇÅ b‚ÇÇ in
                    e1 ‚àô e2
          
          eq : b‚ÇÅ‚ÇÇ ‚â° b‚ÇÇ
          eq = B x‚ÇÇ .snd .is-antisym b‚ÇÅ‚ÇÇ b‚ÇÇ b‚ÇÅ‚ÇÇ‚â§b‚ÇÇ
            (subst (Œª z ‚Üí rel-‚â§ (B x‚ÇÇ) z b‚ÇÅ‚ÇÇ) b‚ÇÇ‚ÇÅ‚ÇÇ‚â°b‚ÇÇ b‚ÇÇ‚ÇÅ‚ÇÇ‚â§b‚ÇÅ‚ÇÇ) 

    bisim : _ ‚Üí _ ‚Üí Type _
    bisim (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) =
      Œ£[ eq ‚àà (x‚ÇÅ ‚â° x‚ÇÇ) ] (rel-‚âà (B x‚ÇÇ) (subst (Œª x ‚Üí ‚ü® B x ‚ü©) eq b‚ÇÅ) b‚ÇÇ)

    bisim-refl : isRefl bisim
    bisim-refl (x , b) = refl ,
      subst
        (Œª y ‚Üí rel-‚âà (B x) y b)
        (sym (substRefl {B = Œª x ‚Üí ‚ü® B x ‚ü©} b))
        (B x .snd .is-refl-Bisim b)

    bisim-sym : isSym bisim
    bisim-sym (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) (x‚ÇÅ‚â°x‚ÇÇ , b‚ÇÅ‚ÇÇ‚âàb‚ÇÇ) =
      (sym x‚ÇÅ‚â°x‚ÇÇ) , rel-transport-‚âà-lemma (cong B (sym x‚ÇÅ‚â°x‚ÇÇ)) (B x‚ÇÇ .snd .is-sym _ _ b‚ÇÅ‚ÇÇ‚âàb‚ÇÇ)

    bisim-prop-valued : isPropValued bisim
    bisim-prop-valued (x‚ÇÅ , b‚ÇÅ) (x‚ÇÇ , b‚ÇÇ) (eq , b‚ÇÅ‚âàb‚ÇÇ) (eq' , b‚ÇÅ‚âàb‚ÇÇ') =
      Œ£PathP ((X .snd x‚ÇÅ x‚ÇÇ eq eq') ,
              (isProp‚ÜíPathP (Œª i ‚Üí B x‚ÇÇ .snd .is-prop-valued-Bisim _ _) b‚ÇÅ‚âàb‚ÇÇ b‚ÇÅ‚âàb‚ÇÇ'))



-- Intro and elim for Œ£
module _ {X : hSet ‚ÑìX} {‚Ñì ‚Ñì‚â§ ‚Ñì‚âà : Level} {B : ‚ü® X ‚ü© ‚Üí PosetBisim ‚Ñì ‚Ñì‚â§ ‚Ñì‚âà} where

  Œ£-intro : (x : ‚ü® X ‚ü©) ‚Üí PBMor (B x) (Œ£P X B)
  Œ£-intro x .PBMor.f b = x , b
  Œ£-intro x .PBMor.isMon {x = b‚ÇÅ} {y = b‚ÇÇ} b‚ÇÅ‚â§b‚ÇÇ =
    refl , subst (Œª b ‚Üí rel-‚â§ (B x) b b‚ÇÇ) (sym (transportRefl b‚ÇÅ)) b‚ÇÅ‚â§b‚ÇÇ
  Œ£-intro x .PBMor.pres‚âà {x = b‚ÇÅ} {y = b‚ÇÇ} b‚ÇÅ‚âàb‚ÇÇ =
    refl , subst (Œª b ‚Üí rel-‚âà (B x) b b‚ÇÇ) (sym (transportRefl b‚ÇÅ)) b‚ÇÅ‚âàb‚ÇÇ

  Œ£-intro' : {A : PosetBisim ‚ÑìA ‚Ñì‚â§A ‚Ñì‚âàA} ‚Üí
    (g : ‚ü® A ‚ü© ‚Üí ‚ü® X ‚ü©) ‚Üí ((a : ‚ü® A ‚ü©) ‚Üí PBMor A (B (g a))) ‚Üí PBMor A (Œ£P X B)
  Œ£-intro' g h .PBMor.f a = (g a) , h a .PBMor.f a
  Œ£-intro' g h .PBMor.isMon {x = a‚ÇÅ} {y = a‚ÇÇ} a‚ÇÅ‚â§a‚ÇÇ = {!!} , {!!}
  Œ£-intro' g h .PBMor.pres‚âà = {!!}
    -- record {
    -- f = Œª x ‚Üí g.f x , h.f x
    -- ; isMon = Œª x‚â§y ‚Üí (g.isMon x‚â§y) , (h.isMon x‚â§y)
    -- ; pres‚âà = Œª x‚âày ‚Üí (g.pres‚âà x‚âày) , (h.pres‚âà x‚âày)
    -- } where
    -- module g = PBMor g
    -- module h = PBMor h

  Œ£-elim‚ÇÅ : ‚ü® (Œ£P X B) ‚ü© ‚Üí ‚ü® X ‚ü©
  Œ£-elim‚ÇÅ = fst

  Œ£-elim‚ÇÇ : (p : ‚ü® Œ£P X B ‚ü©) ‚Üí ‚ü® B (Œ£-elim‚ÇÅ p) ‚ü©
  Œ£-elim‚ÇÇ = snd

-- Action of Œ£ on a family of morphisms
Œ£-mor : ‚àÄ {‚Ñì ‚Ñì‚â§ ‚Ñì‚âà}
  (X : hSet ‚ÑìX) ‚Üí
  (A B : ‚ü® X ‚ü© ‚Üí PosetBisim ‚Ñì ‚Ñì‚â§ ‚Ñì‚âà) ‚Üí
  ((x : ‚ü® X ‚ü©) ‚Üí PBMor (A x) (B x)) ‚Üí
  PBMor (Œ£P X A) (Œ£P X B)
-- Œ£-mor X A B fs = {!!}
Œ£-mor X A B fs .PBMor.f (x , a) = (x , fs x .PBMor.f a)

Œ£-mor X A B fs .PBMor.isMon {x = (x‚ÇÅ , a‚ÇÅ)} {y = (x‚ÇÇ , a‚ÇÇ)} (x‚ÇÅ‚â°x‚ÇÇ , a‚ÇÅ‚ÇÇ‚â§a‚ÇÇ) = x‚ÇÅ‚â°x‚ÇÇ , aux
  where
    open PBMor 
    TA : ‚ü® X ‚ü© ‚Üí Type _
    TA = Œª x ‚Üí ‚ü® A x ‚ü©

    TB : ‚ü® X ‚ü© ‚Üí Type _
    TB = Œª x ‚Üí ‚ü® B x ‚ü©

    a‚ÇÅ‚ÇÇ = subst TA x‚ÇÅ‚â°x‚ÇÇ a‚ÇÅ

    -- fs x‚ÇÇ a‚ÇÅ‚ÇÇ ‚â§ fs x‚ÇÇ a‚ÇÇ
    lem1 : rel-‚â§ (B x‚ÇÇ) (fs x‚ÇÇ .f a‚ÇÅ‚ÇÇ) (fs x‚ÇÇ .f a‚ÇÇ)
    lem1 = fs x‚ÇÇ .isMon a‚ÇÅ‚ÇÇ‚â§a‚ÇÇ

    lem2 : PathP (Œª i ‚Üí ‚ü® B (x‚ÇÅ‚â°x‚ÇÇ i) ‚ü©) (fs x‚ÇÅ .f a‚ÇÅ) (fs x‚ÇÇ .f a‚ÇÅ‚ÇÇ)
    lem2 i = fs (x‚ÇÅ‚â°x‚ÇÇ i) .f (subst-filler TA x‚ÇÅ‚â°x‚ÇÇ a‚ÇÅ i)

    lem3 : (subst TB x‚ÇÅ‚â°x‚ÇÇ (fs x‚ÇÅ .f a‚ÇÅ)) ‚â° fs x‚ÇÇ .f a‚ÇÅ‚ÇÇ
    lem3 = fromPathP lem2
    
    -- lem2 : (fs x‚ÇÇ .f a‚ÇÅ‚ÇÇ) ‚â° (subst TB x‚ÇÅ‚â°x‚ÇÇ (fs x‚ÇÅ .f a‚ÇÅ))
    -- lem2 =
    --   fs x‚ÇÇ .f a‚ÇÅ‚ÇÇ
    --   ‚â°‚ü® cong (fs x‚ÇÇ .f) (sym {!subst-filler TA ? a‚ÇÇ!}) ‚ü© fs x‚ÇÇ .f a‚ÇÇ
    --   ‚â°‚ü® (subst-filler (Œª _ ‚Üí B x‚ÇÇ .fst) x‚ÇÅ‚â°x‚ÇÇ (fs x‚ÇÇ .f a‚ÇÇ)) ‚ü© _
    --   ‚â°‚ü® {!!} ‚ü©
    --   _ ‚àé
 
    aux : rel-‚â§ (B x‚ÇÇ) (subst TB x‚ÇÅ‚â°x‚ÇÇ (fs x‚ÇÅ .f a‚ÇÅ)) (fs x‚ÇÇ .f a‚ÇÇ)
    aux = subst (Œª z ‚Üí rel-‚â§ (B x‚ÇÇ) z (fs x‚ÇÇ .f a‚ÇÇ)) (sym lem3) lem1 
  
Œ£-mor X A B fs .PBMor.pres‚âà = {!!}
-- Œ†-intro (Œª y ‚Üí (fs y) ‚àòp (Œ†-elim {B = A} y))





ùîΩ : (Clock -> PosetBisim ‚Ñì ‚Ñì' ‚Ñì'') -> PosetBisim ‚Ñì ‚Ñì' ‚Ñì''
ùîΩ {‚Ñì' = ‚Ñì'} {‚Ñì'' = ‚Ñì''} A = (‚àÄ k -> ‚ü® A k ‚ü©) ,
  (posetbisimstr
    (Œª f g pf1 pf2 i1 i2 k ‚Üí
      is-set-PosetBisim (A k) (f k) (g k) (Œª i' ‚Üí pf1 i' k) (Œª i' -> pf2 i' k) i1 i2)
    order (isorderingrelation
      (Œª f g pf1 pf2 i k ‚Üí prop-valued-‚â§ (A k) (f k) (g k) (pf1 k) (pf2 k) i )
      (Œª f k ‚Üí reflexive-‚â§ (A k) (f k))
      (Œª f g h f‚â§g g‚â§h k ‚Üí transitive-‚â§ (A k) (f k) (g k) (h k) (f‚â§g k) (g‚â§h k))
      Œª f g f‚â§g g‚â§f i k ‚Üí antisym-‚â§ (A k) (f k) (g k) (f‚â§g k) (g‚â§f k) i)
    bisim (isbisim
      (Œª f k ‚Üí reflexive-‚âà (A k) (f k))
      (Œª f g f‚âàg k ‚Üí sym-‚âà (A k) (f k) (g k) (f‚âàg k))
      Œª f g pf1 pf2 i k ‚Üí prop-valued-‚âà (A k) (f k) (g k) (pf1 k) (pf2 k) i))
    where
      order : ((k : Clock) ‚Üí ‚ü® A k ‚ü©) -> ((k : Clock) ‚Üí ‚ü® A k ‚ü©) -> Type ‚Ñì'
      order a a' = ‚àÄ k -> rel-‚â§ (A k) (a k) (a' k)

      bisim : ((k : Clock) ‚Üí ‚ü® A k ‚ü©) -> ((k : Clock) ‚Üí ‚ü® A k ‚ü©) -> Type ‚Ñì''
      bisim a a' = ‚àÄ k -> rel-‚âà (A k) (a k) (a' k)



-- Contructions involving later
module Clocked (k : Clock) where

  private
    ‚ñπ_ : Type ‚Ñì -> Type ‚Ñì
    ‚ñπ A = ‚ñπ_,_ k A

    -- Theta for double posets
  PB‚ñ∏ : ‚ñπ PosetBisim ‚Ñì ‚Ñì' ‚Ñì'' ‚Üí PosetBisim ‚Ñì ‚Ñì' ‚Ñì''
  PB‚ñ∏ X = (‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©)) ,
            (posetbisimstr
              is-set-later ord
              (isorderingrelation ord-prop-valued ord-refl ord-trans ord-antisym)
              bisim
              (isbisim bisim-refl bisim-sym bisim-prop-valued))

        where
          ord : ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©) ‚Üí ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©) ‚Üí Type _
          ord x1~ x2~ =  ‚ñ∏ (Œª t ‚Üí (PosetBisimStr._‚â§_ (str (X t)) (x1~ t)) (x2~ t))

          is-set-later : isSet (‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©))
          is-set-later = Œª x y p1 p2 i j t ‚Üí
            is-set-PosetBisim (X t) (x t) (y t) (Œª i' ‚Üí p1 i' t) (Œª i' ‚Üí p2 i' t) i j

          ord-prop-valued : isPropValued ord
          ord-prop-valued = Œª a b p q ‚Üí
            isProp‚ñ∏ (Œª t -> prop-valued-‚â§ (X t) (a t) (b t)) p q

          ord-refl : (a : ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©)) -> ord a a
          ord-refl a = Œª t -> reflexive-‚â§ (X t) (a t)

          ord-trans : isTrans ord
          ord-trans = Œª a b c a‚â§b b‚â§c t ‚Üí
            transitive-‚â§ (X t) (a t) (b t) (c t) (a‚â§b t) (b‚â§c t)

          ord-antisym : isAntisym ord
          ord-antisym = Œª a b a‚â§b b‚â§a i t ->
            antisym-‚â§ (X t) (a t) (b t) (a‚â§b t) (b‚â§a t) i

          bisim : ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©) ‚Üí ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©) ‚Üí Type _
          bisim x1~ x2~ = ‚ñ∏ (Œª t ‚Üí (PosetBisimStr._‚âà_ (str (X t)) (x1~ t)) (x2~ t))

          bisim-refl : (a : ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©)) -> bisim a a
          bisim-refl a = Œª t ‚Üí reflexive-‚âà (X t) (a t)

          bisim-sym : isSym bisim
          bisim-sym = Œª a b a‚âàb t ‚Üí sym-‚âà (X t) (a t) (b t) (a‚âàb t)

          bisim-prop-valued : isPropValued bisim
          bisim-prop-valued = Œª a b pf1 pf2 ‚Üí
            isProp‚ñ∏ (Œª t ‚Üí prop-valued-‚âà (X t) (a t) (b t)) pf1 pf2

  PB‚ñ∏'_ : PosetBisim ‚Ñì ‚Ñì' ‚Ñì'' ‚Üí PosetBisim ‚Ñì ‚Ñì' ‚Ñì''
  PB‚ñ∏' X = PB‚ñ∏ (next X)

  PB‚ñπ_ : PosetBisim ‚Ñì ‚Ñì' ‚Ñì'' ‚Üí PosetBisim ‚Ñì ‚Ñì' ‚Ñì''
  PB‚ñπ X = PB‚ñ∏ (next X)

  -- PB‚ñ∏-next : (X : PosetBisim ‚Ñì ‚Ñì' ‚Ñì'') -> PB‚ñ∏ (next X) ‚â° PB‚ñπ X
  -- PB‚ñ∏-next = {!refl!}


  -- We can turn a "later" morphism f : ‚ñ∏_t ((X~ t) ‚Üí (Y~ t))
  -- into a morphism ‚ñ∏f : (PB‚ñ∏ X~) ‚Üí (PB‚ñ∏ Y~).
  PBMor‚ñ∏ : {X~ : ‚ñπ PosetBisim ‚ÑìX ‚Ñì'X ‚Ñì''X} {Y~ : ‚ñπ PosetBisim ‚ÑìY ‚Ñì'Y ‚Ñì''Y} ->
    (‚ñ∏ (Œª t -> PBMor (X~ t) (Y~ t))) ‚Üí
    (PBMor (PB‚ñ∏ X~) (PB‚ñ∏ Y~))
  PBMor‚ñ∏ {X~ = X~} f~ .PBMor.f x~ =
    Œª t -> PBMor.f (f~ t) (x~ t) -- or : map‚ñπ MonFun.f f~ ‚äõ x~
  PBMor‚ñ∏ {X~ = X~} f~ .PBMor.isMon {x~} {y~} x~‚â§y~ =
    Œª t -> PBMor.isMon (f~ t) (x~‚â§y~ t)
  PBMor‚ñ∏ {X~ = X~} f~ .PBMor.pres‚âà {x~} {y~} x~‚â§y~ =
    Œª t -> PBMor.pres‚âà (f~ t) (x~‚â§y~ t)


Zero : PBMor UnitPB ‚Ñï
Zero = record {
  f = Œª _ ‚Üí zero ;
  isMon = Œª _ ‚Üí refl ;
  pres‚âà = Œª _ ‚Üí refl }

Suc : PBMor (UnitPB √ódp ‚Ñï) ‚Ñï
Suc = record {
  f = Œª (_ , n) ‚Üí suc n ;
  isMon = Œª { {_ , n} {_ , m} (_ , n‚â°m) ‚Üí cong suc n‚â°m} ;
  pres‚âà = Œª { {_ , n} {_ , m} (_ , n‚â°m) ‚Üí cong suc n‚â°m} }

Unit-√óL : {X : Type ‚Ñì} -> Unit √ó X ‚âÉ X
Unit-√óL = isoToEquiv
  (iso (Œª {(_ , x) -> x}) (Œª x -> (tt , x)) (Œª x ‚Üí refl) (Œª p ‚Üí refl))



{-
UnitP-√óL-equiv : {X : Poset ‚Ñì ‚Ñì'} -> PosetEquiv (UnitP √óp X) X
UnitP-√óL-equiv .fst = Unit-√óL
UnitP-√óL-equiv .snd = makeIsPosetEquiv Unit-√óL is-mon is-mon-inv
  where
    is-mon : _
    is-mon (_ , x) (_ , x') (_ , x‚â§x') = x‚â§x'

    is-mon-inv : _
    is-mon-inv x x' x‚â§x' = refl , x‚â§x'

UnitP-√óL : {X : Poset ‚Ñì ‚Ñì'} -> (UnitP √óp X) ‚â° X
UnitP-√óL {X = X} = equivFun (PosetPath (UnitP √óp X) X) UnitP-√óL-equiv-}
