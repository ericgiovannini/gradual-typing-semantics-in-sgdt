{-# OPTIONS --rewriting --guarded #-}

 -- to allow opening this module in other files while there are still holes
{-# OPTIONS --allow-unsolved-metas #-}

{-# OPTIONS --lossy-unification #-}

open import Common.Later

module Semantics.Concrete.Dyn (k : Clock) where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Structure
open import Cubical.Foundations.Transport

open import Cubical.Relation.Binary.Base

open import Cubical.Data.Nat hiding (_¬∑_)
open import Cubical.Data.Empty
open import Cubical.Data.Sigma
open import Cubical.Data.Sum

 -- open import Cubical.Algebra.Monoid.FreeProduct


open import Semantics.Concrete.GuardedLiftError k
open import Semantics.Concrete.DoublePoset.Base
open import Semantics.Concrete.DoublePoset.Constructions renaming (‚Ñï to NatP)
open import Semantics.Concrete.DoublePoset.DblPosetCombinators
open import Semantics.Concrete.DoublePoset.Morphism
open import Semantics.Concrete.DoublePoset.DPMorRelation
open import Semantics.Concrete.DoublePoset.PBSquare

open import Semantics.Concrete.DoublePoset.FreeErrorDomain k



private
  variable
    ‚Ñì ‚Ñì' : Level
    ‚ÑìA ‚Ñì‚â§A ‚Ñì‚âàA : Level
    ‚Ñì‚â§ ‚Ñì‚âà : Level

  ‚ñπ_ : {‚Ñì : Level} ‚Üí Type ‚Ñì ‚Üí Type ‚Ñì
  ‚ñπ_ A = ‚ñπ_,_ k A

open BinaryRelation
open LiftPredomain
open Clocked k

module DynDef {‚Ñì : Level} where

 -- The underlying inductive type on which Dyn will be based.
 -- 
 -- If we say X : PosetBisim ‚Ñì here, then Agda gets stuck when
 -- type-checking the line `unfold-Dyn = fix-eq Guarded.Dyn'`
 -- (this happened with lossy-unification turned off; not tried
 --  when it is turned on)
  data DynTy (X : Type ‚Ñì) : Type ‚Ñì where

    nat : ‚Ñï ‚Üí DynTy X
    prod : DynTy X ‚Üí DynTy X ‚Üí DynTy X
    fun : X ‚Üí DynTy X
    -- TODO should we add is-set?

  nat-injective : ‚àÄ {X : Type ‚Ñì} n m ‚Üí
    (nat {X = X} n ‚â° nat m) ‚Üí n ‚â° m
  nat-injective {X = X} n m eq = cong aux eq
    where
      aux : DynTy X ‚Üí ‚Ñï
      aux (nat n) = n
      aux (prod d‚ÇÅ d‚ÇÇ) = 0
      aux (fun x) = 0
  
  prod-injective : ‚àÄ {X : Type ‚Ñì} d‚ÇÅ d‚ÇÇ d‚ÇÅ' d‚ÇÇ' ‚Üí
    (prod {X = X} d‚ÇÅ d‚ÇÇ) ‚â° (prod d‚ÇÅ' d‚ÇÇ') ‚Üí ((d‚ÇÅ ‚â° d‚ÇÅ') √ó (d‚ÇÇ ‚â° d‚ÇÇ'))
  prod-injective {X = X} d‚ÇÅ d‚ÇÇ d‚ÇÅ' d‚ÇÇ' eq = (cong fst (cong aux eq)) , (cong snd (cong aux eq))
    where
      aux : DynTy X ‚Üí (DynTy X √ó DynTy X)
      aux (nat n) = (d‚ÇÅ , d‚ÇÇ)
      aux (prod d‚ÇÅ'' d‚ÇÇ'') = (d‚ÇÅ'' , d‚ÇÇ'')
      aux (fun x) = (d‚ÇÅ , d‚ÇÇ)
  
  fun-injective : {X : Type ‚Ñì} ‚Üí
    ‚àÄ (x y : X) ‚Üí fun x ‚â° fun y ‚Üí x ‚â° y
  fun-injective {X = X} x y eq = cong aux eq
    where
      aux : DynTy X ‚Üí X
      aux (nat n) = x
      aux (prod d‚ÇÅ d‚ÇÇ) = x
      aux (fun x') = x'
      

  DynTyIso : ‚àÄ X ‚Üí Iso (DynTy X) ((‚Ñï ‚äé (DynTy X √ó DynTy X)) ‚äé X)
  DynTyIso X = iso
    (Œª { (nat n) ‚Üí inl (inl n) ;
         (prod d‚ÇÅ d‚ÇÇ) ‚Üí inl (inr (d‚ÇÅ , d‚ÇÇ)) ;
         (fun x) ‚Üí inr x })
    (Œª { (inl (inl n)) ‚Üí nat n ;
         (inl (inr (d‚ÇÅ , d‚ÇÇ))) ‚Üí prod d‚ÇÅ d‚ÇÇ ;
         (inr x) ‚Üí fun x})
    (Œª { (inl (inl n)) ‚Üí refl ; (inl (inr pair)) ‚Üí refl ; (inr x) ‚Üí refl})
    (Œª { (nat n) ‚Üí refl ; (prod d‚ÇÅ d‚ÇÇ) ‚Üí refl ; (fun x) ‚Üí refl})


  -- Defining Dyn as a predomain under the assumption of a
  -- later-predomain D~.
  module Guarded (D~ : ‚ñπ (PosetBisim ‚Ñì ‚Ñì ‚Ñì)) where

    Fun = ‚ü® PB‚ñ∏ (Œª t ‚Üí (D~ t) ==> ùïÉ (D~ t)) ‚ü©
    module Fun = PosetBisimStr (PB‚ñ∏ (Œª t ‚Üí (D~ t) ==> ùïÉ (D~ t)) .snd)

    open IsOrderingRelation

    --------------------------------
    -- The ordering relation on dyn
    --------------------------------
    data _‚äëd_ : DynTy Fun ‚Üí DynTy Fun ‚Üí Type ‚Ñì where
      ‚äë-nat : ‚àÄ {n m} ‚Üí n ‚â° m ‚Üí (nat n) ‚äëd (nat m)
      ‚äë-prod : ‚àÄ {d‚ÇÅ d‚ÇÇ d‚ÇÅ' d‚ÇÇ'} ‚Üí (d‚ÇÅ ‚äëd d‚ÇÅ') ‚Üí (d‚ÇÇ ‚äëd d‚ÇÇ') ‚Üí
        (prod d‚ÇÅ d‚ÇÇ) ‚äëd (prod d‚ÇÅ' d‚ÇÇ')
      ‚äë-fun : ‚àÄ {f~ g~} ‚Üí f~ Fun.‚â§ g~ ‚Üí (fun f~) ‚äëd (fun g~)

    ‚äëd-prop : isPropValued _‚äëd_
    ‚äëd-prop .(nat n) .(nat m) (‚äë-nat {n} {m} p) (‚äë-nat .{n} .{m} q) =
      Œª i ‚Üí ‚äë-nat (isSet‚Ñï n m p q i)
    ‚äëd-prop .(prod d‚ÇÅ d‚ÇÇ) .(prod d‚ÇÅ' d‚ÇÇ')
      (‚äë-prod {d‚ÇÅ} {d‚ÇÇ} {d‚ÇÅ'} {d‚ÇÇ'} p q) (‚äë-prod .{d‚ÇÅ} .{d‚ÇÇ} .{d‚ÇÅ'} .{d‚ÇÇ'} p' q') =
      Œª i ‚Üí ‚äë-prod (‚äëd-prop d‚ÇÅ d‚ÇÅ' p p' i) (‚äëd-prop d‚ÇÇ d‚ÇÇ' q q' i)
    ‚äëd-prop .(fun f~) .(fun g~) (‚äë-fun {f~} {g~} p) (‚äë-fun .{f~} .{g~} q) =
      Œª i ‚Üí ‚äë-fun (Fun.is-prop-valued f~ g~ p q i)

    ‚äëd-refl : isRefl _‚äëd_
    ‚äëd-refl (nat n) = ‚äë-nat refl
    ‚äëd-refl (prod d‚ÇÅ d‚ÇÇ) = ‚äë-prod (‚äëd-refl d‚ÇÅ) (‚äëd-refl d‚ÇÇ)
    ‚äëd-refl (fun f~) = ‚äë-fun (Fun.is-refl f~)

    ‚äëd-trans : isTrans _‚äëd_
    ‚äëd-trans .(nat _) .(nat _) .(nat _) (‚äë-nat eq1) (‚äë-nat eq2) =
      ‚äë-nat (eq1 ‚àô eq2)
    ‚äëd-trans .(prod _ _) .(prod _ _) .(prod _ _)
     (‚äë-prod {d‚ÇÅ} {d‚ÇÇ} {d‚ÇÅ'} {d‚ÇÇ'} p q) (‚äë-prod .{d‚ÇÅ'} .{d‚ÇÇ'} {d‚ÇÅ''} {d‚ÇÇ''} p' q') =
     ‚äë-prod (‚äëd-trans d‚ÇÅ d‚ÇÅ' d‚ÇÅ'' p p') (‚äëd-trans d‚ÇÇ d‚ÇÇ' d‚ÇÇ'' q q')
    ‚äëd-trans .(fun _) .(fun _) .(fun _) (‚äë-fun {f~} {g~} p) (‚äë-fun .{g~} {h~} q) =
      ‚äë-fun (Fun.is-trans f~ g~ h~ p q)

    ‚äëd-antisym : isAntisym _‚äëd_
    ‚äëd-antisym .(nat _) .(nat _) (‚äë-nat eq1) (‚äë-nat eq2) =
      cong nat eq1
    ‚äëd-antisym .(prod _ _) .(prod _ _) (‚äë-prod p q) (‚äë-prod p' q') =
      cong‚ÇÇ prod (‚äëd-antisym _ _ p p') (‚äëd-antisym _ _ q q')
    ‚äëd-antisym .(fun _) .(fun _) (‚äë-fun p) (‚äë-fun q) =
      cong fun (Fun.is-antisym _ _ p q)


    ------------------------------------
    -- The bisimilarity relation on dyn
    ------------------------------------
    data _‚âàd_ : DynTy Fun ‚Üí DynTy Fun ‚Üí Type ‚Ñì where
      ‚âà-nat : ‚àÄ {n m} ‚Üí n ‚â° m ‚Üí (nat n) ‚âàd (nat m)
      ‚âà-prod : ‚àÄ {d‚ÇÅ d‚ÇÇ d‚ÇÅ' d‚ÇÇ'} ‚Üí (d‚ÇÅ ‚âàd d‚ÇÅ') ‚Üí (d‚ÇÇ ‚âàd d‚ÇÇ') ‚Üí
        (prod d‚ÇÅ d‚ÇÇ) ‚âàd (prod d‚ÇÅ' d‚ÇÇ')
      ‚âà-fun : ‚àÄ {f~ g~} ‚Üí f~ Fun.‚âà g~ ‚Üí (fun f~) ‚âàd (fun g~)

    ‚âàd-prop : isPropValued _‚âàd_
    ‚âàd-prop .(nat n) .(nat m) (‚âà-nat {n} {m} p) (‚âà-nat .{n} .{m} q) =
      Œª i ‚Üí ‚âà-nat (isSet‚Ñï n m p q i)
    ‚âàd-prop .(prod d‚ÇÅ d‚ÇÇ) .(prod d‚ÇÅ' d‚ÇÇ')
      (‚âà-prod {d‚ÇÅ} {d‚ÇÇ} {d‚ÇÅ'} {d‚ÇÇ'} p q) (‚âà-prod .{d‚ÇÅ} .{d‚ÇÇ} .{d‚ÇÅ'} .{d‚ÇÇ'} p' q') =
      Œª i ‚Üí ‚âà-prod (‚âàd-prop d‚ÇÅ d‚ÇÅ' p p' i) (‚âàd-prop d‚ÇÇ d‚ÇÇ' q q' i)
    ‚âàd-prop .(fun f~) .(fun g~) (‚âà-fun {f~} {g~} p) (‚âà-fun .{f~} .{g~} q) =
      Œª i ‚Üí ‚âà-fun (Fun.is-prop-valued-Bisim f~ g~ p q i)

    ‚âàd-refl : isRefl _‚âàd_
    ‚âàd-refl (nat n) = ‚âà-nat refl
    ‚âàd-refl (prod d‚ÇÅ d‚ÇÇ) = ‚âà-prod (‚âàd-refl d‚ÇÅ) (‚âàd-refl d‚ÇÇ)
    ‚âàd-refl (fun f~) = ‚âà-fun (Fun.is-refl-Bisim f~)

    ‚âàd-sym : isSym _‚âàd_
    ‚âàd-sym .(nat n) .(nat m) (‚âà-nat {n} {m} p) = ‚âà-nat (sym p)
    ‚âàd-sym .(prod d‚ÇÅ d‚ÇÇ) .(prod d‚ÇÅ' d‚ÇÇ')
      (‚âà-prod {d‚ÇÅ} {d‚ÇÇ} {d‚ÇÅ'} {d‚ÇÇ'} p q) = ‚âà-prod (‚âàd-sym _ _ p) (‚âàd-sym _ _ q)
    ‚âàd-sym .(fun f~) .(fun g~) (‚âà-fun {f~} {g~} p) = ‚âà-fun (Fun.is-sym f~ g~ p)
  

    --------------------------
    -- Defining the predomain
    --------------------------

    -- We take the type of Dyn' to be the type DynTy defined above,
    -- instantiated with the type of later predomain morphisms from
    -- (D~ t) to ùïÉ (D~ t).
    Dyn' : PosetBisim ‚Ñì ‚Ñì ‚Ñì
    -- PosetBisim (‚Ñì-max (‚Ñì-max ‚Ñì ‚Ñì‚â§) ‚Ñì‚âà) (‚Ñì-max ‚Ñì ‚Ñì‚â§) (‚Ñì-max ‚Ñì ‚Ñì‚âà)
    Dyn' .fst = DynTy ‚ü® PB‚ñ∏ (Œª t ‚Üí (D~ t) ==> ùïÉ (D~ t)) ‚ü©
    Dyn' .snd = posetbisimstr {!!} _‚äëd_ {!!} _‚âàd_ {!!}
    -- posetbisimstr set ord isOrd bisim isBisim
      where

        set : isSet (DynTy Fun)
        set = {!!}
        -- set (nat n) (nat m) p q = {!!}
        -- set (nat n) (prod d‚ÇÇ d‚ÇÉ) p q = {!!}
        -- set (nat n) (fun g~) p q = {!!}
        -- set (prod d‚ÇÅ d‚ÇÇ) (nat x) p q = {!!}
        -- set (prod d‚ÇÅ d‚ÇÇ) (prod d‚ÇÅ' d‚ÇÇ') p q = {!!}
        -- set (prod d‚ÇÅ d‚ÇÇ) (fun x) p q = {!!}
        -- set (fun x) d‚ÇÇ p q = {!!}

        -- Ordering relation and properties
{-
        ord : DynTy Fun ‚Üí DynTy Fun ‚Üí Type ‚Ñì
        ord (nat n) (nat m) = Lift (n ‚â° m)
        ord (prod d‚ÇÅ d‚ÇÇ) (prod d‚ÇÅ' d‚ÇÇ') = (ord d‚ÇÅ d‚ÇÅ') √ó (ord d‚ÇÇ d‚ÇÇ')
        ord (fun f~) (fun g~) = f~ Fun.‚â§ g~
        ord _ _ = ‚ä•*

        ord-refl : isRefl ord
        ord-refl (nat n) = lift refl
        ord-refl (prod d‚ÇÅ d‚ÇÇ) = (ord-refl d‚ÇÅ) , (ord-refl d‚ÇÇ)
        ord-refl (fun f~) = Fun.is-refl f~

        ord-prop-valued : isPropValued ord
        ord-prop-valued (nat n) (nat m) p q =
          let is-prop = isOfHLevelLift 1 (isSet‚Ñï n m) in is-prop p q
          -- also works:
          -- Œª i ‚Üí lift (isSet‚Ñï n m (lower p) (lower q) i)
        ord-prop-valued (prod d‚ÇÅ d‚ÇÇ) (prod d‚ÇÅ' d‚ÇÇ') =
          isProp√ó (ord-prop-valued d‚ÇÅ d‚ÇÅ') (ord-prop-valued d‚ÇÇ d‚ÇÇ')
        ord-prop-valued (fun f~) (fun g~) = Fun.is-prop-valued f~ g~

        ord-trans : isTrans ord
        ord-trans (nat n) (nat m) (nat p) (lift eq1) (lift eq2) = lift (eq1 ‚àô eq2)
        ord-trans (prod d‚ÇÅ d‚ÇÇ) (prod d‚ÇÅ' d‚ÇÇ') (prod d‚ÇÅ'' d‚ÇÇ'')
                  (d‚ÇÅ‚â§d‚ÇÅ' , d‚ÇÇ‚â§d‚ÇÇ') (d‚ÇÅ'‚â§d‚ÇÅ'' , d‚ÇÇ'‚â§d‚ÇÇ'') =
                  ord-trans d‚ÇÅ d‚ÇÅ' d‚ÇÅ'' d‚ÇÅ‚â§d‚ÇÅ' d‚ÇÅ'‚â§d‚ÇÅ'' ,
                  ord-trans d‚ÇÇ d‚ÇÇ' d‚ÇÇ'' d‚ÇÇ‚â§d‚ÇÇ' d‚ÇÇ'‚â§d‚ÇÇ''
        ord-trans (fun f~) (fun g~) (fun h~) = Fun.is-trans f~ g~ h~

        ord-antisym : isAntisym ord
        ord-antisym (nat n) (nat m) p q = cong nat (lower p)
        ord-antisym (prod d‚ÇÅ d‚ÇÇ) (prod d‚ÇÅ' d‚ÇÇ') p q = {!!}
        ord-antisym (fun f~) (fun g~) f~‚â§g~ g~‚â§f~ =
          cong fun (Fun.is-antisym f~ g~ f~‚â§g~ g~‚â§f~)

        isOrd : IsOrderingRelation ord
        isOrd .is-prop-valued = ord-prop-valued
        isOrd .is-refl = ord-refl
        isOrd .is-trans = ord-trans
        isOrd .is-antisym = ord-antisym


        -- Bisimilarity relation and properties

        bisim : DynTy Fun ‚Üí DynTy Fun ‚Üí Type ‚Ñì
        bisim (nat n) (nat m) = Lift (n ‚â° m)
        bisim (prod d‚ÇÅ d‚ÇÇ) (prod d‚ÇÅ' d‚ÇÇ') = (bisim d‚ÇÅ d‚ÇÅ') √ó (bisim d‚ÇÇ d‚ÇÇ')
        bisim (fun f~) (fun g~) = f~ Fun.‚âà g~
        bisim _ _ = ‚ä•*

        bisim-refl : isRefl bisim
        bisim-refl (nat n) = lift refl
        bisim-refl (prod d‚ÇÅ d‚ÇÇ) = (bisim-refl d‚ÇÅ) , (bisim-refl d‚ÇÇ)
        bisim-refl (fun f~) = Fun.is-refl-Bisim f~

        bisim-sym : isSym bisim
        bisim-sym = {!!}

        bisim-prop : isPropValued bisim
        bisim-prop = {!!}

        isBisim : IsBisim bisim
        isBisim .IsBisim.is-refl = bisim-refl
        isBisim .IsBisim.is-sym = bisim-sym
        isBisim .IsBisim.is-prop-valued = bisim-prop

-}


  -- We define the predomain Dyn using guarded fixpoint:
  Dyn : PosetBisim ‚Ñì ‚Ñì ‚Ñì
  Dyn = fix Guarded.Dyn'

  unfold-Dyn : Dyn ‚â° Guarded.Dyn' (next Dyn)
  unfold-Dyn = fix-eq Guarded.Dyn'

  Dyn‚ÜíDyn' : PBMor Dyn (Guarded.Dyn' (next Dyn))
  Dyn‚ÜíDyn' = mTransport unfold-Dyn

  Dyn'‚ÜíDyn : PBMor (Guarded.Dyn' (next Dyn)) Dyn
  Dyn'‚ÜíDyn = mTransport (sym unfold-Dyn)

  unfold-fold :  Dyn'‚ÜíDyn ‚àòp Dyn‚ÜíDyn' ‚â° Id
  unfold-fold = eqPBMor _ _ (funExt (Œª d ‚Üí transport‚ÅªTransport (Œª i ‚Üí ‚ü® unfold-Dyn i ‚ü©) d ))
  -- transport‚ÅªTransport unfold-Dyn d

  fold-unfold :  Dyn‚ÜíDyn' ‚àòp Dyn'‚ÜíDyn ‚â° Id
  fold-unfold = eqPBMor _ _ (funExt Œª d ‚Üí transportTransport‚Åª (Œª i ‚Üí ‚ü® unfold-Dyn i ‚ü©) d)
  -- transportTransport‚Åª unfold-Dyn d'


  -- We can show an equality involving the underlying type of dyn:
  Dyn-Ty : ‚ü® Dyn ‚ü© ‚â° DynTy (‚ñπ (PBMor Dyn (ùïÉ Dyn)))
  Dyn-Ty = cong ‚ü®_‚ü© unfold-Dyn

  -- But we can't easily show that Dyn is isomorphic *as a predomain*
  -- to (‚Ñï + (Dyn √ó Dyn) + ‚ñπ (Dyn -> ùïÉ Dyn)).
  

  ----------------------
  -- Embeddings for dyn
  ----------------------
  module Embeddings where

    open PBMor

    open Guarded (next Dyn)

    -- emb-nat' : ‚Ñï ‚Üí ‚ü® Dyn' ‚ü©
    -- emb-nat' n = nat n

    -- emb-prod' : ‚ü® Dyn' ‚ü© ‚Üí ‚ü® Dyn' ‚ü© ‚Üí ‚ü® Dyn' ‚ü©
    -- emb-prod' d‚ÇÅ d‚ÇÇ = prod d‚ÇÅ d‚ÇÇ

    -- emb-fun' : (‚ñπ (PBMor Dyn (ùïÉ Dyn))) ‚Üí ‚ü® Dyn' ‚ü©
    -- emb-fun' = fun

    emb-nat' : PBMor NatP Dyn'
    emb-nat' .f = nat
    emb-nat' .isMon n‚â°m = ‚äë-nat n‚â°m
    emb-nat' .pres‚âà n‚â°m = ‚âà-nat n‚â°m

    emb-times' : PBMor (Dyn' √ódp Dyn') Dyn'
    emb-times' .f (d‚ÇÅ , d‚ÇÇ) = prod d‚ÇÅ d‚ÇÇ
    emb-times' .isMon (p , q) = ‚äë-prod p q
    emb-times' .pres‚âà (p , q) = ‚âà-prod p q

    -- Note that this is not the same as the fun constructor,
    -- since that takes a **later** function.
    emb-arr' : PBMor (Dyn ==> ùïÉ Dyn) Dyn'
    emb-arr' .f g = fun (next g)
    emb-arr' .isMon g‚ÇÅ‚â§g‚ÇÇ = ‚äë-fun (Œª t ‚Üí g‚ÇÅ‚â§g‚ÇÇ)
    emb-arr' .pres‚âà g‚ÇÅ‚âàg‚ÇÇ = ‚âà-fun (Œª t ‚Üí g‚ÇÅ‚âàg‚ÇÇ)


  -----------------------------------
  -- Eliminator and recursor for Dyn
  -----------------------------------
  module ElimDyn where

   open Embeddings
   open Guarded (next (Dyn))
   open PBMor

   -- Because we don't have a notion of "dependent predomain", we can't
   -- talk about "dependent predomain morphisms", and thus we can only
   -- formulate an eliminator at the level of types.
   elimDyn : ‚àÄ (A : ‚ü® Dyn' ‚ü© ‚Üí Type ‚Ñì) ‚Üí
      (caseNat  : ‚àÄ (n : ‚Ñï)                           ‚Üí A (nat n))       ‚Üí
      (caseProd : ‚àÄ (d‚ÇÅ d‚ÇÇ : ‚ü® Dyn' ‚ü©) ‚Üí A d‚ÇÅ ‚Üí A d‚ÇÇ  ‚Üí A (prod d‚ÇÅ d‚ÇÇ))  ‚Üí
      (caseFun  : ‚àÄ (f~ : (‚ñπ (PBMor Dyn (ùïÉ Dyn))))    ‚Üí A (fun f~))      ‚Üí
      (‚àÄ (d : ‚ü® Dyn' ‚ü©) ‚Üí A d)
   elimDyn A caseNat caseProd caseFun = aux
     where
       aux : (d : ‚ü® Dyn' ‚ü©) ‚Üí A d
       aux (nat n) = caseNat n
       aux (prod d‚ÇÅ d‚ÇÇ) = caseProd d‚ÇÅ d‚ÇÇ (aux d‚ÇÅ) (aux d‚ÇÇ)
       aux (fun f~) = caseFun f~


  module RecDyn where
    open Guarded (next (Dyn))
    open PBMor

    recDyn : ‚àÄ {A : PosetBisim ‚ÑìA ‚Ñì‚â§A ‚Ñì‚âàA} ‚Üí
       (caseNat  : PBMor NatP A) ‚Üí
       (caseProd : PBMor (Dyn' √ódp Dyn') A) ‚Üí
       (caseFun  : PBMor (PB‚ñπ (Dyn ==> ùïÉ Dyn)) A) ‚Üí
       PBMor Dyn' A
    recDyn {A = A} caseNat caseProd caseFun = aux
      where
        module caseNat  = PBMor caseNat
        module caseProd = PBMor caseProd
        module caseFun  = PBMor caseFun

        aux : PBMor Dyn' A
        aux .f (nat n) = caseNat $ n
        aux .f (prod d‚ÇÅ d‚ÇÇ) = caseProd $ (d‚ÇÅ , d‚ÇÇ)
        aux .f (fun f~) = caseFun $ f~

        aux .isMon (Guarded.‚äë-nat eq)   = caseNat.isMon eq
        aux .isMon (Guarded.‚äë-prod p q) = caseProd.isMon (p , q)
        aux .isMon (Guarded.‚äë-fun p)    = caseFun.isMon p

        aux .pres‚âà (Guarded.‚âà-nat eq)   = caseNat.pres‚âà eq
        aux .pres‚âà (Guarded.‚âà-prod p q) = caseProd.pres‚âà (p , q)
        aux .pres‚âà (Guarded.‚âà-fun p)    = caseFun.pres‚âà p


----------------
-- Projections
---------------

  module Projections where

    open Guarded (next Dyn)
    open RecDyn
    open ClockedCombinators k

    proj-nat : PBMor Dyn' (ùïÉ NatP)
    proj-nat = recDyn (Œ∑-mor) (K _ ‚Ñß) (K _ ‚Ñß)

    proj-times : PBMor Dyn' (ùïÉ (Dyn' √ódp Dyn'))
    proj-times = recDyn (K _ ‚Ñß) (Œ∑-mor) (K _ ‚Ñß)

    proj-arr : PBMor Dyn' (ùïÉ (Dyn ==> ùïÉ Dyn))
    proj-arr = recDyn (K _ ‚Ñß) (K _ ‚Ñß) ((Œ∏-mor) ‚àòp (Map‚ñπ (Œ∑-mor)))
    --
    -- To project in the case of a later-function g~, we return
    -- Œ∏ (Œª t ‚Üí Œ∑ (g~ t)), which can also be written as Œ∏ (Map‚ñπ Œ∑ g~).
    --
    -- Rather than proving manually that this defines a morphism of
    -- predomains, we observe that we can express this as a
    -- composition of the predomain morphism Œ∏ composed with (Map‚ñπ Œ∑)

-------------------------------------------------------
-- Heterogeneous relations inj-nat, inj-times, inj-arr
-------------------------------------------------------

  module Relations where

    open Guarded (next Dyn)
    open Embeddings
    open PBRel

    inj-nat : PBRel NatP Dyn' ‚Ñì
    inj-nat = functionalRel emb-nat' Id (idPRel Dyn')

    inj-times : PBRel (Dyn' √ódp Dyn') Dyn' ‚Ñì
    inj-times = functionalRel emb-times' Id (idPRel Dyn')

    inj-arr : PBRel (Dyn ==> ùïÉ Dyn) Dyn' ‚Ñì
    inj-arr = functionalRel emb-arr' Id (idPRel Dyn')
