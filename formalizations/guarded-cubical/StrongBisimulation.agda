{-# OPTIONS --cubical --rewriting --guarded #-}

 -- to allow opening this module in other files while there are still holes
{-# OPTIONS --allow-unsolved-metas #-}

open import Later

module StrongBisimulation(k : Clock) where

open import Cubical.Relation.Binary
open import Cubical.Relation.Binary.Poset

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Function
open import Cubical.Foundations.Transport

open import Cubical.Data.Sigma

open import Cubical.Data.Nat hiding (_^_) renaming (‚Ñï to Nat)
open import Cubical.Data.Bool.Base
open import Cubical.Data.Bool.Properties hiding (_‚â§_)
open import Cubical.Data.Empty hiding (rec)
open import Cubical.Data.Sum hiding (rec)
open import Cubical.Foundations.Structure
open import Cubical.Foundations.HLevels

open import Cubical.Data.Unit.Properties

open import Agda.Primitive

private
  variable
    l : Level
    A B : Set l
    ‚Ñì ‚Ñì' : Level
private
  ‚ñπ_ : Set l ‚Üí Set l
  ‚ñπ_ A = ‚ñπ_,_ k A


id : {‚Ñì : Level} -> {A : Type ‚Ñì} -> A -> A
id x = x

_^_ : {‚Ñì : Level} -> {A : Type ‚Ñì} -> (A -> A) -> Nat -> A -> A
f ^ zero = id
f ^ suc n = f ‚àò (f ^ n)


-- Define predomains as posets

Predomain : Set‚ÇÅ
Predomain = Poset ‚Ñì-zero ‚Ñì-zero

-- The relation associated to a predomain d
rel : (d : Predomain) -> (‚ü® d ‚ü© -> ‚ü® d ‚ü© -> Type)
rel d = PosetStr._‚â§_ (d .snd)

reflexive : (d : Predomain) -> (x : ‚ü® d ‚ü©) -> (rel d x x)
reflexive d x = IsPoset.is-refl (PosetStr.isPoset (str d)) x


-- Monotone functions from X to Y

record MonFun (X Y : Predomain) : Set where
  module X = PosetStr (X .snd)
  module Y = PosetStr (Y .snd)
  _‚â§X_ = X._‚â§_
  _‚â§Y_ = Y._‚â§_
  field
    f : (X .fst) ‚Üí (Y .fst)
    isMon : ‚àÄ {x y} ‚Üí x ‚â§X y ‚Üí f x ‚â§Y f y

record IsMonFun {X Y : Predomain} (f : ‚ü® X ‚ü© ‚Üí ‚ü® Y ‚ü©) : Type (‚Ñì-max ‚Ñì ‚Ñì') where
  no-eta-equality
  constructor ismonfun

  module X = PosetStr (X .snd)
  module Y = PosetStr (Y .snd)
  _‚â§X_ = X._‚â§_
  _‚â§Y_ = Y._‚â§_

  field
    isMon : ‚àÄ {x y} ‚Üí x ‚â§X y ‚Üí f x ‚â§Y f y

record MonFunStr (‚Ñì' : Level) (X Y : Predomain) : Type (‚Ñì-max ‚Ñì (‚Ñì-suc ‚Ñì')) where

  constructor monfunstr

  field
    f : ‚ü® X ‚ü© -> ‚ü® Y ‚ü©
    isMonFun : IsMonFun {‚Ñì'} f

  open IsMonFun isMonFun public

MonF : ‚àÄ ‚Ñì ‚Ñì' -> Predomain -> Predomain -> Type (‚Ñì-max (‚Ñì-suc ‚Ñì) (‚Ñì-suc ‚Ñì'))
MonF ‚Ñì ‚Ñì' X Y = TypeWithStr ‚Ñì {!!}

{-
lem-later : {X~ : ‚ñπ Type} ->
  (x~ y~ : ‚ñ∏ X~) -> (x~ ‚â° y~) ‚â° ( ‚ñ∏ Œª t -> ( x~ t ‚â° y~ t ))
lem-later = ?
-}

isSet-poset : {‚Ñì ‚Ñì' : Level} -> (P : Poset ‚Ñì ‚Ñì') -> isSet ‚ü® P ‚ü©
isSet-poset P = IsPoset.is-set (PosetStr.isPoset (str P))

‚ñ∏' : ‚ñπ Predomain ‚Üí Predomain
‚ñ∏' X = (‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©)) ,
       posetstr ord
                (isposet isset-later {!!} ord-refl ord-trans ord-antisym)
   where

     ord : ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©) ‚Üí ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©) ‚Üí Type ‚Ñì-zero
     -- ord x1~ x2~ =  ‚ñ∏ (Œª t ‚Üí (str (X t) PosetStr.‚â§ (x1~ t)) (x2~ t))
     ord x1~ x2~ =  ‚ñ∏ (Œª t ‚Üí (PosetStr._‚â§_ (str (X t)) (x1~ t)) (x2~ t))
     

     isset-later : isSet (‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©))
     isset-later = Œª x y p1 p2 i j t ‚Üí
       isSet-poset (X t) (x t) (y t) (Œª i' ‚Üí p1 i' t) (Œª i' ‚Üí p2 i' t) i j

     ord-refl : (a : ‚ñ∏ (Œª t ‚Üí ‚ü® X t ‚ü©)) -> ord a a
     ord-refl a = Œª t ->
       IsPoset.is-refl (PosetStr.isPoset (str (X t))) (a t)

     ord-trans : BinaryRelation.isTrans ord
     ord-trans = Œª a b c ord-ab ord-bc t ‚Üí
       IsPoset.is-trans
         (PosetStr.isPoset (str (X t))) (a t) (b t) (c t) (ord-ab t) (ord-bc t)

     ord-antisym : BinaryRelation.isAntisym ord
     ord-antisym = Œª a b ord-ab ord-ba i t ->
       IsPoset.is-antisym
         (PosetStr.isPoset (str (X t))) (a t) (b t) (ord-ab t) (ord-ba t) i


‚ñ∏''_ : Predomain ‚Üí Predomain
‚ñ∏'' X = ‚ñ∏' (next X)

record ErrorDomain : Set‚ÇÅ where
  field
    X : Predomain
  module X = PosetStr (X .snd)
  _‚â§_ = X._‚â§_
  field
    ‚Ñß : X .fst
    ‚Ñß‚ä• : ‚àÄ x ‚Üí ‚Ñß ‚â§ x
    Œ∏ : MonFun (‚ñ∏'' X) X


-- Lift monad

data L‚Ñß (X : Set) : Set where
  Œ∑ : X ‚Üí L‚Ñß X
  ‚Ñß : L‚Ñß X
  Œ∏ : ‚ñπ (L‚Ñß X) ‚Üí L‚Ñß X


ret : {X : Set} -> X -> L‚Ñß X
ret = Œ∑

{-
bind' : ‚àÄ {A B} -> (A -> L‚Ñß B) -> ‚ñπ (L‚Ñß A -> L‚Ñß B) -> L‚Ñß A -> L‚Ñß B
bind' f bind_rec (Œ∑ x) = f x
bind' f bind_rec ‚Ñß = ‚Ñß
bind' f bind_rec (Œ∏ l_la) = Œ∏ (bind_rec ‚äõ l_la)

-- fix : ‚àÄ {l} {A : Set l} ‚Üí (f : ‚ñπ k , A ‚Üí A) ‚Üí A
bind : L‚Ñß A -> (A -> L‚Ñß B) -> L‚Ñß B
bind {A} {B} la f = (fix (bind' f)) la

ext : (A -> L‚Ñß B) -> L‚Ñß A -> L‚Ñß B
ext f la = bind la f
-}

ext' : (A -> L‚Ñß B) -> ‚ñπ (L‚Ñß A -> L‚Ñß B) -> L‚Ñß A -> L‚Ñß B
ext' f rec (Œ∑ x) = f x
ext' f rec ‚Ñß = ‚Ñß
ext' f rec (Œ∏ l-la) = Œ∏ (rec ‚äõ l-la)

ext : (A -> L‚Ñß B) -> L‚Ñß A -> L‚Ñß B
ext f = fix (ext' f)


bind : L‚Ñß A -> (A -> L‚Ñß B) -> L‚Ñß B
bind {A} {B} la f = ext f la

unfold-ext : (f : A -> L‚Ñß B) -> ext f ‚â° ext' f (next (ext f))
unfold-ext f = fix-eq (ext' f)

mapL : (A -> B) -> L‚Ñß A -> L‚Ñß B
mapL f la = bind la (Œª a -> ret (f a))


-- Strong bisimulation relation/ordering for the lift monad

U : Predomain -> Type
U p = ‚ü® p ‚ü©

{-
module LiftOrder (p : Predomain) where

  module X = PosetStr (p .snd)
  open X using (_‚â§_)
  -- _‚â§_ = X._‚â§_

  module Inductive (rec : ‚ñπ (L‚Ñß (U p) -> L‚Ñß (U p) -> Type)) where

    _‚âæ'_ : L‚Ñß (U p) -> L‚Ñß (U p) -> Type
    ‚Ñß ‚âæ' _ = Unit
    Œ∑ x ‚âæ' Œ∑ y = x ‚â§ y
    Œ∏ lx ‚âæ' Œ∏ ly = ‚ñ∏ (Œª t -> rec t (lx t) (ly t))
    Œ∑ _ ‚âæ' _ = ‚ä•
    Œ∏ _ ‚âæ' _ = ‚ä•

  open Inductive
  _‚âæ_ : L‚Ñß (U p) -> L‚Ñß (U p) -> Type
  _‚âæ_ = fix _‚âæ'_

  ‚âæ-refl : BinaryRelation.isRefl _‚âæ_

  ‚âæ-refl' : ‚ñπ (BinaryRelation.isRefl _‚âæ_) ->
            BinaryRelation.isRefl _‚âæ_
  ‚âæ-refl' IH (Œ∑ x) =
    transport (sym (Œª i -> fix-eq _‚âæ'_ i (Œ∑ x) (Œ∑ x)))
              (IsPoset.is-refl (X.isPoset) x)
  ‚âæ-refl' IH ‚Ñß =
    transport (sym (Œª i -> fix-eq _‚âæ'_ i ‚Ñß ‚Ñß))
              tt
  ‚âæ-refl' IH (Œ∏ lx~) =
    transport (sym (Œª i -> fix-eq _‚âæ'_ i (Œ∏ lx~) (Œ∏ lx~)))
              Œª t ‚Üí IH t (lx~ t)

  ‚âæ-refl = fix ‚âæ-refl'

  
  ‚Ñß-bot : (l : L‚Ñß (U p)) -> ‚Ñß ‚âæ l
  ‚Ñß-bot l = transport (sym Œª i ‚Üí fix-eq _‚âæ'_ i ‚Ñß l) tt



-- Predomain to lift predomain

ùïÉ‚Ñß' : Predomain -> Predomain
ùïÉ‚Ñß' X = L‚Ñß (X .fst) ,
      posetstr (LiftOrder._‚âæ_ X)
        (isposet {!!} {!!} ‚âæ-refl {!!} {!!})
  where open LiftOrder X


-- Predomain to lift Error Domain

ùïÉ‚Ñß : Predomain ‚Üí ErrorDomain
ùïÉ‚Ñß X = record {
  X = ùïÉ‚Ñß' X ; ‚Ñß = ‚Ñß ; ‚Ñß‚ä• = ‚Ñß-bot ;
  Œ∏ = record { f = Œ∏ ; isMon = Œª t -> {!!} } }
  where
    -- module X = PosetStr (X .snd)
    -- open Relation X
    open LiftOrder X

ùïå : ErrorDomain -> Predomain
ùïå d = ErrorDomain.X d
-}


-- Flat predomain from a set

flat : hSet ‚Ñì-zero -> Predomain
flat h = ‚ü® h ‚ü© ,
         (posetstr _‚â°_ (isposet (str h) (str h)
           (Œª _ ‚Üí refl)
           (Œª a b c a‚â°b b‚â°c ‚Üí a ‚â°‚ü® a‚â°b ‚ü© b ‚â°‚ü® b‚â°c ‚ü© c ‚àé)
           Œª a b a‚â°b _ ‚Üí a‚â°b))

ùîπ : Predomain
ùîπ = flat (Bool , isSetBool)

‚Ñï : Predomain
‚Ñï = flat (Nat , isSet‚Ñï)

UnitP : Predomain
UnitP = flat (Unit , isSetUnit)


-- Underlying predomain of an error domain

ùïå : ErrorDomain -> Predomain
ùïå d = ErrorDomain.X d



-- Predomains from arrows (need to ensure monotonicity)

-- Ordering on functions between predomains. This does not require that the
-- functions are monotone.
fun-order-het : (P1 P1' P2 P2' : Predomain) ->
  (‚ü® P1 ‚ü© -> ‚ü® P1' ‚ü© -> Type) ->
  (‚ü® P2 ‚ü© -> ‚ü® P2' ‚ü© -> Type) ->
  (‚ü® P1 ‚ü© -> ‚ü® P2 ‚ü©) -> (‚ü® P1' ‚ü© -> ‚ü® P2' ‚ü©) -> Type ‚Ñì-zero
fun-order-het P1 P1' P2 P2' rel-P1P1' rel-P2P2' fP1P2 fP1'P2' =
  (p : ‚ü® P1 ‚ü©) -> (p' : ‚ü® P1' ‚ü©) ->
  rel-P1P1' p p' ->
  rel-P2P2' (fP1P2 p) (fP1'P2' p')


-- TODO can define this in terms of fun-order-general
fun-order : (P1 P2 : Predomain) -> (‚ü® P1 ‚ü© -> ‚ü® P2 ‚ü©) -> (‚ü® P1 ‚ü© -> ‚ü® P2 ‚ü©) -> Type ‚Ñì-zero
fun-order P1 P2 f1 f2 =
  (x y : ‚ü® P1 ‚ü©) -> x ‚â§P1 y -> (f1 x) ‚â§P2 (f2 y)
  where
    module P1 = PosetStr (P1 .snd)
    module P2 = PosetStr (P2 .snd)
    _‚â§P1_ = P1._‚â§_
    _‚â§P2_ = P2._‚â§_

{-
mon-fun-order-refl : {P1 P2 : Predomain} ->
  (f : ‚ü® P1 ‚ü© -> ‚ü® P2 ‚ü©) ->
  ({x y : ‚ü® P1 ‚ü©} -> rel P1 x y -> rel P2 (f x) (f y)) ->
  fun-order P1 P2 f f
mon-fun-order-refl {P1} {P2} f f-mon = Œª x y x‚â§y ‚Üí f-mon x‚â§y
-}

fun-order-trans : {P1 P2 : Predomain} ->
  (f g h : ‚ü® P1 ‚ü© -> ‚ü® P2 ‚ü©) ->
  fun-order P1 P2 f g ->
  fun-order P1 P2 g h ->
  fun-order P1 P2 f h
fun-order-trans {P1} {P2} f g h f‚â§g g‚â§h =
  Œª x y x‚â§y ->
    P2.is-trans (f x) (g x) (h y)
    (f‚â§g x x (reflexive P1 x))
    (g‚â§h x y x‚â§y)
   where
     module P1 = PosetStr (P1 .snd)
     module P2 = PosetStr (P2 .snd)



mon-fun-order : (P1 P2 : Predomain) -> MonFun P1 P2 ‚Üí MonFun P1 P2 ‚Üí Type ‚Ñì-zero
mon-fun-order P1 P2 mon-f1 mon-f2 =
  fun-order P1 P2 (MonFun.f mon-f1) (MonFun.f mon-f2)
   where
     module P1 = PosetStr (P1 .snd)
     module P2 = PosetStr (P2 .snd)
     _‚â§P1_ = P1._‚â§_
     _‚â§P2_ = P2._‚â§_


mon-fun-order-refl : {P1 P2 : Predomain} ->
  (f : MonFun P1 P2) ->
  fun-order P1 P2 (MonFun.f f) (MonFun.f f)
mon-fun-order-refl f = Œª x y x‚â§y -> MonFun.isMon f x‚â§y

mon-fun-order-trans : {P1 P2 : Predomain} ->
  (f g h : MonFun P1 P2) ->
  mon-fun-order P1 P2 f g ->
  mon-fun-order P1 P2 g h ->
  mon-fun-order P1 P2 f h
mon-fun-order-trans f g h f‚â§g g‚â§h =
  fun-order-trans (MonFun.f f) (MonFun.f g) (MonFun.f h) f‚â§g g‚â§h


-- Predomain of monotone functions between two predomains
arr' : Predomain -> Predomain -> Predomain
arr' P1 P2 =
  MonFun P1 P2 ,
  -- (‚ü® P1 ‚ü© -> ‚ü® P2 ‚ü©) ,
  (posetstr
    (mon-fun-order P1 P2)
    (isposet {!!} {!!}
      mon-fun-order-refl
      
      -- TODO can use fun-order-trans
      (Œª f1 f2 f3 Hf1-f2 Hf2-f3 x y H‚â§xy ->
      -- Goal: f1 .f x ‚â§P2 f3 .f y
       P2.is-trans (f1 .f x) (f2 .f x) (f3 .f y)
         (Hf1-f2 x x (IsPoset.is-refl (P1.isPoset) x))
         (Hf2-f3 x y H‚â§xy))
      {!!}))
  where
    -- Two functions from P1 to P2 are related if, when given inputs
    -- that are related (in P1), the outputs are related (in P2)
    open MonFun
    module P1 = PosetStr (P1 .snd)
    module P2 = PosetStr (P2 .snd)
    _‚â§P1_ = P1._‚â§_
    _‚â§P2_ = P2._‚â§_

    {-
    mon-fun-order : MonFun P1 P2 ‚Üí MonFun P1 P2 ‚Üí Type ‚Ñì-zero
    mon-fun-order mon-f1 mon-f2 =
      fun-order P1 P2 (MonFun.f mon-f1) (MonFun.f mon-f2)
    -}

    {-
    fun-order : MonFun P1 P2 ‚Üí MonFun P1 P2 ‚Üí Type ‚Ñì-zero
    fun-order mon-f1 mon-f2 =
      (x y : ‚ü® P1 ‚ü©) -> x ‚â§P1 y -> (mon-f1 .f) x ‚â§P2 (mon-f2 .f) y
    -}

_==>_ : Predomain -> Predomain -> Predomain
A ==> B = arr' A B

infixr 20 _==>_


arr : Predomain -> ErrorDomain -> ErrorDomain
arr dom cod =
  record {
    X = arr' dom (ùïå cod) ;
    ‚Ñß = const-err ;
    ‚Ñß‚ä• = const-err-bot ;
    Œ∏ = {!!} }
    where
       -- open LiftOrder
       const-err : ‚ü® arr' dom (ùïå cod) ‚ü©
       const-err = record { f = Œª _ -> ErrorDomain.‚Ñß cod ; isMon = Œª _ -> reflexive (ùïå cod) (ErrorDomain.‚Ñß cod) }

       const-err-bot : (f : ‚ü® arr' dom (ùïå cod) ‚ü©) -> rel (arr' dom (ùïå cod)) const-err f
       const-err-bot f = Œª x y x‚â§y ‚Üí ErrorDomain.‚Ñß‚ä• cod (MonFun.f f y)
       




-- Lifting a heterogeneous relation between A and B to a
-- relation between L A and L B
-- (We may be able to reuse this logic to define the homogeneous ordering on ùïÉ below)

module LiftRelation
  (A B : Predomain)
  (ordAB : ‚ü® A ‚ü© -> ‚ü® B ‚ü© -> Type)
  where

  module A = PosetStr (A .snd)
  module B = PosetStr (B .snd)

  open A renaming (_‚â§_ to _‚â§A_)
  open B renaming (_‚â§_ to _‚â§B_)

  ord' : ‚ñπ ( L‚Ñß ‚ü® A ‚ü© ‚Üí L‚Ñß ‚ü® B ‚ü© ‚Üí Type) ->
             L‚Ñß ‚ü® A ‚ü© ‚Üí L‚Ñß ‚ü® B ‚ü© ‚Üí Type
  ord' rec (Œ∑ a) (Œ∑ b) = ordAB a b
  ord' rec ‚Ñß lb = Unit
  ord' rec (Œ∏ la~) (Œ∏ lb~) = ‚ñ∏ (Œª t ‚Üí rec t (la~ t) (lb~ t))
  ord' _ _ _ = ‚ä•

  ord : L‚Ñß ‚ü® A ‚ü© -> L‚Ñß ‚ü® B ‚ü© -> Type
  ord = fix ord'

  unfold-ord : ord ‚â° ord' (next ord)
  unfold-ord = fix-eq ord'

  ord-Œ∑-monotone : {a : ‚ü® A ‚ü©} -> {b : ‚ü® B ‚ü©} -> ordAB a b -> ord (Œ∑ a) (Œ∑ b)
  ord-Œ∑-monotone {a} {b} a‚â§b = transport (sym (Œª i ‚Üí unfold-ord i (Œ∑ a) (Œ∑ b))) a‚â§b

  ord-bot : (lb : L‚Ñß ‚ü® B ‚ü©) -> ord ‚Ñß lb
  ord-bot lb = transport (sym (Œª i ‚Üí unfold-ord i ‚Ñß lb)) tt


  -- ord-trans-IH


module LiftRelTransitive
  (A B C : Predomain)
  (ordAB : ‚ü® A ‚ü© -> ‚ü® B ‚ü© -> Type)
  (ordBC : ‚ü® B ‚ü© -> ‚ü® C ‚ü© -> Type)
  where

  module A = PosetStr (A .snd)
  module B = PosetStr (B .snd)
  module C = PosetStr (C .snd)

  open A renaming (_‚â§_ to _‚â§A_)
  open B renaming (_‚â§_ to _‚â§B_)
  open C renaming (_‚â§_ to _‚â§C_)

  open LiftRelation A B ordAB renaming (ord to ordLALB; unfold-ord to unfold-ordLALB)
  open LiftRelation B C ordBC renaming (ord to ordLBLC; unfold-ord to unfold-ordLBLC)

  ordAC : ‚ü® A ‚ü© -> ‚ü® C ‚ü© -> Type
  ordAC a c = Œ£ ‚ü® B ‚ü© Œª b ‚Üí ordAB a b √ó ordBC b c

  open LiftRelation A C ordAC renaming (ord to ordLALC; unfold-ord to unfold-ordLALC)


  {-
  ord-trans-ind :
        ‚ñπ ((a b c : L‚Ñß ‚ü® p ‚ü©) ->
           ord' (next ord) a b ->
           ord' (next ord) b c ->
           ord' (next ord) a c) ->
        (a b c : L‚Ñß ‚ü® p ‚ü©) ->
         ord' (next ord) a b ->
         ord' (next ord) b c ->
         ord' (next ord) a c
  -}


  ord-trans :
    (la : L‚Ñß ‚ü® A ‚ü©) (lb : L‚Ñß ‚ü® B ‚ü©) (lc : L‚Ñß ‚ü® C ‚ü©) ->
    ordLALB la lb -> ordLBLC lb lc -> ordLALC la lc
  ord-trans la lb lc la‚â§lb lb‚â§lc = {!!}
 

  {- ord-trans = fix (transport (sym (Œª i ->
         (‚ñπ ((a b c : L‚Ñß ‚ü® p ‚ü©) ‚Üí
            unfold-ord i a b ‚Üí unfold-ord i b c ‚Üí unfold-ord i a c) ‚Üí
             (a b c : L‚Ñß ‚ü® p ‚ü©) ‚Üí
            unfold-ord i a b ‚Üí unfold-ord i b c ‚Üí unfold-ord i a c))) ord-trans-ind)
  -}
  


-- Predomain to lift predomain
module ùïÉ (p : Predomain) where

  module X = PosetStr (p .snd)
  open X using (_‚â§_)
      -- _‚â§_ = X._‚â§_


  ord' : ‚ñπ ( L‚Ñß ‚ü® p ‚ü© ‚Üí L‚Ñß ‚ü® p ‚ü© ‚Üí Type) ->
                 L‚Ñß ‚ü® p ‚ü© ‚Üí L‚Ñß ‚ü® p ‚ü© ‚Üí Type
  ord' _ ‚Ñß _ = Unit
  ord' _ (Œ∑ x) (Œ∑ y) = x ‚â§ y
  ord' _ (Œ∑ _) _ = ‚ä•
  ord' rec (Œ∏ lx~) (Œ∏ ly~) = ‚ñ∏ (Œª t -> (rec t) (lx~ t) (ly~ t))
        -- or: ‚ñ∏ ((rec ‚äõ lx~) ‚äõ ly~)
  ord' _ (Œ∏ _) _ = ‚ä•

  ord :  L‚Ñß ‚ü® p ‚ü© ‚Üí L‚Ñß ‚ü® p ‚ü© ‚Üí Type
  ord = fix ord'

  unfold-ord : ord ‚â° ord' (next ord)
  unfold-ord = fix-eq ord'

  ord-Œ∑-monotone : {x y : ‚ü® p ‚ü©} -> x ‚â§ y -> ord (Œ∑ x) (Œ∑ y)
  ord-Œ∑-monotone {x} {y} x‚â§y = transport (sym Œª i ‚Üí unfold-ord i (Œ∑ x) (Œ∑ y)) x‚â§y

  ord-bot : (lx : L‚Ñß ‚ü® p ‚ü©) -> ord ‚Ñß lx
  ord-bot lx = transport (sym Œª i ‚Üí unfold-ord i ‚Ñß lx) tt

  -- lift-ord : (A -> A -> Type) -> (L‚Ñß A -> L‚Ñß A -> Type)

  ord-refl-ind : ‚ñπ ((a : L‚Ñß ‚ü® p ‚ü©) -> ord a a) ->
                    (a : L‚Ñß ‚ü® p ‚ü©) -> ord a a

  ord-refl-ind IH (Œ∑ x) =
    transport (sym (Œª i -> fix-eq ord' i (Œ∑ x) (Œ∑ x))) (IsPoset.is-refl X.isPoset x)
  ord-refl-ind IH ‚Ñß =
    transport (sym (Œª i -> fix-eq ord' i ‚Ñß ‚Ñß)) tt
  ord-refl-ind IH (Œ∏ x) =
    transport (sym (Œª i -> fix-eq ord' i (Œ∏ x) (Œ∏ x))) Œª t ‚Üí IH t (x t)

  ord-refl : (a : L‚Ñß ‚ü® p ‚ü©) -> ord a a
  ord-refl = fix ord-refl-ind

 

  ùïÉ : Predomain
  ùïÉ =
    (L‚Ñß ‚ü® p ‚ü©) ,
    (posetstr ord (isposet {!!} {!!} ord-refl ord-trans {!!}))
    where

      ord-trans-ind :
        ‚ñπ ((a b c : L‚Ñß ‚ü® p ‚ü©) ->
           ord' (next ord) a b ->
           ord' (next ord) b c ->
           ord' (next ord) a c) ->
        (a b c : L‚Ñß ‚ü® p ‚ü©) ->
         ord' (next ord) a b ->
         ord' (next ord) b c ->
         ord' (next ord) a c
      ord-trans-ind IH (Œ∑ x) (Œ∑ y) (Œ∑ z) ord-ab ord-bc =
        IsPoset.is-trans X.isPoset x y z ord-ab ord-bc
        -- x ‚â°‚ü® ord-ab ‚ü© y ‚â°‚ü® ord-bc ‚ü© z ‚àé
      ord-trans-ind IH (Œ∑ x) (Œ∑ y) ‚Ñß ord-ab ord-bc = ord-bc
      ord-trans-ind IH (Œ∑ x) (Œ∏ y) ‚Ñß contra ord-bc = contra
      ord-trans-ind IH (Œ∑ x) (Œ∑ y) (Œ∏ z) ord-ab contra = contra
      ord-trans-ind IH (Œ∑ x) ‚Ñß (Œ∏ y) ord-ab ord-bc = ord-ab
      ord-trans-ind IH (Œ∑ x) (Œ∏ y) (Œ∏ z) ord-ab ord-bc = ord-ab
      ord-trans-ind IH ‚Ñß b c ord-ab ord-bc = tt
      ord-trans-ind IH (Œ∏ lx~) (Œ∏ ly~) (Œ∏ lz~) ord-ab ord-bc =
        Œª t -> transport (sym Œª i ‚Üí unfold-ord i (lx~ t) (lz~ t))
          (IH t (lx~ t) (ly~ t) (lz~ t)
          (transport (Œª i -> unfold-ord i (lx~ t) (ly~ t)) (ord-ab t))
          (transport (Œª i -> unfold-ord i (ly~ t) (lz~ t)) (ord-bc t)))

      ord-trans : (a b c : L‚Ñß ‚ü® p ‚ü©) -> ord a b -> ord b c -> ord a c
      ord-trans = fix (transport (sym (Œª i ->
         (‚ñπ ((a b c : L‚Ñß ‚ü® p ‚ü©) ‚Üí
            unfold-ord i a b ‚Üí unfold-ord i b c ‚Üí unfold-ord i a c) ‚Üí
             (a b c : L‚Ñß ‚ü® p ‚ü©) ‚Üí
            unfold-ord i a b ‚Üí unfold-ord i b c ‚Üí unfold-ord i a c))) ord-trans-ind)


-- Predomain to lift Error Domain

ùïÉ‚Ñß : Predomain ‚Üí ErrorDomain
ùïÉ‚Ñß X = record {
  X = ùïÉ X ; ‚Ñß = ‚Ñß ; ‚Ñß‚ä• = ord-bot X ;
  Œ∏ = record { f = Œ∏ ; isMon = Œª t -> {!!} } }
  where
    -- module X = PosetStr (X .snd)
    -- open Relation X
    open ùïÉ



-- Product of predomains


-- We can't use Cubical.Data.Prod.Base for products, because this version of _√ó_
-- is not a subtype of the degenerate sigma type Œ£ A (Œª _ ‚Üí B), and this is needed
-- when we define the lookup function.
-- So we instead use Cubical.Data.Sigma.

-- These aren't included in Cubical.Data.Sigma, so we copy the
-- definitions from Cubical.Data.Prod.Base.
proj‚ÇÅ : {‚Ñì ‚Ñì' : Level} {A : Type ‚Ñì} {B : Type ‚Ñì'} ‚Üí A √ó B ‚Üí A
proj‚ÇÅ (x , _) = x

proj‚ÇÇ : {‚Ñì ‚Ñì' : Level} {A : Type ‚Ñì} {B : Type ‚Ñì'} ‚Üí A √ó B ‚Üí B
proj‚ÇÇ (_ , x) = x


infixl 21 _√ód_
_√ód_  : Predomain -> Predomain -> Predomain
A √ód B =
  (‚ü® A ‚ü© √ó ‚ü® B ‚ü©) ,
  (posetstr order {!!})
  where
    module A = PosetStr (A .snd)
    module B = PosetStr (B .snd)
   

    prod-eq : {a1 a2 : ‚ü® A ‚ü©} -> {b1 b2 : ‚ü® B ‚ü©} ->
      (a1 , b1) ‚â° (a2 , b2) -> (a1 ‚â° a2) √ó (b1 ‚â° b2)
    prod-eq p = (Œª i ‚Üí proj‚ÇÅ (p i)) , Œª i -> proj‚ÇÇ (p i)

    isSet-prod : isSet (‚ü® A ‚ü© √ó ‚ü® B ‚ü©)
    isSet-prod (a1 , b1) (a2 , b2) p1 p2 =
      let (p-a1‚â°a2 , p-b1‚â°b2) = prod-eq p1 in
      let (p'-a1‚â°a2 , p'-b1‚â°b2) = prod-eq p2 in
      {!!}

    order : ‚ü® A ‚ü© √ó ‚ü® B ‚ü© -> ‚ü® A ‚ü© √ó ‚ü® B ‚ü© -> Type ‚Ñì-zero
    order (a1 , b1) (a2 , b2) = (a1 A.‚â§ a2) √ó (b1 B.‚â§ b2)

    order-refl : BinaryRelation.isRefl order
    order-refl = Œª (a , b) ‚Üí reflexive A a , reflexive B b

    order-trans : BinaryRelation.isTrans order
    order-trans (a1 , b1) (a2 , b2) (a3 , b3) (a1‚â§a2 , b1‚â§b2) (a2‚â§a3 , b2‚â§b3) =
      (IsPoset.is-trans A.isPoset a1 a2 a3 a1‚â§a2 a2‚â§a3) ,
       IsPoset.is-trans B.isPoset b1 b2 b3 b1‚â§b2 b2‚â§b3
    

    {-
    order : ‚ü® A ‚ü© √ó ‚ü® B ‚ü© ‚Üí ‚ü® A ‚ü© √ó ‚ü® B ‚ü© ‚Üí Type ‚Ñì-zero
    order (a1 , b1) (a2 , b2) = (a1 A.‚â§ a2) ‚äé ((a1 ‚â° a2) √ó b1 B.‚â§ b2)

    order-trans : BinaryRelation.isTrans order
    order-trans (a1 , b1) (a2 , b2) (a3 , b3) (inl a1‚â§a2) (inl a2‚â§a3) =
      inl (IsPoset.is-trans A.isPoset a1 a2 a3 a1‚â§a2 a2‚â§a3)
    order-trans (a1 , b1) (a2 , b2) (a3 , b3) (inl a1‚â§a2) (inr (a2‚â°a3 , b2‚â§b3)) =
      inl (transport (Œª i ‚Üí a1 A.‚â§ a2‚â°a3 i) a1‚â§a2)
    order-trans (a1 , b1) (a2 , b2) (a3 , b3) (inr (a1‚â°a2 , b1‚â§b2)) (inl a2‚â§a3) =
      inl (transport (sym (Œª i ‚Üí a1‚â°a2 i A.‚â§ a3)) a2‚â§a3)
    order-trans (a1 , b1) (a2 , b2) (a3 , b3) (inr (a1‚â°a2 , b1‚â§b2)) (inr (a2‚â°a3 , b2‚â§b3)) =
      inr (
        (a1 ‚â°‚ü® a1‚â°a2 ‚ü© a2 ‚â°‚ü® a2‚â°a3 ‚ü© a3 ‚àé) ,
        IsPoset.is-trans B.isPoset b1 b2 b3 b1‚â§b2 b2‚â§b3)
    -}

    is-poset : IsPoset order
    is-poset = isposet
      isSet-prod
      {!!}
      order-refl
      order-trans
      {!!}



œÄ1 : {A B : Predomain} -> ‚ü® (A √ód B) ==> A ‚ü©
œÄ1 {A} {B} = record {
  f = g;
  isMon = g-mon }
  where
    g : ‚ü® A √ód B ‚ü© -> ‚ü® A ‚ü©
    g (a , b) = a

    g-mon  : {p1 p2 : ‚ü® A √ód B ‚ü©} ‚Üí rel (A √ód B) p1 p2 ‚Üí rel A (g p1) (g p2)
    g-mon {Œ≥1 , a1} {Œ≥2 , a2} (a1‚â§a2 , b1‚â§b2) = a1‚â§a2


œÄ2 : {A B : Predomain} -> ‚ü® (A √ód B) ==> B ‚ü©
œÄ2 {A} {B} = record {
  f = g;
  isMon = g-mon }
  where
    g : ‚ü® A √ód B ‚ü© -> ‚ü® B ‚ü©
    g (a , b) = b

    g-mon  : {p1 p2 : ‚ü® A √ód B ‚ü©} ‚Üí rel (A √ód B) p1 p2 ‚Üí rel B (g p1) (g p2)
    g-mon {Œ≥1 , a1} {Œ≥2 , a2} (a1‚â§a2 , b1‚â§b2) = b1‚â§b2



Pair : {A B : Predomain} -> ‚ü® A ==> B ==> (A √ód B) ‚ü©
Pair {A} = record {
  f = Œª a ‚Üí
    record {
      f = Œª b -> a , b ;
      isMon = Œª b1‚â§b2 ‚Üí (reflexive A a) , b1‚â§b2 } ;
  isMon = Œª {a1} {a2} a1‚â§a2 b1 b2 b1‚â§b2 ‚Üí a1‚â§a2 , b1‚â§b2 }


-- Weak bisimulation relaion
-- Define compositionally

Œ¥ : {X : Type} -> L‚Ñß X -> L‚Ñß X
Œ¥ = Œ∏ ‚àò next
  where open L‚Ñß

module WeakRel (d : Predomain) where

  module D = PosetStr (d .snd)
  _‚â§_ = D._‚â§_

  -- make this a module so we can avoid having to make the IH
  -- a parameter of the comparison function
  module Inductive (IH : ‚ñπ (L‚Ñß ‚ü® d ‚ü© -> L‚Ñß ‚ü® d ‚ü© -> Type)) where


    _‚âæ'_ : L‚Ñß (U d) -> L‚Ñß (U d) -> Type
    ‚Ñß ‚âæ' _ = Unit
      
    Œ∑ x ‚âæ' Œ∑ y = x ‚â§ y
    
    Œ∏ lx ‚âæ' Œ∏ ly = ‚ñ∏ (Œª t -> IH t (lx t) (ly t))
    -- or equivalently: Œ∏ lx ‚âæ' Œ∏ ly = ‚ñ∏ ((IH ‚äõ lx) ‚äõ ly)
      
    Œ∑ x ‚âæ' Œ∏ t = Œ£ Nat Œª n -> Œ£ (U d) (Œª y -> (Œ∏ t ‚â° (Œ¥ ^ n) (Œ∑ y)) √ó (x ‚â§ y))

    -- need to account for error (Œ∏ s ‚â° delay of Œ∑ x or delay of ‚Ñß, in which case we're done)
    Œ∏ s ‚âæ' Œ∑ y = Œ£ Nat Œª n ->
       (Œ∏ s ‚â° (Œ¥ ^ n) L‚Ñß.‚Ñß) ‚äé
       (Œ£ (U d) (Œª x -> (Œ∏ s ‚â° (Œ¥ ^ n) (Œ∑ x)) √ó (x ‚â§ y)))
      
    _ ‚âæ' ‚Ñß = ‚ä•
   
  _‚âæ_ : L‚Ñß (U d) -> L‚Ñß (U d) -> Type
  _‚âæ_ = fix _‚âæ'_
    where open Inductive






{-
-- Weak bisimulation relaion
-- Define compositionally

module WeakRel (d : ErrorDomain) where

  -- make this a module so we can avoid having to make the IH
  -- a parameter of the comparison function
  module Inductive (IH : ‚ñπ (L‚Ñß (U d) -> L‚Ñß (U d) -> Type)) where

    open ErrorDomain d renaming (Œ∏ to Œ∏')

    _‚âæ'_ : L‚Ñß (U d) -> L‚Ñß (U d) -> Type
    ‚Ñß ‚âæ' _ = Unit
      
    Œ∑ x ‚âæ' Œ∑ y = x ‚â§ y
    
    Œ∏ lx ‚âæ' Œ∏ ly = ‚ñ∏ (Œª t -> IH t (lx t) (ly t))
    -- or equivalently: Œ∏ lx ‚âæ' Œ∏ ly = ‚ñ∏ ((IH ‚äõ lx) ‚äõ ly)
      
    Œ∑ x ‚âæ' Œ∏ t = Œ£ ‚Ñï Œª n -> Œ£ (U d) (Œª y -> (Œ∏ t ‚â° (Œ¥ ^ n) (Œ∑ y)) √ó (x ‚â§ y))

    -- need to account for error (Œ∏ s ‚â° delay of Œ∑ x or delay of ‚Ñß, in which case we're done)
    Œ∏ s ‚âæ' Œ∑ y = Œ£ ‚Ñï Œª n ->
       (Œ∏ s ‚â° (Œ¥ ^ n) L‚Ñß.‚Ñß) ‚äé
       (Œ£ (U d) (Œª x -> (Œ∏ s ‚â° (Œ¥ ^ n) (Œ∑ x)) √ó (x ‚â§ y)))
      
    _ ‚âæ' ‚Ñß = ‚ä•
   
  _‚âæ_ : L‚Ñß (U d) -> L‚Ñß (U d) -> Type
  _‚âæ_ = fix _‚âæ'_
    where open Inductive

-}
