{-# OPTIONS --cubical --rewriting --guarded #-}

 -- to allow opening this module in other files while there are still holes
{-# OPTIONS --allow-unsolved-metas #-}

open import Later

module Semantics (k : Clock) where

open import Cubical.Foundations.Prelude
open import Cubical.Data.Nat renaming (‚Ñï to Nat) hiding (_^_)

open import Cubical.Relation.Binary
open import Cubical.Relation.Binary.Poset
open import Cubical.Foundations.Structure
open import Cubical.Foundations.Transport

open import Cubical.Data.Unit
-- open import Cubical.Data.Prod
open import Cubical.Data.Sigma
open import Cubical.Data.Empty

open import Cubical.Foundations.Function

open import StrongBisimulation k
open import GradualSTLC
open import SyntacticTermPrecision k
open import Lemmas k
open import MonFuns k

private
  variable
    l : Level
    A B : Set l
private
  ‚ñπ_ : Set l ‚Üí Set l
  ‚ñπ_ A = ‚ñπ_,_ k A


open ùïÉ

-- Denotations of Types


data Dyn' (D : ‚ñπ Predomain) : Type where
  nat : Nat -> Dyn' D
  fun : ‚ñ∏ (Œª t ‚Üí MonFun (D t) (ùïÉ (D t))) -> Dyn' D

DynP' : (D : ‚ñπ Predomain) -> Predomain
DynP' D = (Dyn' D) ,
  (posetstr order
    (isposet (Œª x y pf1 pf2 ‚Üí {!!}) {!!} order-refl order-trans {!!}))
  where
    order : Dyn' D ‚Üí Dyn' D ‚Üí Type ‚Ñì-zero
    order (nat n1) (nat n2) = n1 ‚â° n2
    order (fun f) (fun g) = ‚ñ∏ Œª t ->
      mon-fun-order (D t) (ùïÉ (D t)) (f t) (g t)
    order _ _ = ‚ä•

    {-
    order (fun f) (fun g) = ‚àÄ x y ->
      rel (‚ñ∏' D) x y ->
      ‚ñ∏ Œª t -> rel (ùïÉ (D t)) (MonFun.f (f t) (x t)) (MonFun.f (g t) (y t))
    -}

    order-refl : (d : Dyn' D) -> order d d
    order-refl (nat n) = refl
    order-refl (fun f) = Œª t ‚Üí mon-fun-order-refl (f t)

    order-trans : BinaryRelation.isTrans order
    order-trans (nat n1) (nat n2) (nat n3) n1‚â°n2 n2‚â°n3 =
      n1 ‚â°‚ü® n1‚â°n2 ‚ü© n2 ‚â°‚ü® n2‚â°n3 ‚ü© n3 ‚àé
    order-trans (fun f1) (fun f2) (fun f3) later-f1‚â§f2 later-f2‚â§f3 =
      Œª t ‚Üí
        mon-fun-order-trans (f1 t) (f2 t) (f3 t) (later-f1‚â§f2 t) (later-f2‚â§f3 t)



----------------------------------------------------------


DynP : Predomain
DynP = fix DynP'

unfold-DynP : DynP ‚â° DynP' (next DynP)
unfold-DynP = fix-eq DynP'



unfold-‚ü®DynP‚ü© : ‚ü® DynP ‚ü© ‚â° ‚ü® DynP' (next DynP) ‚ü©
unfold-‚ü®DynP‚ü© = Œª i ‚Üí ‚ü® unfold-DynP i ‚ü©

-- Converting from the underlying set of DynP' to the underlying
-- set of DynP
DynP'-to-DynP : ‚ü® DynP' (next DynP) ‚ü© -> ‚ü® DynP ‚ü©
DynP'-to-DynP d = transport (sym (Œª i -> ‚ü® unfold-DynP i ‚ü©)) d

DynP-to-DynP' : ‚ü® DynP ‚ü© -> ‚ü® DynP' (next DynP) ‚ü©
DynP-to-DynP' d = transport (Œª i ‚Üí ‚ü® unfold-DynP i ‚ü©) d

DynP-DynP'-iso : (d : ‚ü® DynP' (next DynP) ‚ü©) ->
  DynP-to-DynP' (DynP'-to-DynP d) ‚â° d
DynP-DynP'-iso d = {!!}

DynP-DynP'-iso-inv : (d : ‚ü® DynP ‚ü©) ->
  DynP'-to-DynP (DynP-to-DynP' d) ‚â° d
DynP-DynP'-iso-inv d = {!!}


-- This basically is a monotonicity result, and could be
-- incorporated as a constant into the combinator language.
DynP-rel : ‚àÄ d1 d2 ->
  rel (DynP' (next DynP)) d1 d2 ->
  rel DynP (DynP'-to-DynP d1) (DynP'-to-DynP d2)
DynP-rel d1 d2 d1‚â§d2 = transport
  (Œª i ‚Üí rel (unfold-DynP (~ i))
    (transport-filler (Œª j -> ‚ü® unfold-DynP (~ j) ‚ü©) d1 i)
    (transport-filler (Œª j -> ‚ü® unfold-DynP (~ j) ‚ü©) d2 i))
  d1‚â§d2


{-
rel-lemma : ‚àÄ d1 d2 ->
  rel (DynP' (next DynP)) d1 d2 ->
  rel DynP (transport (sym unfold-‚ü®DynP‚ü©) d1) (transport (sym unfold-‚ü®DynP‚ü©) d2)
rel-lemma d1 d2 d1‚â§d2 = {!!}
transport
  (Œª i -> rel (unfold-DynP (~ i))
    (transport-filler (Œª j -> sym unfold-‚ü®DynP‚ü© j ) d1 i)
    {!!}
    --(transport-filler (sym unfold-‚ü®DynP‚ü©) d1 i)
    --(transport-filler (sym unfold-‚ü®DynP‚ü©) d2 i)
  )
  d1‚â§d2
-}



-------------------------------------
-- *** Embedding-projection pairs ***


record EP (A B : Predomain) : Set where
  field
    emb : MonFun A B
    proj : MonFun B (ùïÉ A)
    wait-l-e : ‚ü® A ==> A ‚ü©
    wait-l-p : ‚ü® ùïÉ A ==> ùïÉ A ‚ü©
    wait-r-e : ‚ü® B ==> B ‚ü©
    wait-r-p : ‚ü® ùïÉ B ==> ùïÉ B ‚ü©


-- Identity E-P pair

EP-id : (A : Predomain) -> EP A A
EP-id A = record {
  emb = record { f = id ; isMon = Œª x‚â§y ‚Üí x‚â§y };
  proj = record { f = ret ; isMon = ord-Œ∑-monotone A };
  wait-l-e = Id;
  wait-l-p = Id;
  wait-r-e = Id;
  wait-r-p = Id}



-- E-P Pair for nats

‚â§‚Ñï-eq : {x y : ‚ü® ‚Ñï ‚ü©} -> (rel ‚Ñï) x y -> x ‚â° y
‚â§‚Ñï-eq {x} {y} x‚â§y = x‚â§y

e-nat : ‚ü® ‚Ñï ==> DynP ‚ü©
e-nat = record {
  f = Œª n -> DynP'-to-DynP (nat n) ;  -- transport (sym unfold-‚ü®DynP‚ü©) (nat n) ;
  isMon = Œª {x} {y} x‚â§y ‚Üí DynP-rel (nat x) (nat y) (‚â§‚Ñï-eq x‚â§y) }

p-nat' : ‚ü® DynP' (next DynP) ==> ùïÉ ‚Ñï ‚ü©
p-nat' = record { f = g ; isMon = g-mon }
  where
    g : ‚ü® DynP' (next DynP) ‚ü© ‚Üí ‚ü® ùïÉ ‚Ñï ‚ü© 
    g (nat n) = ret n
    g (fun f) = ‚Ñß

    g-mon : {x y : ‚ü® DynP' (next DynP) ‚ü©} ‚Üí
      (rel (DynP' (next DynP)) x y) ‚Üí
      (rel (ùïÉ ‚Ñï) (g x) (g y))
    g-mon {nat n} {nat m} x‚â§y = ord-Œ∑-monotone ‚Ñï x‚â§y
    g-mon {fun f} {fun g} x‚â§y = ord-bot ‚Ñï ‚Ñß

p-nat : MonFun DynP (ùïÉ ‚Ñï)
p-nat = {!!} -- S DynP (K DynP p-nat') (mTransport unfold-DynP)
  -- or:
  -- mTransportDomain (sym unfold-DynP) p-nat'


EP-nat : EP ‚Ñï DynP
EP-nat = record {
  emb = e-nat;
  proj = p-nat;
  wait-l-e = Id;
  wait-l-p = Id;
  wait-r-e = Id;
  wait-r-p = Id}


-- E-P Pair for monotone functions Dyn to L‚Ñß Dyn

e-fun : MonFun (DynP ==> (ùïÉ DynP)) DynP
e-fun = record { f = e-fun-f ; isMon = e-fun-mon }
  where
    e-fun-f : ‚ü® DynP ==> (ùïÉ DynP) ‚ü© -> ‚ü® DynP ‚ü©
    e-fun-f f = DynP'-to-DynP (fun (next f))

    e-fun-mon :
      {f1 f2 : ‚ü® DynP ==> (ùïÉ DynP) ‚ü©} ->
      rel (DynP ==> (ùïÉ DynP)) f1 f2 ->
      rel DynP (e-fun-f f1) (e-fun-f f2)
    e-fun-mon {f1} {f2} f1‚â§f2 =
      DynP-rel (fun (next f1)) (fun (next f2)) (Œª t d1 d2 d1‚â§d2 ‚Üí {!!})


p-fun : MonFun DynP (ùïÉ (DynP ==> (ùïÉ DynP)))
p-fun = record { f = p-fun-f ; isMon = {!!} }
  where

    p-fun-f' : ‚ü® DynP' (next DynP) ‚ü© -> ‚ü® ùïÉ (DynP ==> (ùïÉ DynP)) ‚ü©
    p-fun-f' (nat n) = ‚Ñß
    p-fun-f' (fun f) = Œ∏ (Œª t ‚Üí Œ∑ (f t))
    -- f : ‚ñ∏ (Œª t ‚Üí MonFun (next DynP t) (ùïÉ (next DynP t)))

    p-fun-f : ‚ü® DynP ‚ü© -> ‚ü® ùïÉ (DynP ==> (ùïÉ DynP)) ‚ü©
    -- p-fun-f d = p-fun-f' (transport unfold-‚ü®DynP‚ü© d)
    p-fun-f d = p-fun-f' (transport (Œª i -> ‚ü® unfold-DynP i ‚ü©) d)


EP-fun : EP (arr' DynP (ùïÉ DynP)) DynP
EP-fun = record {
  emb = e-fun;
  proj = p-fun;
  wait-l-e = Id;
  wait-l-p = Œî;
  wait-r-e = Id;
  wait-r-p = Œî}




-- Composing EP pairs

module EPComp
  {A B C : Predomain}
  (epAB : EP A B)
  (epBC : EP B C) where

  open EP
  open MonFun

  comp-emb : ‚ü® A ==> C ‚ü©
  comp-emb = mCompU (emb epBC) (emb epAB)
  -- A ! K A (emb epBC) <*> (emb epAB) -- mComp (emb epBC) (emb epAB)

  comp-proj : ‚ü® C ==> ùïÉ A ‚ü©
  comp-proj = Bind C (proj epBC) (mCompU (proj epAB) œÄ2)
  --C ! (mExt' C (K C (proj epAB))) <*> (proj epBC)
  -- mComp (mExt (proj epAB)) (proj epBC)
  --  comp-proj-f =
  --    Œª c -> bind (f (proj epBC) c) (f (proj epAB)) ==
  --    Œª c -> ext  (f (proj epAB)) (f (proj epBC) c) ==
  --    (ext (f (proj epAB))) ‚àò (f (proj epBC c)) 

  EP-comp : EP A C
  EP-comp = record {
    emb = comp-emb;
    proj = comp-proj;
    wait-l-e = wait-l-e epAB;
    wait-l-p = wait-l-p epAB;
    wait-r-e = wait-r-e epBC;
    wait-r-p = wait-r-p epBC}


-- Lifting EP pairs to ùïÉ
EP-lift : {A B : Predomain} -> EP A B -> EP (ùïÉ A) (ùïÉ B)
EP-lift epAB =
  record {
    emb = U mMap (EP.emb epAB);
    proj = U mMap (EP.proj epAB);
    wait-l-e = U mMap (EP.wait-l-e epAB);
    wait-l-p = U mMap (EP.wait-l-p epAB);
    wait-r-e = U mMap (EP.wait-r-e epAB);
    wait-r-p = U mMap (EP.wait-r-p epAB) }


-- Lifting EP pairs to functions

module EPArrow
  {A A' B B' : Predomain}
  (epAA' : EP A A')
  (epBB' : EP B B') where

    e-arrow : ‚ü® (A ==> ùïÉ B) ==> (A' ==> ùïÉ B') ‚ü©
    e-arrow = mFunEmb A A' B B' (EP.proj epAA') (EP.emb epBB')

    p-arrow : ‚ü® (A' ==> (ùïÉ B')) ==> (ùïÉ (A ==> (ùïÉ B))) ‚ü©
    p-arrow = mFunProj A A' B B' (EP.emb epAA') (EP.proj epBB')

{-
    p-lift :
      (A' -> L‚Ñß B') -> L‚Ñß (A -> L‚Ñß B)
    p-lift f =
      ret (Œª a ‚Üí bind (f (EP.emb epAA' a)) (EP.proj epBB'))
-}


EP-arrow : {A A' B B' : Predomain} ->
  EP A A' ->
  EP B B' ->
  EP (A ==> (ùïÉ B)) (A' ==> (ùïÉ B'))
EP-arrow epAA' epBB' = record {
  emb = e-arrow;
  proj = p-arrow;
  
  wait-l-e = Curry (
    (mMap' (With2nd (EP.wait-l-e epBB'))) ‚àòm
    (Uncurry mExt) ‚àòm
    (With2nd (EP.wait-l-p epAA')) ‚àòm
    (mRet' _ œÄ2)
  ) ;
  
  wait-l-p = U mMap (Curry (
    With2nd (EP.wait-l-p epBB') ‚àòm
    App ‚àòm
    With2nd (EP.wait-l-e epAA')
  )) ;
  
  wait-r-e = Curry (
    mMap' (With2nd (EP.wait-r-e epBB')) ‚àòm
    ((Uncurry mExt) ‚àòm
    (With2nd (EP.wait-r-p epAA') ‚àòm
    (mRet' _ œÄ2)))) ;
  -- or : wait-r-e = Curry (mMap' (With2nd (EP.wait-r-e epBB')) ‚àòm ((Uncurry mExt) ‚àòm (With2nd (EP.wait-r-p epAA') ‚àòm (With2nd mRet)))) ;

  
  wait-r-p = U mMap (Curry (
    With2nd (EP.wait-r-p epBB') ‚àòm
    App ‚àòm
    With2nd (EP.wait-r-e epAA')
  ))

  }
  
  where open EPArrow epAA' epBB'



-------------------------------------------
-- *** Denotation of types and contexts ***

open EPComp

-- Types are predomains
‚ü¶_‚üßty : Ty -> Predomain
‚ü¶ nat ‚üßty = ‚Ñï
‚ü¶ dyn ‚üßty = DynP
‚ü¶ A => B ‚üßty =  ‚ü¶ A ‚üßty ==> (ùïÉ ‚ü¶ B ‚üßty)
-- ‚ü¶ A ‚üßty -> L‚Ñß ‚ü¶ B ‚üßty

-- Contexts are predomains
‚ü¶_‚üßctx : Ctx -> Predomain
‚ü¶ ¬∑ ‚üßctx = UnitP
‚ü¶ Œì :: A ‚üßctx = ‚ü¶ Œì ‚üßctx √ód ‚ü¶ A ‚üßty -- ‚ü¶ Œì ‚üßctx √ó ‚ü¶ A ‚üßty

-- Agda can infer that the context is not empty, so
-- ‚ü¶ Œì ‚üßctx must be a product
-- Make A implicit
look : {Œì : Ctx} ->
  (env : ‚ü® ‚ü¶ Œì ‚üßctx ‚ü©) ->
  (A : Ty) ->
  (x : Œì ‚àã A) ->
  ‚ü® ‚ü¶ A ‚üßty ‚ü©
look env A vz = proj‚ÇÇ env
look env A (vs {Œì} {S} {T} x) = look (proj‚ÇÅ env) A x

look-mon : {Œì : Ctx} ->
  (env1 env2 : ‚ü® ‚ü¶ Œì ‚üßctx ‚ü©) ->
  (A : Ty) ->
  (z : Œì ‚àã A) ->
  rel ‚ü¶ Œì ‚üßctx env1 env2 ->
  rel ‚ü¶ A ‚üßty (look env1 A z) (look env2 A z)
look-mon env1 env2 A z env1‚â§env2 = {!!}

mLook : {Œì : Ctx} ->
  (A : Ty) ->
  (x : Œì ‚àã A) ->
  ‚ü® ‚ü¶ Œì ‚üßctx ==> ‚ü¶ A ‚üßty ‚ü©
mLook A vz = œÄ2
mLook A (vs z) = mCompU (mLook A z) œÄ1

mLook-vz : {Œì : Ctx} -> (A : Ty) -> (env : ‚ü® ‚ü¶ Œì :: A ‚üßctx ‚ü©) ->
  MonFun.f (mLook A (vz {Œì})) env ‚â° proj‚ÇÇ env
mLook-vz = {!!}


---------------------------------------
-- *** Denotation of type precision ***

‚ü¶_‚üßlt : {A B : Ty} -> A ‚äë B -> EP ‚ü¶ A ‚üßty ‚ü¶ B ‚üßty
-- ‚ü¶_‚üßlt = {!!}
‚ü¶ dyn ‚üßlt = EP-id DynP
‚ü¶ A‚äëA' => B‚äëB' ‚üßlt = EP-arrow ‚ü¶ A‚äëA' ‚üßlt ‚ü¶ B‚äëB' ‚üßlt
‚ü¶ nat ‚üßlt = EP-id ‚Ñï
‚ü¶ inj-nat ‚üßlt = EP-nat
‚ü¶ inj-arrow (A-dyn => B-dyn) ‚üßlt =
  EP-comp (EP-arrow  ‚ü¶ A-dyn ‚üßlt  ‚ü¶ B-dyn ‚üßlt) EP-fun



------------------------------
-- *** Denotation of terms ***

tm-sem : {A : Ty} {Œì : Ctx} -> Tm Œì A -> ‚ü® ‚ü¶ Œì ‚üßctx ==> (ùïÉ ‚ü¶ A ‚üßty) ‚ü©
tm-sem {_} {Œì} (var z) = mRet' ‚ü¶ Œì ‚üßctx (mLook _ z)
tm-sem {_} {Œì} (lda M) = mRet' ‚ü¶ Œì ‚üßctx (Curry (tm-sem M))
--(_ $ K ‚ü¶ Œì ‚üßctx (tm-sem M) ‚àòm Pair)

-- mRet' ? (K (tm-sem M) ‚àòm Pair))

{-
record {
  f = Œª ‚ü¶Œì‚üß -> ret
    (record {
      f = Œª N -> MonFun.f (tm-sem M) (‚ü¶Œì‚üß , N);
      isMon = {!!} }) ;
  isMon = {!!} }
-}
  
tm-sem {A} {Œì} (app {S = B} M1 M2) = {!!}
{-
    let kont = (‚ü¶ Œì ‚üßctx ! K ‚ü¶ Œì ‚üßctx (swap _ {- (‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty) -} mExt) <*> tm-sem M2) in
    (‚ü¶ Œì ‚üßctx ! mExt' ‚ü¶ Œì ‚üßctx kont <*> tm-sem M1)
-}

-- mExt :      ‚ü® (‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty) ==> ùïÉ ‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty ‚ü©
-- swap mExt : ‚ü® ùïÉ ‚ü¶ B ‚üßty ==> ( ‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty ) ==> ùïÉ ‚ü¶ A ‚üßty ‚ü©
-- K (swap mExt) : ‚ü® ‚ü¶ Œì ‚üßctx ==> ùïÉ ‚ü¶ B ‚üßty ==> ( ‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty ) ==> ùïÉ ‚ü¶ A ‚üßty ‚ü©
-- tm-sem M2 : ‚ü® ‚ü¶ Œì ‚üßctx ==> ùïÉ ‚ü¶ B ‚üßty ‚ü©
-- kont :      ‚ü®  ‚ü¶ Œì ‚üßctx ==> ( ‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty ) ==> ùïÉ ‚ü¶ A ‚üßty ‚ü©

-- mExt' kont : ‚ü® ‚ü¶ Œì ‚üßctx ==> ùïÉ ( ‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty ) ==> ùïÉ ‚ü¶ A ‚üßty ‚ü©
-- tm-sem M1 : ‚ü® ‚ü¶ Œì ‚üßctx ==> ùïÉ ( ‚ü¶ B ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty ) ‚ü©
-- result : ‚ü® ‚ü¶ Œì ‚üßctx ==> ùïÉ ‚ü¶ A ‚üßty ‚ü©

{-
 
Idea:
  
  ext f : ùïÉ ‚ü¶ S1 ‚üßty ==> ùïÉ ‚ü¶ A ‚üßty
 (ext f) (tm-sem M2 ‚ü¶Œì‚üß) : ùïÉ ‚ü¶ A ‚üßty

-}


{-
record {
  f = Œª ‚ü¶Œì‚üß ->
    bind ((MonFun.f (tm-sem M1)) ‚ü¶Œì‚üß)
         (Œª f -> bind (MonFun.f (tm-sem M2) ‚ü¶Œì‚üß) (MonFun.f f)) ;
    isMon = {!!} }
-}
    
tm-sem {A} {Œì} err = K ‚ü¶ Œì ‚üßctx ‚Ñß
-- record { f = Œª _ -> ‚Ñß ; isMon = Œª _ -> ord-bot ‚ü¶ A ‚üßty ‚Ñß }

tm-sem {_} {Œì} (up A‚äëB M) = Map (mCompU (EP.emb ‚ü¶ A‚äëB ‚üßlt) œÄ2) (tm-sem M)
  -- ‚ü¶ Œì ‚üßctx ! (mMap' (K ‚ü¶ Œì ‚üßctx (EP.emb ‚ü¶ A‚äëB ‚üßlt))) <*> (tm-sem M)
  -- Map (K ‚ü¶ Œì ‚üßctx (EP.emb ‚ü¶ A‚äëB ‚üßlt)) (tm-sem M)

{-
record {
  f =  Œª ‚ü¶Œì‚üß -> mapL (MonFun.f (EP.emb ‚ü¶ A‚äëB ‚üßlt)) ((MonFun.f (tm-sem  M)) ‚ü¶Œì‚üß) ;
  isMon = {!!} }
-}
  
tm-sem {_} {Œì} (dn A‚äëB M) =
  -- ‚ü¶ Œì ‚üßctx ! (mExt' ‚ü¶ Œì ‚üßctx (K ‚ü¶ Œì ‚üßctx (EP.proj ‚ü¶ A‚äëB ‚üßlt))) <*> (tm-sem M)
  Bind ‚ü¶ Œì ‚üßctx (tm-sem M) (mCompU (EP.proj ‚ü¶ A‚äëB ‚üßlt) œÄ2)

{-
record { f =
  Œª ‚ü¶Œì‚üß -> bind ((MonFun.f (tm-sem M)) ‚ü¶Œì‚üß) (MonFun.f (EP.proj ‚ü¶ A‚äëB ‚üßlt)) ;
  isMon = {!!} }
-}
  
tm-sem {_} {Œì} zro = K ‚ü¶ Œì ‚üßctx (Œ∑ zero)
-- record { f = Œª _ -> Œ∑ zero ; isMon = Œª _ ‚Üí ord-refl ‚Ñï (Œ∑ zero) }

tm-sem {_} {Œì} (suc M) = {!!}
-- ‚ü¶ Œì ‚üßctx ! (mExt' ‚ü¶ Œì ‚üßctx (K ‚ü¶ Œì ‚üßctx (mRet' ‚Ñï mSuc))) <*> (tm-sem M)
{-
record {
  f =  Œª ‚ü¶Œì‚üß -> bind (MonFun.f (tm-sem M) ‚ü¶Œì‚üß) (Œª n -> Œ∑ (suc n)) ;
  isMon = Œª _ ‚Üí {!!} }
-}

-- ‚ü¶_‚üßtm : {A : Ty} -> {Œì : Ctx} -> Tm Œì A -> (‚ü® ‚ü¶ Œì ‚üßctx ‚ü© -> L‚Ñß ‚ü® ‚ü¶ A ‚üßty ‚ü©)
‚ü¶_‚üßtm : {A : Ty} -> {Œì : Ctx} -> Tm Œì A -> MonFun ( ‚ü¶ Œì ‚üßctx)  (ùïÉ ‚ü¶ A ‚üßty )
‚ü¶ M ‚üßtm = tm-sem M





---------------------------------------
-- *** Denotation of term precision ***
--  ‚ü¶ M ‚üß ‚â≤ ‚ü¶ N ‚üß

open Bisimilarity

{-
-- Homogeneous term precision relation
lttm-hom : {A : Ty} ->
  (Œì : Ctx) ->
  (M : Tm (lhs (Ctx-ref Œì)) A) ->
  (N : Tm (rhs (Ctx-ref Œì)) A) ->
  (Ctx-ref Œì) |- M ‚äëtm N # (‚äëref A) ->
  (‚ü¶ A ‚üßty ‚âæ ((MonFun.f ‚ü¶ M ‚üßtm) {!!} )) ((MonFun.f ‚ü¶ N ‚üßtm) {!!})
lttm-hom Œì M N M‚äëN = {!!}
-}

{-
mapL-emb : {A A' : Type} -> (epAA' : EP A A') (a : L‚Ñß A) ->
  mapL (EP.emb epAA') a ‚â° EP.emb (EP-L epAA') a
mapL-emb epAA' a = refl
-}


------------------------------------------------------------------
-- *** Relational interpretation of type precision derivations ***
-- c : A ‚äë B
-- ‚ü¶c‚üß : relation between ‚ü¶ A ‚üßty and ‚ü¶ B ‚üßty

typrecd-sem : {A B : Ty} ->
  (c : A ‚äë B) -> (‚ü® ‚ü¶ A ‚üßty ‚ü© -> ‚ü® ‚ü¶ B ‚üßty ‚ü© -> Type)
typrecd-sem dyn = rel DynP
typrecd-sem {Ain => Aout} {Bin => Bout} (cin => cout) =
  Œª f1 f2 -> fun-order-het  ‚ü¶ Ain ‚üßty ‚ü¶ Bin ‚üßty (ùïÉ ‚ü¶ Aout ‚üßty) (ùïÉ ‚ü¶ Bout ‚üßty)
    (typrecd-sem cin)
    (LiftRelation.ord ‚ü¶ Aout ‚üßty ‚ü¶ Bout ‚üßty (typrecd-sem cout))
    (MonFun.f f1) (MonFun.f f2)
    -- (MonFun.f (MonFun.f (EP.wait-l-e ‚ü¶ cin => cout ‚üßlt) f1))
    -- (MonFun.f (MonFun.f (EP.wait-r-e ‚ü¶ cin => cout ‚üßlt) f2))
typrecd-sem nat = rel ‚Ñï
typrecd-sem inj-nat = Œª n d -> rel' n (DynP-to-DynP' d)
  where
    rel' : ‚ü® ‚Ñï ‚ü© -> ‚ü® DynP' (next DynP) ‚ü© -> Type
    rel' n (nat n') = n ‚â° n'
    rel' n (fun _) = ‚ä•
typrecd-sem {Ain => Aout} (inj-arrow (cin => cout)) =
  Œª f d -> rel' f (DynP-to-DynP' d)
  where
    rel' : ‚ü® ‚ü¶ Ain ‚üßty ==> ùïÉ ‚ü¶ Aout ‚üßty ‚ü© -> ‚ü® DynP' (next DynP) ‚ü© -> Type
    rel' f (nat n) = ‚ä•
    rel' f (fun f') = ‚ñ∏ Œª t ->
      fun-order-het ‚ü¶ Ain ‚üßty DynP (ùïÉ ‚ü¶ Aout ‚üßty) (ùïÉ DynP)
      (typrecd-sem cin)
      (LiftRelation.ord ‚ü¶ Aout ‚üßty DynP (typrecd-sem cout))
      (MonFun.f f) (MonFun.f (f' t))

------------------------------------------
-- *** Heterogeneous term precision *** --

tmprec : {Œì : Ctx} -> {A B : Ty} ->
  (c : A ‚äë B) -> Tm Œì A -> Tm Œì B -> Type
tmprec {Œì} {A} {B} c M N =
  fun-order-het ‚ü¶ Œì ‚üßctx ‚ü¶ Œì ‚üßctx (ùïÉ ‚ü¶ A ‚üßty) (ùïÉ ‚ü¶ B ‚üßty)
  (rel ‚ü¶ Œì ‚üßctx)
    (LiftRelation.ord ‚ü¶ A ‚üßty ‚ü¶ B ‚üßty (typrecd-sem c))
    (MonFun.f ‚ü¶ M ‚üßtm) (MonFun.f ‚ü¶ N ‚üßtm)



-----------------------------------------


x‚â§emb : {Œì : Ctx} -> (A B : Ty) -> (x : (¬∑ :: A) ‚àã A) -> (c : A ‚äë B) ->
  tmprec c (var x) (up c (var x))
x‚â§emb .dyn .dyn x dyn (_ , d1) (_ , d2) (_ , d1‚â§d2) =
           transport
             (sym (Œª i ‚Üí LiftRelation.unfold-ord DynP DynP (rel DynP) i
                           (MonFun.f ‚ü¶ var x ‚üßtm (tt , d1))
                           (MonFun.f ‚ü¶ up dyn (var x) ‚üßtm (tt , d2))))
             {!!}
x‚â§emb .(_ => _) .(_ => _) x (c => c‚ÇÅ) = {!!}
x‚â§emb .nat .nat x nat (_ , n1) (_ , n2) (_ , n1‚â°n2) =
           transport
             (sym (Œª i ‚Üí LiftRelation.unfold-ord ‚Ñï ‚Ñï (rel ‚Ñï) i
                           (MonFun.f ‚ü¶ var x ‚üßtm (tt , n1))
                           (MonFun.f ‚ü¶ up nat (var x) ‚üßtm (tt , n2))))
             {!!}
x‚â§emb .nat .dyn x inj-nat = {!!}
x‚â§emb A .dyn x (inj-arrow c) = {!!}





open EPComp


-- Properties of the wait functions
module WaitProp
  where

  open EP

  wait-l-Œ∏ : {A B : Ty} -> (c : A ‚äë B) -> (la~ : ‚ñπ L‚Ñß ‚ü® ‚ü¶ A ‚üßty ‚ü©) ->
    Œ£ (‚ñπ L‚Ñß ‚ü® ‚ü¶ A ‚üßty ‚ü©) Œª la'~ ->
      MonFun.f (wait-l-p ‚ü¶ c ‚üßlt) (Œ∏ la~) ‚â°
      Œ∏ (Œª t -> MonFun.f (wait-l-p ‚ü¶ c ‚üßlt) (la'~ t))
  wait-l-Œ∏ dyn la~ = la~ , refl
  wait-l-Œ∏ {Ai => Ao} {Bi => Bo} (cin => cout) la~ = {!!}
  wait-l-Œ∏ nat la~ = la~ , refl
  wait-l-Œ∏ inj-nat la~ = la~ , refl
  wait-l-Œ∏ {Ai => Ao} (inj-arrow (cin => cout)) la~ = {!!} , {!!}


  wait-r-Œ∏ : {A B : Ty} -> (c : A ‚äë B) -> (lb~ : ‚ñπ L‚Ñß ‚ü® ‚ü¶ B ‚üßty ‚ü©) ->
    Œ£ (‚ñπ L‚Ñß ‚ü® ‚ü¶ B ‚üßty ‚ü©) Œª lb'~ ->
      MonFun.f (wait-r-p ‚ü¶ c ‚üßlt) (Œ∏ lb~) ‚â°
      Œ∏ (Œª t -> MonFun.f (wait-r-p ‚ü¶ c ‚üßlt) (lb'~ t))
  wait-r-Œ∏ dyn la~ = la~ , refl
  wait-r-Œ∏ {Ai => Ao} {Bi => Bo} (cin => cout) la~ = {!!}
  wait-r-Œ∏ nat la~ = la~ , refl
  wait-r-Œ∏ inj-nat la~ = la~ , refl
  wait-r-Œ∏ {Ai => Ao} (inj-arrow (cin => cout)) la~ = la~ ,
    transport (Œª i -> Œ¥ (Œ∏ la~) ‚â° Œ∏ (Œª t -> Œ∏ (next-Mt‚â°M la~ t (~ i)))) refl

  -- Goal :  Œ¥ (Œ∏ la~)        ‚â° Œ∏ (Œª t ‚Üí Œ¥ (la~ t))
  -- i.e.    Œ∏ (next (Œ∏ la~)) ‚â° Œ∏ (Œª t ‚Üí Œ∏ (next (la~ t)))
  
  -- By tick irr + later extensionality, we have that
  -- ‚ñ∏ Œª t -> (next (la~ t) == la~)

  -- So the goal becomes
  -- Œ∏ (next (Œ∏ la~)) ‚â° Œ∏ (Œª t ‚Üí Œ∏ (la~))
  -- Œ∏ (next (Œ∏ la~)) ‚â° Œ∏ (next (Œ∏ la~))
  


-- Universal properties of casts
module UniversalProps where
{-
UpR : {A B C : Ty} ->
  (M1 : ‚ü® ‚ü¶ A ‚üßty ‚ü©) ->
  (M2 : ‚ü® ‚ü¶ B ‚üßty ‚ü©) ->
  (c : A ‚äë B) ->
  (d : B ‚äë C) ->
  typrecd-sem c M1 M2 ->
  typrecd-sem (‚äëcomp c d)
    (MonFun.f (EP.wait-l-e ‚ü¶ c ‚üßlt) M1)
    (MonFun.f (EP.emb ‚ü¶ d ‚üßlt) M2)
UpR M1 M2 dyn dyn M1‚äëM2 = M1‚äëM2

UpR {Ai => Ao} {Bi => Bo} {Ci => Co}
  M1 M2 (cin => cout) (din => dout) M1‚äëM2 =
  Œª ai ci ai‚äëci ‚Üí {!!}

UpR {Ai => Ao} {Bi => Bo}
  M1 M2 (cin => cout) (inj-arrow (cin' => cout')) M1‚äëM2 =
  {!!}

UpR M1 M2 nat nat M1‚äëM2 = M1‚äëM2

UpR M1 M2 nat inj-nat M1‚äëM2 = {!!}

UpR M1 M2 inj-nat dyn M1‚äëM2 = M1‚äëM2

UpR {Ai => Ao} M1 M2 (inj-arrow (cin' => cout')) dyn M1‚äëM2 = {!!}
-}


  UpR : {A B C : Ty} ->
    (M1 M2 : ‚ü® ‚ü¶ A ‚üßty ‚ü©) ->
    (c : A ‚äë B) ->
    rel ‚ü¶ A ‚üßty M1 M2 ->
    typrecd-sem c
      (MonFun.f (EP.wait-l-e ‚ü¶ c ‚üßlt) M1)
      (MonFun.f (EP.emb ‚ü¶ c ‚üßlt) M2)
  UpR M1 M2 dyn M1‚äëM2 = M1‚äëM2
  UpR M1 M2 (cin => cout) M1‚äëM2 = {!!}
  UpR M1 M2 nat M1‚äëM2 = M1‚äëM2
  UpR M1 M2 inj-nat M1‚äëM2 = {!!} -- transport stuff
  UpR {Ai => Ao} M1 M2 (inj-arrow (cin' => cout')) M1‚äëM2 = {!!}



  UpL : {A B C : Ty} ->
    (M1 : ‚ü® ‚ü¶ A ‚üßty ‚ü©) ->
    (M2 : ‚ü® ‚ü¶ B ‚üßty ‚ü©) ->
    (c : A ‚äë B) ->
    typrecd-sem c M1 M2 ->
    rel ‚ü¶ B ‚üßty
      (MonFun.f (EP.emb ‚ü¶ c ‚üßlt) M1)
      (MonFun.f (EP.wait-r-e ‚ü¶ c ‚üßlt) M2)
  UpL M1 M2 dyn M1‚äëM2 = M1‚äëM2
  UpL M1 M2 (cin => cout) M1‚äëM2 = {!!}
  UpL M1 M2 nat M1‚äëM2 = M1‚äëM2
  UpL M1 M2 inj-nat M1‚äëM2 = {!!} -- transport stuff
  UpL {Ai => Ao} M1 M2 (inj-arrow (cin' => cout')) M1‚äëM2 = {!!}

-- By our assumption that M1 is related to M2,
-- (DynP-to-DynP' M2) must be of the form (fun f') where
-- ‚ñ∏ (Œª t -> M1 ‚äë (f' t)).
-- Thus, we have that emb M1 is related to M2 in the DynP relation
-- which is what we needed to show (since here wait-r-e is the identity)























id‚â§map : {A B : Predomain} ->
  (la la' : L‚Ñß ‚ü® A ‚ü©) ->
  (f : ‚ü® A ‚ü© -> ‚ü® B ‚ü©) ->
  (R : ‚ü® A ‚ü© -> ‚ü® B ‚ü© -> Type) ->
  ((a a' : ‚ü® A ‚ü©) -> rel A a a' -> R a (f a')) ->
  ord' A (next (ord A)) la la' ->
  LiftRelation.ord' A B R (next (LiftRelation.ord A B R)) la (mapL f la')
id‚â§map {A} {B} (Œ∑ x) (Œ∑ x') f R H la‚â§la' =
  -- subst {!!} {!!} (H x x' la‚â§la')  -- (H x x' la‚â§la')
  transport
    (sym (Œª i ‚Üí LiftRelation.ord' A B R _ (Œ∑ x) (mapL-eta f x' i)))
    (H x x' la‚â§la')
id‚â§map ‚Ñß la' f R H la‚â§la' = tt
id‚â§map {A} {B} (Œ∏ lx~) (Œ∏ ly~) f R H la‚â§la' =
  transport
    (sym (Œª i ‚Üí LiftRelation.ord' A B R (next (LiftRelation.ord A B R)) (Œ∏ lx~) (mapL-theta f ly~ i)))
    Œª t ‚Üí {!!}

-- LiftRelation.ord' A B R (next (LiftRelation.ord A B R)) (Œ∑ x)
--      (mapL f (Œ∑ x'))









------------------------------
-- *** Beta/eta properties ***


-- Semantic interpretation of substitution

-- Correct subtitution lemma for values




-- This is incorrect. Counterexample is if N is err and M is a term that
-- doesn't refer to its free variable
sub-lemma : (Œì : Ctx) (A B : Ty) -> (M : Tm (Œì :: A) B) -> (N : Tm Œì A) ->
  rel (‚ü¶ Œì ‚üßctx ==> ùïÉ ‚ü¶ B ‚üßty)
      (‚ü¶ M [ N ] ‚üßtm)
      (Bind ‚ü¶ Œì ‚üßctx ‚ü¶ N ‚üßtm (‚ü¶ M ‚üßtm))
sub-lemma Œì A .A (var vz) N = bind-Ret' (‚ü¶ N ‚üßtm) (mLook A vz)
sub-lemma Œì A B (var (vs x)) N = {!!}
sub-lemma Œì A .(_ => _) (lda M) N = {!!}
sub-lemma Œì A B (app M1 M2) N = {!!}
sub-lemma Œì A B err N = bind-K (‚ü¶ N ‚üßtm) ‚Ñß
sub-lemma Œì A B (up x M) N = {!!}
sub-lemma Œì A B (dn x M) N = {!!}
sub-lemma Œì A .nat zro N = bind-K (‚ü¶ N ‚üßtm) (Œ∑ zero)
sub-lemma Œì A .nat (suc M) N = {!!}

{-
lem1 : ‚àÄ (Œì : Ctx) (A B : Ty) -> (M : Tm (Œì :: A) B) (N : Tm Œì A) ->
   ‚ü¶ app (lda M) N ‚üßtm ‚â° {!!}
lem1 Œì A B M N =
  let kont = (K (swap mExt) <*> tm-sem N) in
  (mExt' kont <*> tm-sem (lda M))
    ‚â°‚ü® refl ‚ü©
  let kont = (K (swap mExt) <*> tm-sem N) in
  (mExt' kont <*> (mRet' (K (tm-sem M) ‚àòm Pair)))
    ‚â°‚ü® {! refl!} ‚ü©
  mExt' (K (swap mExt) <*> tm-sem N) <*> (mRet' (K (tm-sem M) ‚àòm Pair))
    ‚â°‚ü® {!!} ‚ü©
  {!!}
    ‚â°‚ü® {!!} ‚ü©
  {!!}

-}


beta-lt : (Œì : Ctx) (A B : Ty) -> (M : Tm (Œì :: A) B) -> {!!}
  -- rel {!!} ‚ü¶ app (lda {!!}) (var vz) ‚üßtm ‚ü¶ M ‚üßtm
beta-lt = {!!}



{-
eta : (Œì : Ctx) (A B : Ty) -> (M : Tm Œì (A => B)) ->
  rel {!!}  ‚ü¶ M ‚üßtm ‚ü¶ {!lda!} ‚üßtm
eta = {!!}
-}


{-

-}
