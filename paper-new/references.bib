%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                       String Definitions                         %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Publishing houses
% %%%%%%%%%%%%%%%%%
@STRING{ap =        "Academic Press" }
@STRING{springer =  {Springer-Verlag} }
@STRING{lncs =      "Lecture Notes in Computer Science" }
@STRING{lnm =       "Lecture Notes in Mathematics" }
@STRING{gtm =       "Graduate Texts in Mathematics" }
@STRING{lfcs =      "Laboratory for Foundations of Computer Science,
                    University of Edinburgh" }
@STRING{mp =        "MIT Press" }
@STRING{mitpress =  mp }
%
% Journals and magazines
% %%%%%%%%%%%%%%%%%%%%%%
@STRING{toplas =    "ACM Transactions on Programming Languages and Systems" }
@STRING{jlp =       {Journal of Logic Programming} }
@STRING{cacm =      "Communications of the {ACM}" }
@STRING{jacm =      "Journal of the {ACM}" }
@STRING{tcs =       "Theoretical Computer Science" }
@STRING{jsl =       "Journal of Symbolic Logic" }
@STRING{siamjc =    "SIAM Journal on Computing" }
@STRING{mscs =      "Mathematical Structures in Computer Science" }
@STRING{proc =      "Proceedings of the" }
@STRING{ic =        "Information and Computation" }
@STRING{iandcomp =  {Information and Computation} }
@string{ifip =      "International Federation for Information Processing World Computer Congress (IFIP)"}
@STRING{jfp =       "Journal of Functional Programming" }
@STRING{lmcs =      "Logical Methods in Computer Science" }
@string{hosc =      "Higher-Order and Symbolic Computation"}
@STRING{cup =       "Cambridge University Press" }
@STRING{mcgh =      "McGraw-Hill" }
@STRING{nh =        "North Holland" }
@STRING{sv =        "Springer-Verlag" }
@STRING{aw =        "Addison-Wesley" }
@STRING{ph =        "Prentice Hall" }
@STRING{signot =    "SIGPLAN Notices"}
@STRING{taoop =     "Carl A. Gunter and John C. Mitchell, editors, {\em
                    Theoretical Aspects of Object-Oriented Programming:
                    Types, Semantics, and Language Design}, MIT Press, 1994" }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             Conferences                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@STRING{popl =      "{ACM} {S}ymposium on {P}rinciples of {P}rogramming
                     {L}anguages ({POPL})" }
@STRING{popl73 =    popl # ", Boston, Massachusetts" }
@STRING{popl75 =    popl # ", Palo Alto, California" }
@STRING{popl76 =    popl # ", {A}tlanta, {G}eorgia" }
@STRING{popl77 =    popl # ", Los Angeles, California" }
@STRING{popl78 =    popl # ", Tucson, Arizona" }
@STRING{popl79 =    popl # ", San Antonio, Texas" }
@STRING{popl80 =    popl # ", Las Vegas, Nevada" }
@STRING{popl81 =    popl # ", Williamsburg, Virginia" }
@STRING{popl82 =    popl # ", Albuquerque, New Mexico" }
@STRING{popl83 =    popl # ", Austin, Texas" }
@STRING{popl84 =    popl # ", Salt Lake City, Utah" }
@STRING{popl85 =    popl # ", New Orleans, Louisiana" }
@STRING{popl86 =    popl # ", St.\ Petersburg Beach, Florida" }
@STRING{popl87 =    popl # ", Munich, Germany" }
@STRING{popl88 =    popl # ", San Diego, California" }
@STRING{popl89 =    popl # ", Austin, Texas" }
@STRING{popl90 =    popl # ", {S}an {F}rancisco, {C}alifornia" }
@STRING{popl91 =    popl # ", Orlando, Florida" }
@STRING{popl92 =    popl # ", Albuquerque, New Mexico" }
@STRING{popl93 =    popl # ", Charleston, South Carolina" }
@STRING{popl94 =    popl # ", {P}ortland, {O}regon" }
@STRING{popl95 =    popl # ", San Francisco, California" }
@STRING{popl96 =    popl # ", St.~Petersburg Beach, Florida" }
@STRING{popl97 =    popl # ", Paris, France" }
@STRING{popl98 =    popl # ", San Diego, California" }
@STRING{popl99 =    popl # ", San Antonio, Texas" }
@STRING{popl00 =    popl # ", Boston, Massachusetts" }
@STRING{popl01 =    popl # ", London, England" }
@STRING{popl02 =    popl # ", Portland, Oregon" }
@STRING{popl03 =    popl # ", New Orleans, Louisiana" }
@STRING{popl04 =    popl # ", Venice, Italy" }
@STRING{popl05 =    popl # ", Long Beach, California" }
@STRING{popl06 =    popl # ", Charleston, South Carolina" }
@STRING{popl07 =    popl # ", Nice, France" }
@STRING{popl08 =    popl # ", San Francisco, California" }
@STRING{popl09 =    popl # ", Savannah, Georgia" }
@STRING{popl10 =    popl # ", Madrid, Spain" }
@STRING{popl11 =    popl # ", Austin, Texas" }
@STRING{popl12 =    popl # ", Philadelphia, Pennsylvania" }
@STRING{popl13 =    popl # ", Rome, Italy" }
@STRING{popl14 =    popl # ", San Diego, California" }
@STRING{popl15 =    popl # ", Mumbai, India" }
@STRING{popl16 =    popl # ", St. Petersburg, Florida" }
@STRING{popl17 =    popl # ", Paris, France" }
@STRING{popl19 =    popl # ", Cascais, Portugal" }
% ----
@STRING{icfp =      "{I}nternational {C}onference on {F}unctional {P}rogramming
                    ({ICFP})" }
@STRING{icfp96 =    icfp # ", Philadelphia, Pennsylvania" }
@STRING{icfp97 =    icfp # ", Amsterdam, The Netherlands" }
@STRING{icfp98 =    icfp # ", Baltimore, Maryland, USA" }
@STRING{icfp99 =    icfp # ", Paris, France" }
@STRING{icfp00 =    icfp # ", Montreal, Canada" }
@STRING{icfp01 =    icfp # ", Firenze, Italy" }
@STRING{icfp02 =    icfp # ", Pittsburgh, Pennsylvania" }
@STRING{icfp03 =    icfp # ", Uppsala, Sweden" }
@STRING{icfp04 =    icfp # ", Snowbird, Utah" }
@STRING{icfp05 =    icfp # ", Tallinn, Estonia" }
@STRING{icfp06 =    icfp # ", Portand, Oregon" }
@STRING{icfp07 =    icfp # ", Freiburg, Germany" }
@STRING{icfp08 =    icfp # ", Victoria, British Columbia, Canada" }
@STRING{icfp09 =    icfp # ", Edinburgh, Scotland" }
@STRING{icfp10 =    icfp # ", Baltimore, Maryland" }
@STRING{icfp11 =    icfp # ", Tokyo, Japan" }
@STRING{icfp12 =    icfp # ", Copenhagen, Denmark" }
@STRING{icfp13 =    icfp # ", Boston, Massachusetts" }
@STRING{icfp14 =    icfp # ", Gothenburg, Sweden" }
@STRING{icfp15 =    icfp # ", Vancouver, British Columbia, Canada" }
@STRING{icfp16 =    icfp # ", Nara, Japan" }
@STRING{icfp17 =    icfp # ", Oxford, United Kingdom" }
@STRING{icfp18 =    icfp # ", St. Louis, Missouri" }

% ----
@STRING{oopsla =    "{ACM} {S}ymposium on {O}bject {O}riented {P}rogramming:
                    {S}ystems, {L}anguages, and {A}pplications ({OOPSLA})" }
@STRING{oopsla86 =  oopsla # ", Portland, Oregon" }
@STRING{oopsla89 =  oopsla }
@STRING{oopsla98 =  oopsla # ", Vancouver, British Columbia" }
@STRING{oopsla08 =  oopsla # ", Nashville, Tennessee" }
% ----
@STRING{types = "Types for Proofs and Programs (TYPES)"}
@STRING{types15 = types # ", Tallinn, Estonia"}
@STRING{oldLics =      "IEEE Symposium on Logic in Computer Science (LICS)" }
@STRING{lics =      "ACM/IEEE Symposium on Logic in Computer Science (LICS)" }
@STRING{lics89 =    oldLics # "Pacific Grove, California" }
@STRING{lics91 =    oldLics # ", Amsterdam, The Netherlands" }
@STRING{lics92 =    lics # ", Santa Cruz, California" }
@STRING{lics93 =    lics # ", Montreal, Canada" }
@STRING{lics94 =    lics # ", Paris, France" }
@STRING{lics95 =    lics # ", San Diego, California" }
@STRING{lics96 =    lics # ", New Brunswick, New Jersey" }
@STRING{lics97 =    lics # ", Warsaw, Poland" }}
@STRING{lics98 =    lics # ", Indianapolis, Indiana" }
@STRING{lics99 =    lics # ", Trento, Italy" }
@STRING{lics00 =    lics # ", Santa Barbara, California" }
@STRING{lics01 =    lics # ", Boston, Massachusetts" }
@STRING{lics02 =    lics # ", Copenhagen, Denmark" }
@STRING{lics03 =    lics # ", Ottawa, Canada" }
@STRING{lics04 =    lics # ", Turku, Finland" }
@STRING{lics05 =    lics # ", Chicago, Illinois" }
@STRING{lics06 =    lics # ", Seattle, Washington" }
@STRING{lics07 =    lics # ", Wroclaw, Poland" }
@STRING{lics08 =    lics # ", Pittsburgh, Pennsylvania" }
@STRING{lics09 =    lics # ", Los Angeles, California" }
@STRING{lics10 =    lics # ", Edinburgh, Scotland" }
@STRING{lics11 =    lics # ", Toronto, Canada" }
@STRING{lics12 =    lics # ", Dubrovnik, Croatia" }
@STRING{lics13 =    lics # ", New Orleans, Louisiana" }
@STRING{lics14 =    lics # ", Vienna, Austria" }
@STRING{lics16 =    lics # ", New York City, New York" }
@STRING{lics17 =    lics # ", Reykjavik, Iceland" }
@STRING{lics22 =    lics # ", Haifa, Israel" }
% ----
@STRING{pldi =      "{ACM SIGPLAN Conference on Programming Language Design
                    and Implementation (PLDI)}" }
@STRING{pldi88 =    pldi # ", {A}tlanta, {G}eorgia" }
@STRING{pldi89 =    pldi # ", Portland, Oregon" }
@STRING{pldi90 =    pldi # ", White Plains, New York" }
@STRING{pldi91 =    pldi # ", Toronto, Ontario" }
@STRING{pldi92 =    pldi # ", San Francisco, California" }
@STRING{pldi93 =    pldi # ", Albuquerque, New Mexico" }
@STRING{pldi94 =    pldi # ", Orlando, Florida" }
@STRING{pldi95 =    pldi # ", La Jolla, California" }
@STRING{pldi96 =    pldi # ", Philadephia, Pennsylvania" }
@STRING{pldi97 =    pldi # ", Las Vegas, Nevada" }
@STRING{pldi98 =    pldi # ", {M}ontreal, {C}anada" }
@STRING{pldi99 =    pldi # ", {A}tlanta, {G}eorgia" }
@STRING{pldi00 =    pldi # ", Vancouver, British Columbia, Canada" }
@STRING{pldi01 =    pldi # ", Snowbird, Utah" }
@STRING{pldi02 =    pldi # ", Berlin, Germany" }
@STRING{pldi03 =    pldi # ", San Diego, California" }
@STRING{pldi04 =    pldi # ", Washington, DC" }
@STRING{pldi05 =    pldi # ", Chicago, Illinois" }
@STRING{pldi06 =    pldi # ", Ottawa, Canada" }
@STRING{pldi07 =    pldi # ", San Diego, California" }
@STRING{pldi08 =    pldi # ", Tucson, Arizona" }
@STRING{pldi09 =    pldi # ", Dublin, Ireland" }
@STRING{pldi10 =    pldi # ", Toronto, Canada" }
@STRING{pldi11 =    pldi # ", San Jose, California" }
@STRING{pldi12 =    pldi # ", Beijing, China" }
@STRING{pldi13 =    pldi # ", Seattle, Washington" }
@STRING{pldi14 =    pldi # ", Edinburgh, Scotland" }
% ----
@STRING{lfp =       "ACM Symposium on Lisp and Functional Programming (LFP)" }
@STRING{lfp84 =     lfp # ", Austin, Texas" }
@STRING{lfp88 =     lfp # ", Snowbird, Utah" }
@STRING{lfp90 =     lfp }
@STRING{lfp92 =     lfp }
% ----
@STRING{fpca =      "ACM Symposium on Functional Programming Languages and
                    Computer Architecture (FPCA)" }
@STRING{fpca89 =    fpca }
@STRING{fpca93 =    fpca }
% ----
@STRING{sosp=" {ACM} {S}ymposium on {O}perating {S}ystems {P}rinciples ({SOSP})"}
% ----
@STRING{fool =      "Workshop on Foundations of Object-Oriented Languages
                    (FOOL), informal proceedings" }
@STRING{tlca =      "Typed Lambda Calculi and Applications (TLCA)" }
@STRING{tlca93 =    tlca # ", Utrecht, The Netherlands" }
@STRING{tlca95 =    tlca # ", Edinburgh, UK" }
@STRING{tlca97 =    tlca # ", Nancy, France" }
@STRING{tlca99 =    tlca # ", L'Aquila, Italy" }
@STRING{tlca01 =    tlca # ", Krakow, Poland" }
@STRING{tlca03 =    tlca # ", Valencia, Spain" }
@STRING{tlca05 =    tlca # ", Nara, Japan" }
@STRING{tlca07 =    tlca # ", Paris, France" }
@STRING{tlca09 =    tlca # ", Brasilia, Brazil" }
@STRING{tlca11 =    tlca # ", Novi Sad, Serbia" }
@STRING{tlca13 =    tlca # ", Eindhoven, The Netherlands" }

@string{fscd = "Formal Structures for Computation and Deduction"}
@string{fscd18 = fscd # ", Oxford England"}

@string{cav =       "Conference on Computer Aided Verification (CAV)"}
@string{ccs =       "ACM Conference on Computer and Communication Security (CCS)"}
@string{oakland =   "{IEEE} Symposium on Security and Privacy"}
@string{dls =       "Dynamic Languages Symposium (DLS)"}
@STRING{esop =      "European Symposium on Programming (ESOP)" }
@STRING{esop92 =    esop # ", Rennes, France" }
@STRING{ecoop =     "{E}uropean {C}onference on {O}bject-{O}riented
                    {P}rogramming ({ECOOP})" }
@STRING{ecoop97 =   ecoop }
@STRING{ecoop02 =   ecoop # ", Malaga, Spain" }
@STRING{flops =     "International Symposium on Functional and Logic Programming (FLOPS)" }
@STRING{flops02 =   flops # ", Aizu, Japan" }
@string{icalp =     "International Colloquium on Automata, Languages and Programming (ICALP)"}
@string{plpv =      "Programming Languages meets Program Verification (PLPV)"}
@STRING{post =      "Principles of Security and Trust (POST)" }
@string{ppdp =      "ACM Conference on Principles and Practice of Declarative Programming (PPDP)"}
@string{scheme =    "Scheme and Functional Programming Workshop (Scheme)"}
@string{stop =      "Workshop on Script-to-Program Evolution (STOP)"}
@string{tldi =      "ACM SIGPLAN Workshop on Types in Language Design and Implementation (TLDI)"}
@STRING{tacs =      "Theoretical Aspects of Computer Software (TACS)" }
@STRING{tacs01 =    tacs # ", Sendai, Japan" }
@string{tfp =       "Trends in Functional Programming (TFP)"}
@STRING{webdb =     {International Workshop on the Web and Databases
                    (WebDB)} }
@STRING{langsec = "Language-theoretic Security IEEE Security and Privacy Workshop (LangSec)"}
@STRING{fossacs = "Foundations of Software Science and Computational Structures"}
@STRING{fossacs09 = fossacs # ", Berlin"}
@STRING{pacmpl = "Proceedings of the ACM on Programming Languages (PACMPL)"}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@INPROCEEDINGS{Nakano2000,
  author={Nakano, H.},
  booktitle=lics00,
  title={A modality for recursion},
  year={2000},
  volume={},
  number={},
  doi={10.1109/LICS.2000.855774}}


@article{Mannaa2020TickingCA,
  title={Ticking clocks as dependent right adjoints: Denotational semantics for clocked type theory},
  author={Bassel Mannaa and Rasmus Ejlers M{\o}gelberg and Niccol{\`o} Veltri},
  journal={Log. Methods Comput. Sci.},
  year={2020},
  volume={16}
}

@inproceedings{mogelberg-paviotti2016,
author = {M\o{}gelberg, Rasmus Ejlers and Paviotti, Marco},
year = {2016},
title = {Denotational Semantics of Recursive Types in Synthetic Guarded Domain Theory},
booktitle = lics16,
url = {https://doi.org/10.1145/2933575.2934516},
doi = {10.1145/2933575.2934516},
}

@inproceedings{veltri-vezzosi2020,
author = {Veltri, Niccol\`{o} and Vezzosi, Andrea},
title = {Formalizing $\pi$-Calculus in Guarded Cubical Agda},
year = {2020},
url = {https://doi.org/10.1145/3372885.3373814},
doi = {10.1145/3372885.3373814},
booktitle = {ACM SIGPLAN International Conference on Certified Programs and Proofs (CPP)},
pages = {270-283},
numpages = {14},
keywords = {pi-calculus, ticked cubical type theory, denotational semantics, guarded recursion},
location = {New Orleans, LA, USA},
}


@INPROCEEDINGS{birkedal-mogelberg-schwinghammer-stovring2011,
  author={Birkedal, Lars and Mogelberg, Rasmus Ejlers and Schwinghammer, Jan and Stovring, Kristian},
  booktitle=lics11,
  title={First Steps in Synthetic Guarded Domain Theory: Step-Indexing in the Topos of Trees},
  year={2011},
  volume={},
  number={},
  doi={10.1109/LICS.2011.16}
}


@INPROCEEDINGS{bahr-grathwohl-bugge-mogelberg2017,
  author={Bahr, Patrick and Grathwohl, Hans Bugge and Møgelberg, Rasmus Ejlers},
  booktitle=lics17,
  title={The clocks are ticking: No more delays!},
  year={2017},
  doi={10.1109/LICS.2017.8005097}
}


@inproceedings{atkey-mcbride2013,
author = {Atkey, Robert and McBride, Conor},
title = {Productive Coprogramming with Guarded Recursion},
year = {2013},
isbn = {9781450323260},
url = {https://doi.org/10.1145/2500365.2500597},
doi = {10.1145/2500365.2500597},
booktitle = icfp13,
pages = {197-208},
numpages = {12},
}

@article{10.1145/2544174.2500597,
author = {Atkey, Robert and McBride, Conor},
title = {Productive Coprogramming with Guarded Recursion},
year = {2013},
issue_date = {September 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2544174.2500597},
doi = {10.1145/2544174.2500597},
abstract = {Total functional programming offers the beguiling vision that, just by virtue of the compiler accepting a program, we are guaranteed that it will always terminate. In the case of programs that are not intended to terminate, e.g., servers, we are guaranteed that programs will always be productive. Productivity means that, even if a program generates an infinite amount of data, each piece will be generated in finite time. The theoretical underpinning for productive programming with infinite output is provided by the category theoretic notion of final coalgebras. Hence, we speak of coprogramming with non-well-founded codata, as a dual to programming with well-founded data like finite lists and trees.Systems that offer facilities for productive coprogramming, such as the proof assistants Coq and Agda, currently do so through syntactic guardedness checkers. Syntactic guardedness checkers ensure that all self-recursive calls are guarded by a use of a constructor. Such a check ensures productivity. Unfortunately, these syntactic checks are not compositional, and severely complicate coprogramming.Guarded recursion, originally due to Nakano, is tantalising as a basis for a flexible and compositional type-based approach to coprogramming. However, as we show, by itself, guarded recursion is not suitable for coprogramming due to the fact that there is no way to make finite observations on pieces of infinite data. In this paper, we introduce the concept of clock variables that index Nakano's guarded recursion. Clock variables allow us to "close over" the generation of infinite data, and to make finite observations, something that is not possible with guarded recursion alone.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {197-208},
numpages = {12},
keywords = {guarded recursion, coalgebras, total functional programming, corecursion}
}


@inproceedings{kristensen-mogelberg-vezzosi2022,
author = {Baunsgaard Kristensen, Magnus and Mogelberg, Rasmus Ejlers and Vezzosi, Andrea},
title = {Greatest HITs: Higher Inductive Types in Coinductive Definitions via Induction under Clocks},
year = {2022},
isbn = {9781450393515},
url = {https://doi.org/10.1145/3531130.3533359},
doi = {10.1145/3531130.3533359},
booktitle = lics22,
}


@article{mogelberg-veltri2019,
author = {M\o{}gelberg, Rasmus Ejlers and Veltri, Niccol\`{o}},
title = {Bisimulation as Path Type for Guarded Recursive Types},
year = {2019},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290317},
doi = {10.1145/3290317},
journal = pacmpl,
month = {jan},
articleno = {4},
numpages = {29},
}


@article{new-ahmed2018,
author = {New, Max S. and Ahmed, Amal},
title = {Graduality from Embedding-Projection Pairs},
year = {2018},
issue_date = {September 2018},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236768},
doi = {10.1145/3236768},
journal = pacmpl,
month = {jul},
articleno = {73},
}


@article{new-licata-ahmed2019,
author = {New, Max S. and Licata, Daniel R. and Ahmed, Amal},
title = {Gradual Type Theory},
year = {2019},
issue_date = {January 2019},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290328},
doi = {10.1145/3290328},
journal = pacmpl,
month = {jan},
articleno = {15},
numpages = {31},
}


@InProceedings{siek_et_al:LIPIcs:2015:5031,
  author =	{Jeremy G. Siek and Michael M. Vitousek and Matteo Cimini and John Tang Boyland},
  title =	{{Refined Criteria for Gradual Typing}},
  booktitle =	{1st Summit on Advances in Programming Languages (SNAPL 2015)},
  pages =	{274--293},
  year =	{2015},
  volume =	{32},
  doi =		{10.4230/LIPIcs.SNAPL.2015.274},
}


@inproceedings{garcia-clark-tanter2016,
author = {Garcia, Ronald and Clark, Alison M. and Tanter, \'{E}ric},
title = {Abstracting Gradual Typing},
year = {2016},
isbn = {9781450335492},
url = {https://doi.org/10.1145/2837614.2837670},
doi = {10.1145/2837614.2837670},
booktitle = popl16,
pages = {429-442},
numpages = {14},
keywords = {abstract interpretation, gradual typing, subtyping},
}

@article{10.1145/2914770.2837670,
author = {Garcia, Ronald and Clark, Alison M. and Tanter, \'{E}ric},
title = {Abstracting Gradual Typing},
year = {2016},
issue_date = {January 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2914770.2837670},
doi = {10.1145/2914770.2837670},
abstract = {Language researchers and designers have extended a wide variety of type systems to support gradual typing, which enables languages to seamlessly combine dynamic and static checking. These efforts consistently demonstrate that designing a satisfactory gradual counterpart to a static type system is challenging, and this challenge only increases with the sophistication of the type system. Gradual type system designers need more formal tools to help them conceptualize, structure, and evaluate their designs. In this paper, we propose a new formal foundation for gradual typing, drawing on principles from abstract interpretation to give gradual types a semantics in terms of pre-existing static types. Abstracting Gradual Typing (AGT for short) yields a formal account of consistency---one of the cornerstones of the gradual typing approach---that subsumes existing notions of consistency, which were developed through intuition and ad hoc reasoning. Given a syntax-directed static typing judgment, the AGT approach induces a corresponding gradual typing judgment. Then the type safety proof for the underlying static discipline induces a dynamic semantics for gradual programs defined over source-language typing derivations. The AGT approach does not resort to an externally justified cast calculus: instead, run-time checks naturally arise by deducing evidence for consistent judgments during proof reduction. To illustrate the approach, we develop a novel gradually-typed counterpart for a language with record subtyping. Gradual languages designed with the AGT approach satisfy by construction the refined criteria for gradual typing set forth by Siek and colleagues.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {429-442},
numpages = {14},
keywords = {subtyping, gradual typing, abstract interpretation}
}


@inproceedings{cimini-siek2016,
author = {Cimini, Matteo and Siek, Jeremy G.},
title = {The Gradualizer: A Methodology and Algorithm for Generating Gradual Type Systems},
doi = {10.1145/2837614.2837632},
booktitle = popl16,
year = {2016}
}

@article{10.1145/2914770.2837632,
author = {Cimini, Matteo and Siek, Jeremy G.},
title = {The Gradualizer: A Methodology and Algorithm for Generating Gradual Type Systems},
year = {2016},
issue_date = {January 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2914770.2837632},
doi = {10.1145/2914770.2837632},
abstract = {Many languages are beginning to integrate dynamic and static typing. Siek and Taha offered gradual typing as an approach to this integration that provides a coherent and full-span migration between the two disciplines. However, the literature lacks a general methodology for designing gradually typed languages. Our first contribution is to provide a methodology for deriving the gradual type system and the compilation to the cast calculus. Based on this methodology, we present the Gradualizer, an algorithm that generates a gradual type system from a well-formed type system and also generates a compiler to the cast calculus. Our algorithm handles a large class of type systems and generates systems that are correct with respect to the formal criteria of gradual typing. We also report on an implementation of the Gradualizer that takes a type system expressed in lambda-prolog and outputs its gradually typed version and a compiler to the cast calculus in lambda-prolog.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {443-455},
numpages = {13},
keywords = {gradual typing, methodology, semantics, type systems}
}









@inproceedings{wadler-findler09,
 author = "Philip Wadler and Robert Bruce Findler",
 title = "Well-typed programs can't be blamed",
 booktitle = esop,
 year = 2009,
 month = mar,
 pages = "1--16",
 location = "York, UK"
}

@inproceedings{tobin-hochstadt06,
 author = "Sam Tobin-Hochstadt and Matthias Felleisen",
 title = "Interlanguage Migration: From Scripts to Programs",
 booktitle = dls,
 month = oct,
 pages = "964--974",
 year = 2006,
}

@inproceedings{tobin-hochstadt08,
 author = {Sam Tobin-Hochstadt and Matthias Felleisen},
 title = {The Design and Implementation of Typed Scheme},
 booktitle = popl08,
 year = {2008}}

@inproceedings{siek-taha06,
 author = "Jeremy G. Siek and Walid Taha",
 title = "Gradual Typing for Functional Languages",
 booktitle = scheme,
 month = sep,
 pages = "81--92",
 year = 2006
}

@inproceedings{findler-felleisen02,
author = {Robert Bruce Findler and Matthias Felleisen},
title = {Contracts for higher-order functions},
booktitle = icfp,
year = {2002},
month = sep,
pages = {48--59}
}

@inproceedings{new-licata18,
  author    = {Max S. New and Daniel R. Licata},
  title     = {Call-by-name Gradual Type Theory},
  booktitle   = fscd18,
  year      = {2018},
  doi       = {10.4230/LIPIcs.FSCD.2018.24},
}

@phdthesis{levy01:phd,
author = "Levy, Paul Blain",
title = "Call-by-Push-Value",
type = "{Ph.~D.} Dissertation",
school = "Queen Mary, University of London",
department = "Department of Computer Science",
address = "London, UK",
month = mar,
year = "2001"}

@InProceedings{CohenCoquandHuberMortberg2017,
  author =	{Cohen, Cyril and Coquand, Thierry and Huber, Simon and M\"{o}rtberg, Anders},
  title =	{{Cubical Type Theory: A Constructive Interpretation of the Univalence Axiom}},
  booktitle =	types15,
  doi =		{10.4230/LIPIcs.TYPES.2015.5},
}

@article{VezzosiMortbergAbel2019,
author = {Vezzosi, Andrea and M\"{o}rtberg, Anders and Abel, Andreas},
title = {Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341691},
doi = {10.1145/3341691},
abstract = {Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.},
journal = pacmpl,
month = {jul},
articleno = {87},
numpages = {29},
keywords = {Univalence, Cubical Type Theory, Higher Inductive Types, Dependent Pattern Matching}
}

@article{new-jamner-ahmed19,
author = {New, Max S. and Jamner, Dustin and Ahmed, Amal},
title = {Graduality and Parametricity: Together Again for the First Time},
year = {2020},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371114},
doi = {10.1145/3371114},
journal = pacmpl,
month = {jan},
articleno = {46},
numpages = {32},
}

@article{lmcs:2265,
  TITLE = {{General Recursion via Coinductive Types}},
  AUTHOR = {Venanzio Capretta},
  URL = {https://lmcs.episciences.org/2265},
  DOI = {10.2168/LMCS-1(2:1)2005},
  JOURNAL = lmcs,
  VOLUME = {{Volume 1, Issue 2}},
  YEAR = {2005},
  MONTH = Jul,
  KEYWORDS = {Computer Science - Logic in Computer Science ; F.3.1},
}

@inproceedings{ma-reynolds,
author = {Ma, QingMing and Reynolds, John C.},
title = {Types, Abstractions, and Parametric Polymorphism, Part 2},
year = {1991},
isbn = {3540555110},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 7th International Conference on Mathematical Foundations of Programming Semantics},
pages = {1–40},
numpages = {40}
}

@phdthesis{dunphythesis,
 author = {Dunphy, Brian Patrick},
 advisor = {Reddy, Uday},
 title = {Parametricity As a Notion of Uniformity in Reflexive Graphs},
 year = {2002},
 school = {University of Illinois at Urbana-Champaign},
 address = {Champaign, IL, USA},
}

@article{reynoldsprogramme,
title = {Logical Relations and Parametricity – A Reynolds Programme for Category Theory and Programming Languages},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {303},
pages = {149-180},
year = {2014},
note = {Proceedings of the Workshop on Algebra, Coalgebra and Topology (WACT 2013)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2014.02.008},
url = {https://www.sciencedirect.com/science/article/pii/S1571066114000346},
author = {Claudio Hermida and Uday S. Reddy and Edmund P. Robinson},
keywords = {Universal algebra, Category Theory, Homomorphisms, Logical Relations, Natural Transformations, Parametric polymorphism, Relational Parametricity, Data abstraction, Information hiding, Definability, Reflexive Graphs, Fibrations, Relation lifting},
abstract = {In his seminal paper on “Types, Abstraction and Parametric Polymorphism,” John Reynolds called for homomorphisms to be generalized from functions to relations. He reasoned that such a generalization would allow type-based “abstraction” (representation independence, information hiding, naturality or parametricity) to be captured in a mathematical theory, while accounting for higher-order types. However, after 30 years of research, we do not yet know fully how to do such a generalization. In this article, we explain the problems in doing so, summarize the work carried out so far, and call for a renewed attempt at addressing the problem.}
}

@inproceedings{neis09,
 author = {Georg Neis and Derek Dreyer and Andreas Rossberg},
 title = {Non-Parametric Parametricity},
 booktitle = icfp09,
 pages = "135--148",
 year = {2009},
 month = sep,
 doi = {10.1145/1596550.1596572}
}

@inproceedings{ahmed06,
  author       = {Amal J. Ahmed},
  title        = {Step-Indexed Syntactic Logical Relations for Recursive and Quantified Types},
  booktitle    = {15th European Symposium on Programming, {ESOP} 2006, Vienna, Austria},
  volume       = {3924},
  pages        = {69--83},
  month        = mar,
  year         = {2006},
  url          = {https://doi.org/10.1007/11693024\_6},
  doi          = {10.1007/11693024\_6},
  timestamp    = {Tue, 05 Jul 2022 08:30:25 +0200},
}

@article{appelmcallester01,
author = {Appel, Andrew W. and McAllester, David},
title = {An indexed model of recursive types for foundational proof-carrying code},
year = {2001},
volume = {23},
number = {5},
issn = {0164-0925},
url = {https://doi.org/10.1145/504709.504712},
doi = {10.1145/504709.504712},
journal = toplas,
month = sep,
pages = {657–683},
numpages = {27}
}


@article{new-giovannini-licata-2022,
  author       = {Max S. New and
                  Eric Giovannini and
                  Daniel R. Licata},
  title        = {Gradual Typing for Effect Handlers},
  journal      = pacmpl,
  volume       = {7},
  number       = {{OOPSLA2}},
  pages        = {1758--1786},
  year         = {2023},
  url          = {https://doi.org/10.1145/3622860},
  doi          = {10.1145/3622860},
}

@inproceedings{levy99,
  author       = {Paul Blain Levy},
  title        = {Call-by-Push-Value: {A} Subsuming Paradigm},
  booktitle    = tlca99,
  volume       = {1581},
  pages        = {228--242},
  publisher    = {Springer},
  year         = {1999},
  url          = {https://doi.org/10.1007/3-540-48959-2\_17},
  doi          = {10.1007/3-540-48959-2\_17},
}


@article{eec,
  author       = {Jeff Egger and
                  Rasmus Ejlers M{\o}gelberg and
                  Alex Simpson},
  title        = {The enriched effect calculus: syntax and semantics},
  journal      = {J. Log. Comput.},
  volume       = {24},
  number       = {3},
  pages        = {615--654},
  year         = {2014},
  url          = {https://doi.org/10.1093/logcom/exs025},
  doi          = {10.1093/LOGCOM/EXS025},
  timestamp    = {Wed, 17 May 2017 14:25:55 +0200},
  biburl       = {https://dblp.org/rec/journals/logcom/EggerMS14.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{cfm2016,
  author       = {Pierre{-}Louis Curien and
                  Marcelo P. Fiore and
                  Guillaume Munch{-}Maccagnoni},
  title        = {A theory of effects and resources: adjunction models and polarised
                  calculi},
  booktitle    = popl16,
  doi          = {10.1145/2837614.2837652},
}

@phdthesis{Eremondi_2023, series={Electronic Theses and Dissertations (ETDs) 2008+}, title={On the design of a gradual dependently typed language for programming}, url={https://open.library.ubc.ca/collections/ubctheses/24/items/1.0428823}, DOI={http://dx.doi.org/10.14288/1.0428823}, school={University of British Columbia}, author={Eremondi, Joseph S.}, year={2023}, collection={Electronic Theses and Dissertations (ETDs) 2008+}}


@article{siek-chen2021,
  author       = {Jeremy G. Siek and
                  Tianyu Chen},
  title        = {Parameterized cast calculi and reusable meta-theory for gradually
                  typed lambda calculi},
  journal      = {J. Funct. Program.},
  volume       = {31},
  pages        = {e30},
  year         = {2021},
  url          = {https://doi.org/10.1017/S0956796821000241},
  doi          = {10.1017/S0956796821000241},
  timestamp    = {Fri, 21 Jan 2022 22:01:15 +0100},
  biburl       = {https://dblp.org/rec/journals/jfp/SiekC21.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{FIORE_1997, title={An enrichment theorem for an axiomatisation of categories of domains and continuous functions}, volume={7}, DOI={10.1017/S0960129597002429}, number={5}, journal={Mathematical Structures in Computer Science}, author={FIORE, MARCELO P.}, year={1997}, pages={591–618}}

@article{GrodinNSH24,
  author       = {Harrison Grodin and
                  Yue Niu and
                  Jonathan Sterling and
                  Robert Harper},
  title        = {Decalf: {A} Directed, Effectful Cost-Aware Logical Framework},
  journal      = pacmpl,
  volume       = {8},
  number       = {{POPL}},
  pages        = {273--301},
  year         = {2024},
  url          = {https://doi.org/10.1145/3632852},
  doi          = {10.1145/3632852},
  timestamp    = {Thu, 25 Jan 2024 09:55:47 +0100},
  biburl       = {https://dblp.org/rec/journals/pacmpl/GrodinNSH24.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/corr/abs-2210-02169,
  author       = {Jonathan Sterling and
                  Daniel Gratzer and
                  Lars Birkedal},
  title        = {Denotational semantics of general store and polymorphism},
  journal      = {CoRR},
  year         = {2022},
  doi          = {10.48550/ARXIV.2210.02169},
}

@article{action,
                  author = {G. Janelidze and G.M. Kelly},
                  title = { A Note on Actions of a Monoidal Category },
                  journal = {Theory and Applications of Categories},
                  volume = {9},
                  year = {2001},
                  number = {4},
                  pages = {61--91}
                  }

@article{MOGGI199155,
title = {Notions of computation and monads},
journal = {Information and Computation},
volume = {93},
number = {1},
pages = {55-92},
year = {1991},
note = {Selections from 1989 IEEE Symposium on Logic in Computer Science},
issn = {0890-5401},
doi = {https://doi.org/10.1016/0890-5401(91)90052-4},
url = {https://www.sciencedirect.com/science/article/pii/0890540191900524},
author = {Eugenio Moggi},
abstract = {The Î»-calculus is considered a useful mathematical tool in the study of programming languages, since programs can be identified with Î»-terms. However, if one goes further and uses Î²Î·-conversion to prove equivalence of programs, then a gross simplification is introduced (programs are identified with total functions from values to values) that may jeopardise the applicability of theoretical results. In this paper we introduce calculi, based on a categorical semantics for computations, that provide a correct basis for proving equivalence of programs for a wide range of notions of computation.}
}

@INPROCEEDINGS{39155,
author={Moggi, E.},
booktitle=lics89,
title={Computational lambda-calculus and monads},
year={1989},
volume={},
number={},
pages={14-23},
keywords={Computer languages;Calculus;Mathematical programming;Mathematical model;Logic programming;Reasoning about programs;Computer science;Contracts},
doi={10.1109/LICS.1989.39155}}

@article{gradualizing-cic,
author = {Lennon-Bertrand, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, \'{E}ric},
title = {Gradualizing the Calculus of Inductive Constructions},
year = {2022},
issue_date = {June 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/3495528},
doi = {10.1145/3495528},
abstract = {We investigate gradual variations on the Calculus of Inductive Construction (CIC) for swifter prototyping with imprecise types and terms. We observe, with a no-go theorem, a crucial trade-off between graduality and the key properties of normalization and closure of universes under dependent product that CIC enjoys. Beyond this Fire Triangle of Graduality, we explore the gradualization of CIC with three different compromises, each relaxing one edge of the Fire Triangle. We develop a parametrized presentation of Gradual CIC (GCIC) that encompasses all three variations, and develop their metatheory. We first present a bidirectional elaboration of GCIC to a dependently-typed cast calculus, CastCIC, which elucidates the interrelation between typing, conversion, and the gradual guarantees. We use a syntactic model of CastCIC to inform the design of a safe, confluent reduction, and establish, when applicable, normalization. We study the static and dynamic gradual guarantees as well as the stronger notion of graduality with embedding-projection pairs formulated by New and Ahmed, using appropriate semantic model constructions. This work informs and paves the way towards the development of malleable proof assistants and dependently-typed programming languages.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {apr},
articleno = {7},
numpages = {82},
keywords = {Gradual typing, proof assistants, dependent types}
}

@InProceedings{10.1007/978-3-319-08918-8_8,
author="Bizjak, Ale{\v{s}}
and Birkedal, Lars
and Miculan, Marino",
editor="Dowek, Gilles",
title="A Model of Countable Nondeterminism in Guarded Type Theory",
booktitle="Rewriting and Typed Lambda Calculi",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="108--123",
abstract="We show how to construct a logical relation for countable nondeterminism in a guarded type theory, corresponding to the internal logic of the topos Sh$\omega$1 of sheaves over $\omega$1. In contrast to earlier work on abstract step-indexed models, we not only construct the logical relations in the guarded type theory, but also give an internal proof of the adequacy of the model with respect to standard contextual equivalence. To state and prove adequacy of the logical relation, we introduce a new propositional modality. In connection with this modality we show why it is necessary to work in the logic of bf Sh$\omega$1.",
isbn="978-3-319-08918-8"
}

@article{shulman2007,
author = {Shulman, Michael},
year = {2007},
month = {06},
pages = {},
title = {Framed bicategories and monoidal fibrations},
volume = {20},
journal = {Theory and Applications of Categories}
}

@article{ahmed-findler-siek-wadler-2011,
author = {Ahmed, Amal and Findler, Robert Bruce and Siek, Jeremy G. and Wadler, Philip},
title = {Blame for all},
year = {2011},
issue_date = {January 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1925844.1926409},
doi = {10.1145/1925844.1926409},
abstract = {Several programming languages are beginning to integrate static and dynamic typing, including Racket (formerly PLT Scheme), Perl 6, and C# 4.0 and the research languages Sage (Gronski, Knowles, Tomb, Freund, and Flanagan, 2006) and Thorn (Wrigstad, Eugster, Field, Nystrom, and Vitek, 2009). However, an important open question remains, which is how to add parametric polymorphism to languages that combine static and dynamic typing. We present a system that permits a value of dynamic type to be cast to a polymorphic type and vice versa, with relational parametricity enforced by a kind of dynamic sealing along the lines proposed by Matthews and Ahmed (2008) and Neis, Dreyer, and Rossberg (2009). Our system includes a notion of blame, which allows us to show that when casting between a more-precise type and a less-precise type, any cast failures are due to the less-precisely-typed portion of the program. We also show that a cast from a subtype to its supertype cannot fail.},
journal = {SIGPLAN Not.},
month = jan,
pages = {201–214},
numpages = {14},
keywords = {blame tracking, casts, coercions, lambda-calculus}
}

@inproceedings{10.1145/1926385.1926409,
author = {Ahmed, Amal and Findler, Robert Bruce and Siek, Jeremy G. and Wadler, Philip},
title = {Blame for all},
year = {2011},
isbn = {9781450304900},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1926385.1926409},
doi = {10.1145/1926385.1926409},
abstract = {Several programming languages are beginning to integrate static and dynamic typing, including Racket (formerly PLT Scheme), Perl 6, and C# 4.0 and the research languages Sage (Gronski, Knowles, Tomb, Freund, and Flanagan, 2006) and Thorn (Wrigstad, Eugster, Field, Nystrom, and Vitek, 2009). However, an important open question remains, which is how to add parametric polymorphism to languages that combine static and dynamic typing. We present a system that permits a value of dynamic type to be cast to a polymorphic type and vice versa, with relational parametricity enforced by a kind of dynamic sealing along the lines proposed by Matthews and Ahmed (2008) and Neis, Dreyer, and Rossberg (2009). Our system includes a notion of blame, which allows us to show that when casting between a more-precise type and a less-precise type, any cast failures are due to the less-precisely-typed portion of the program. We also show that a cast from a subtype to its supertype cannot fail.},
booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {201–214},
numpages = {14},
keywords = {blame tracking, casts, coercions, lambda-calculus},
location = {Austin, Texas, USA},
series = {POPL '11}
}

@article{herman-tomb-flanagan-2010,
author = {Herman, David and Tomb, Aaron and Flanagan, Cormac},
title = {Space-efficient gradual typing},
year = {2010},
issue_date = {June      2010},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {23},
number = {2},
issn = {1388-3690},
url = {https://doi.org/10.1007/s10990-011-9066-z},
doi = {10.1007/s10990-011-9066-z},
abstract = {Gradual type systems offer a smooth continuum between static and dynamic typing by permitting the free mixture of typed and untyped code. The runtime systems for these languages, and other languages with hybrid type checking, typically enforce function types by dynamically generating function proxies. This approach can result in unbounded growth in the number of proxies, however, which drastically impacts space efficiency and destroys tail recursion.We present a semantics for gradual typing that is based on coercions instead of function proxies, and which combines adjacent coercions at runtime to limit their space consumption. We prove bounds on the space consumed by coercions as well as soundness of the type system, demonstrating that programmers can safely mix typing disciplines without incurring unreasonable overheads. Our approach also detects certain errors earlier than prior work.},
journal = {Higher Order Symbol. Comput.},
month = jun,
pages = {167–189},
numpages = {23},
keywords = {Casts, Coercions, Gradual typing, Type dynamic}
}

@article{guarded-interaction-trees,
author = {Frumin, Dan and Timany, Amin and Birkedal, Lars},
title = {Modular Denotational Semantics for Effects with Guarded Interaction Trees},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632854},
doi = {10.1145/3632854},
journal = pacmpl,
month = jan,
articleno = {12},
numpages = {30},
keywords = {Coq, Iris, denotational semantics, logical relations}
}

@article{recursion-probabilistic-choice-guarded,
  title        = {Modelling Recursion and Probabilistic Choice in Guarded Type Theory},
  author       = {Philipp Jan Andries Stassen and Rasmus Ejlers Møgelberg and Maaike Zwart and Alejandro Aguirre and Lars Birkedal},
  journal      = pacmpl,
  volume       = {9},
  number       = {{POPL}},
  year         = {2025},
  url          = {https://doi.org/10.1145/3704884},
  doi          = {10.1145/3704884},
}

@InProceedings{Birkedal-Stovring-Thamsborg-2009,
author="Birkedal, Lars
and St{\o}vring, Kristian
and Thamsborg, Jacob",
title="Realizability Semantics of Parametric Polymorphism, General References, and Recursive Types",
booktitle=fossacs09,
year="2009",
pages="456--470",
isbn="978-3-642-00596-1",
doi={10.1007/978-3-642-00596-1\_32}
}


@inproceedings{deepandshallowtypes,
author = {Greenman, Ben},
title = {Deep and shallow types for gradual languages},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523430},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {580–593},
numpages = {14},
keywords = {complete monitoring, gradual typing, migratory typing, type-enforcement strategies},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@inproceedings{transient,
author = {Vitousek, Michael M. and Swords, Cameron and Siek, Jeremy G.},
title = {Big types in little runtime: open-world soundness and collaborative blame for gradual type systems},
year = {2017},
doi = {10.1145/3009837.3009849},
booktitle = popl17,
}

@article{levystacks,
title = {Adjunction Models For Call-By-Push-Value With Stacks},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {69},
pages = {248-271},
year = {2003},
note = {CTCS'02, Category Theory and Computer Science},
issn = {1571-0661},
doi = {https://doi.org/10.1016/S1571-0661(04)80568-1},
author = {Paul Blain Levy},
}

@inproceedings{mogelberg-2014,
author = {M\o{}gelberg, Rasmus Ejlers},
title = {A type theory for productive coprogramming via guarded recursion},
year = {2014},
isbn = {9781450328869},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2603088.2603132},
doi = {10.1145/2603088.2603132},
booktitle = lics14,
articleno = {71},
numpages = {10},
keywords = {categorical semantics, corecursion, denotational semantics, dependent types, guarded recursion},
location = {Vienna, Austria},
}
