\section{A Guarded Model of Graduality}\label{sec:concrete-relational-model}

Next we describe in detail our compositional model of GTLC that
satisfies graduality. The definitions proceed in two phases: in the
first phase we define our objects, functions, relations and squares to
model the error ordering and bisimilarity, and then we add the extra
structure of perturbations and quasi-representability to our objects
and relations to ensure that we can model the cast rules.
%
Once these definitions are complete we show how to interpret the
types, type precision, terms and term precision compositionally in our
model, and finally we conclude by extracting a big step semantics from
this model that satisfies the graduality theorem.

\subsection{Phase One: Predomains and Error Domains}

As discussed in the previous section our model of types must now come
with both an error ordering and a bisimilarity relation.
\begin{definition}
A \textbf{predomain} $A$ consists of a set $A$ along with two relations:
\begin{itemize}
    \item A partial order $\ltdyn_A$.
    \item A reflexive, symmetric ``bisimilarity'' relation $\bisim_A$.
\end{itemize}
A \textbf{morphism of predomains} $f : A \to A'$ is a function between
the underlying sets that is both \emph{monotone} (if
$x \ltdyn_A x'$, then $f(x) \ltdyn_{A'} f(x')$), and
\emph{extensional} (if $x \bisim_A x'$, then $f(x) \bisim_{A'} f(x')$).
\end{definition}

We will generally write $A$ for both a predomain and its underlying set; if we
need to emphasize the difference we will write $|A|$ for the underlying set of
$A$.
%
Given a predomain $A$, we can form the predomain $\later A$. The
underlying set is $\later |A|$ and the ordering is given by $\tilde{x}
\ltdyn_{\later A} \tilde{x'}$ iff $\later_t(\tilde{x}_t \ltdyn_A
\tilde{x'}_t)$, and likewise for bisimilarity.

We similarly enhance our error domains with ordering and bisimilarity
relations, but we further need to impose conditions on the algebraic
structure: the error element should be the least element (so that it
models graduality), the think map should be monotone and extensional
and the bisimilarity relation should relate $\delta$ to the identity
(so that it models bisimilarity).
%
\begin{definition}
An \textbf{error domain} $B$ consists of a predomain $B$ along with the following data:
\begin{itemize}
    \item A distinguished ``error'' element $\mho_B \in B$ such that $\mho \ltdyn_B x$ for all $x$
    \item A morphism of predomains $\theta_B \colon \later B \to B$
    \item For all $x : B$ we have $\theta_B(\nxt\, x) \bisim_B x$
\end{itemize}
A \textbf{morphism of error domains} is a morphism of the underlying
predomains that preserves the error element and the $\theta$ map.
\end{definition}
For an error domain $B$, we define the predomain morphism $\delta_B := \theta_B
\circ \nxt$.

A \emph{predomain relation} $c : A \rel A'$ is a relation between $A$ and $A'$
that is upward closed in $A'$ and downward closed in $A$, as defined in the
previous section (no condition is required for bisimilarity). The ``reflexive''
predomain relation is written $r(A)$ and is given by the ordering $\ltdyn_A$.
The relational composition of two predomain relations is also a predomain
relation, and $r(A)$ is the identity for this composition.

Error domain relations are given by predomain relations that are
additionally a congruence with respect to the algebraic structures
$\theta$ and $\mho$.
\begin{definition}
  An \textbf{error domain relation} $d : B \rel B'$ is a monotone relation $d$ on the underlying predomains satisfying
  \begin{enumerate}
     \item ($\mho$ congruence): $\mho_B \binrel{d} \mho_{B'}$.
     \item ($\theta$ congruence): For all $\tilde{x}$ in $\laterhs B$ and
     $\tilde{y} \in \laterhs B'$, if $\laterhs_t (\tilde{x}_t \binrel{d} \tilde{y}_t)$, then 
     $(\theta_B (\tilde{x}) \binrel{d} \theta_{B'} (\tilde{y}))$. 
  \end{enumerate}
\end{definition}
Again we have a reflexive error domain relation $r(B)$ given by the
ordering. The relational composition of two error domain relations in
general is not an error domain relation ($\theta$ congruence in
particular is not preserved), but we instead use an alternative ``free
composition'' $d \odot d'$ that is inductively generated from the
relational composition. Details of this construction are in the
appendix (Definition \ref{def:free-comp-ed-rel}).

We also will use the notion of a square $f \ltsq{c_i}{c_o} g$ between
predomain morphisms as well as squares $\phi \ltsq{d_i}{d_o} \psi$
between error domain morphisms, which are defined similarly, with no
extra interaction with the algebraic structure.

In our denotational model of GTLC, we map every type $A$ to a
predomain $\sem{A}$. These constructions are given by the same
constructions as in Section~\ref{sec:concrete-term-model}, but now enriched to
act also on orderings and bisimilarity. For products this is the
obvious lifting, and for functions we use the CBPV decomposition $U(A
\to \li A')$ where the only one that is not clear is $\li A'$.
\begin{definition}
  The free error domain $\li A$ has as the underlying set the free
  simple error domain with ordering given by the lock-step error
  ordering and bisimilarity by weak bisimilarity both generated by the
  ordering/bisimilarity on $A$. This is free in the same sense as the
  free simple error domain that it is left adjoint to $U$.
\end{definition}

%% \subsubsection{Functors}\label{sec:free-error-domain}

%% The functors $U$, $\li$, $\times$, and $\arr$ introduced in the previous section
%% act on predomains and error domains and also have actions on their morphisms,
%% relations, and squares. The functor $U$ simply takes the underlying predomain
%% relation of an error domain relation. Given a relation $c_1 : A_1 \rel A_1'$ and
%% $c_2 : A_2 \rel A_2'$, the relation $c_1 \times c_2 : (A_1 \times A_2) \rel
%% (A_1' \times A_2')$ is defined by $((x, y), (x', y')) \in (c_1 \times c_2)$ if
%% and only if $(x, x') \in c_1$ and $(y, y') \in c_2$. Given a relation $c : A
%% \rel A'$ and an error domain relation $d : B \rel B'$, the relation $c \arr d :
%% (A \arr B) \rel (A' \arr B')$ is the error domain relation defined by $(f, g)
%% \in (c \arr d)$ if and only if for all $x : A$ and $x' : A'$ with $(x , x') \in
%% c$ we have $(f(x), g(x')) \in Ud$. The fact that this relation respects error %\max{preserves error?}
%% and preserves $\theta$ follows from the corresponding properties for $d$.

%% % Free error domain
%% The functor $\li$ takes a predomain $A$ to the free error domain on
%% $A$. We first define the predomain $U\li A$. The underlying set of
%% $U\li A$ is defined to be $\li |A|$ (the guarded lift monad applied to
%% $|A|$). The ordering relation is the lock-step error ordering
%% introduced in the previous section , and the bisimilarity relation is
%% the weak bisimilarity relation on $\li |A|$ also defined in the
%% previous section. With these relations, the constructors $\eta$ and
%% $\theta$ of the guarded lift monad are in fact morphisms of
%% predomains, i.e., they are monotone and preserve bisimilarity.
%% %
%% We observe that this predomain structure extends to an error domain structure by
%% noting that the required error element is given by the constructor $\mho$ and
%% the required $\theta$ map is the constructor $\theta$. Lastly, it can be shown
%% that the delay morphism $\delta = \theta \circ \nxt : UB \to UB$ satisfies $x \bisim
%% \delta\, x$ for all $x$ as is required by the definition of error domain.

% The monadic bind operation $-^\dagger$ takes a predomain morphism $f : A \to UB$
% to an error domain morphism $\li A \multimap B$; with this we define the action of $\li$ on
% morphisms: Given $f : A \to A'$ we define $\li f = (\eta \circ f)^\dagger : \li A \to \li A'$.
%\max{what is the point of this sentence?}

Additionally, all of these core constructions $\times, \to, U, \li$
act on heterogeneous relations as well in an analogous way.

The most interesting type to interpret is the dynamic
type. The beauty of guarded domain theory is that once we have define
$\laterhs$ for predomains, we can solve the same domain equation as in
Section~\ref{sec:concrete-term-model} changed only in that we interpret it as a
domain equation on predomains rather than sets:
%
\[ D \cong \mathbb{N}\, + (D \times D)\, + \laterhs U(D \arr \li D) \]
The complete definition of the ordering $\ltdyn_D$ is provided in the appendix
for completeness.

To interpret term precision, we define three relations involving $D$
as follows. We define $\inat : \mathbb{N} \rel D$ by $(n, d) \in
\inat$ iff $e_\nat(n) \ltdyn_D d$. We similarly define $\itimes : D
\times D \rel D$ by $((d_1, d_2), d) \in \itimes$ iff $e_\times(d_1,
d_2) \ltdyn_D d$, and we define $\text{inj}_\to : U(D \arr \li D) \rel
D$ by $(f, d) \in \iarr$ iff $e_\to(f) \ltdyn_D d$.

\subsection{Phase Two: Perturbations and Quasi-Representable Relations}

We now introduce the additional definitions needed to complete the construction
of our model. Recall from Section \ref{sec:lock-step-and-weak-bisim} that in order
to establish the DnL rule for the downcast of $\iarr$, we needed to adjust the
rule by inserting a ``delay'' on the right-hand side. A similar adjustment is
needed for the DnR rule for $\iarr$. Moreover, the need to insert delays impacts
the semantics of the cast rules for \emph{all} relations, because of the
functorial nature of casts. That is, the upcast at a function type $c_i \ra c_o$
involves a downcast in the domain and an upcast in the codomain. This has two
consequences: first, the squares corresponding to the rules UpL and UpR may also
require the insertion of a delay. Second, we need to be able to insert
``higher-order'' delays in a way that follows the structures of the casts.

To accomplish this, we equip the predomains $A$ in our semantics with
a monoid $M_A$ of \emph{syntactic perturbations}, as well as a means
of \emph{interpreting} these syntactic perturbations as
\emph{semantic} perturbations on $A$, i.e., as endomorphisms that are
bisimilar to the identity. We call such an object a \emph{value
object}, and this will serve as the final definition of a denotation of
a type in our semantics. Similarly, we define computation objects to be
error domains equipped with a notion of syntactic perturbation:
\begin{definition}[value and computation objects + morphisms]
  A \textbf{value object} consists of a predomain $A$, a monoid $M_A$ and a
  homomorphism of monoids $i_A \colon M_A \to \morbisimid{A} := \{ f : A \to A \mid f
  \bisim \id_A \}$.

  Likewise, a \textbf{computation object} consists of an error domain $B$, a
  monoid $M_B$ and a homomorphism of monoids $i_B \colon M_B \to \morbisimid{B}$.

  We define a \textbf{value morphism} to be simply a morphism of the underlying
  predomains, and a \textbf{computation morphism} to be a morphism of the
  underlying error domains.
\end{definition}

\begin{remark}
  The reason the set of perturbations needs to carry a monoid structure is that
  we will need to produce a syntactic perturbation corresponding to the identity
  relations $r(A)$, as well as one for the composition of relations. The monoid
  structure gives us what we need to produce these elements. Likewise, the
  reason that the interpretations as semantic perturbations must be
  \emph{homomorphisms} of monoids is that we need a syntactic perturbation that
  is interpreted as the identity semantic perturbation, and likewise given two
  syntactic perturbations $\delta_1$ and $\delta_2$ we need a syntactic
  pertubration $\delta_{1,2}$ that is interpreted as the composition of the
  semantic perturbations $i_A(\delta_1)$ and $i_A(\delta_2)$.
\end{remark}

\begin{remark}
  It might seem strange that in defining the morphisms of value and computation
  objects, there is no requirement involving the monoids. For example, one could
  imagine defining a morphism between value objects $(A, M_A, i_A)$ and $(A',
  M_{A'}, i_{A'})$ to be a predomain morphism $f \colon A \to A'$ along with a
  monoid homomorphism $h \colon M_A \to M_{A'}$ such that $f$ and $h$ satisfied
  a compatibility condition with respect to the interpretations $i_A$ and
  $i_{A'}$. However, with this definition of morphism, the category of value
  types is no longer Cartesian closed and is not a model of call-by-push-value.
  This is unfortunate, as it would simplify some aspects of the model construction.
\end{remark} 

% every error domain $B$ with a monoid $M_B$ and interpretation homomorphism $i_B
% : M_B \to \morbisimid{B}$. This grouping of data deserves its own definition: We
% call the triple $(A, M_A, iA)$ a \textbf{value object} as it will be the
% denotation of value types in our final model. Likewise, the triple $(B, M_B,
% i_B)$ will be called a \textbf{computation object}.\max{make this a proper \textit{Definition} and define morphisms as well}

Having defined syntactic perturbations and value and computation objects, we can
now make formal the final aspect of the model: the notion of
quasi-represntability of relations.
%
\begin{definition}[quasi-left-representable relations]\label{def:quasi-left-representable}
Let $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$ be value objects, and let $c : A
\rel A'$ be a predomain relation. We say that $c$ is
\emph{quasi-left-representable} by a predomain morphism $e : A \to A'$ if there
are perturbations $\delle_c \in M_A$ and $\delre_c \in M_{A'}$ such that the
following two squares exist: (1) $\upl$: $e \ltsq{c}{\ltdyn_{A'}} i_{A'}(\delre_c)$, and
(2) $\upr$: $i_A(\delle_c) \ltsq{\ltdyn_{A}}{c} e$.
\end{definition}
%
Observe that this weakens the previous notion of representability, since under
that definition the perturbations were required to be the identity.
%
We make the analogous definition of quasi-left-representability for error domain
relations $d$.

Likewise, we define quasi-right-representability as follows:
%
\begin{definition}[quasi-right-represntable relations]\label{def:quasi-right-representable}
Let $(B, M_B, i_B)$ and $(B', M_{B'}, i_{B'})$ be computation objects, and let
$d : B \rel B'$ be an error domain relation. We say that $d$ is
\emph{quasi-right-representable} by an error domain morphism $p : B' \multimap B$ if
there are perturbations $\dellp_d \in M_B$ and $\delrp_d \in M_{B'}$ such that
the following two squares exist: 
(1) $\dnl$: $p \ltsq{\ltdyn_{B'}}{d} i_{B'}(\delrp_d)$ and
(2) $\dnr$: $i_B(\dellp_d) \ltsq{d}{\ltdyn_{B}} p$.
Quasi-right-representability for predomain relations is defined similarly.
\end{definition}

For ordinary representability, the relation is \emph{uniqueley
determined} by any morphism that left- or right-represents it: if two
relations are left-represented by the same morphism, then they are
equal. But for quasi-representability, this is no longer the case due
to the presence of perturbations. Instead we have the following weaker property:
\begin{definition}[quasi-equivalence]\label{def:quasi-equivalent}
  Let $A$ and $A'$ be value objects, and let $c, c' : A \rel A'$ be relations
  between the underlying predomains. We say that $c$ and $c'$ are
  \textbf{quasi-equivalent}, written $c \qordeq c'$, if there exist
  syntactic perturbations $\delta^l_1, \delta^l_2 \in M_A$ and $\delta^r_1,
  \delta^r_2 \in M_{A'}$ such that there is a square $i_A(\delta^l_1)
  \ltsq{c}{c'} i_{A'}(\delta^r_1)$ and a square $i_A(\delta^l_2) \ltsq{c'}{c}
  i_{A'}(\delta^r_2)$. Given computation objects $B$ and $B$, we make the
  analogous definition for relations $d, d' : B \rel B'$ between the underlying
  error domains.
\end{definition}

% \max{idea: move this after the quasi-representability part and say that this structure is what's needed to make them compose}
Given two quasi-representable relations $c$ and $c'$, it is not the case in
general that $cc'$ is quasi-representable. We need an additional condition that
specifies how relations interact with perturbations. In particular, we need to
be able to ``push'' and ``pull'' perturbations along relations $c$ and $d$.
%
The intuition for this requirement comes from the construction of the square
corresponding to the original UpL rule from the square for the simplified
version as was shown in Section \ref{sec:towards-relational-model}. Recall that
we horizontally composed the simplified UpL square for $c$ with the identity
square for $c'$ on the right. Now that the square for UpL involves a
perturbation on the right instead of the identity, this construction will not
work unless we can ``push'' the perturbation on $A_2$ to one on $A_3$. That is,
given a relation $c : A \rel A'$ and a syntactic perturbation $m_A \in M_A$, we
need to be able to turn it into a syntactic perturbation $m_{A'} \in M_{A'}$
such that the resulting semantic perturbations obtained by applying the
respective homomorphisms $i_A$ and $i_{A'}$ form a square. Dually, we will need
to ``pull'' a perturbation from right to left. This notion is made formal by the
following definition:
%
\begin{definition}
    Let $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$ be value objects,
    and let $c : A \rel A'$ be a predomain relation. A
    \textbf{push-pull structure} for $c$ (with respect to $M_A$ and
    $M_{A'}$) consists of monoid homomorphisms $\push : M_A \to M_A'$
    and $\pull : M_A' \to M_A$ such that for all $m_A \in M_A$ there
    is a square $i_A(m_A) \ltsq{c}{c} i_{A'}(\push\, m_A)$ and for all
    $m_{A'} \in M_{A'}$ there is a square $i_A(\pull\, m_{A'})
    \ltsq{c}{c} i_{A'}(m_{A'})$. A push-pull structure for error
    domain relations is defined similarly.
\end{definition}

We can now give the final definition of value and computation relations for our
model, which serve as the denotation of our type precision derivations:
%
\begin{definition}[value relations]
A \textbf{value relation} between value objects $(A, M_A, i_A)$ and $(A',
M_{A'}, i_{A'})$ consists of a predomain relation $c : A \rel A'$ that has a
push-pull structure, is quasi-left-representable by a morphism $e_c : A \to A'$,
and is such that $\li c$ is quasi-right-representable by an error domain morphism
$p_c : \li A' \to \li A$.

A \textbf{computation relation} between computation objects $(B, M_B, i_B)$ and
$(B', M_{B'}, i_{B'})$ consists of an error domain relation $d$ that has a
push-pull structure, is quasi-right-representable by a morphism $p_d : B' \to
B$, and is such that $Ud$ is quasi-left-representable by a morphism $e_d : UB
\to UB'$
\end{definition}

It is essential in the definition of a value relation that we have not
just that $c$ is quasi-left-representable but also that $\li c$ is
quasi-right-representable so that we can define the action of the
functor $\li$ on relations, taking a value relation to a computation
relation. Likewise, we require $Ud$ to be quasi-left-representable in
the definition of computation relations so that we can define the
action of $U$ on relations.

% Because we have augmented the definitions of object and relation for our model,
% we need to specify the actions of the functors $F$, $U$, $\times$, and $\arr$ on
% these objects and relations. 
% For instance, the functor $F$ now acts on \emph{value objects} $(A, M_A, i_A)$,
% which means we need to specify the monoid $M_{FA}$ and interpretation $i_{FA}$
% corresponding to the error domain $FA$.

To model the term precision in a way that is oblivious to the stepping
behavior of terms, we need to weaken the notion of square to allow for the
morphisms on either side to be ``out of sync'' rather than in lock step.
In the below, $f' \bisimsq{A_i}{A_o} f$ is the natural extension of
bisimilarity to morphisms: given bisimilar inputs, the functions have
bisimilar outputs.
\begin{definition}
  Let $c_i : A_i \rel A_i'$, $c_o : A_o \rel A_o'$ $f : A_i \to A_o$
  and $g : A_i' \to A_o'$.  An extensional square $f
  \ltsqbisim{c_i}{c_o} g$ holds if there \emph{exist} $f'
  \bisimsq{A_i}{A_o} f$ and $g' \bisimsq{A_i'}{A_o'} g$ such that $f' \ltsq{c_i}{c_o} g'$.
\end{definition}

\subsection{Constructing the Denotational Semantics}\label{sec:relational-model-construction}

With these concepts now defined, we can give an overview of our
denotational model:
\begin{itemize}
  \item For every type $A$ we define a value type $\sem{A}$, and define $\sem{x_1:A_1,\ldots} = \sem{A_1}\times\cdots$
  \item For every term $\Gamma \vdash M : A$, we define a value morphism $\sem{M} : \sem{\Gamma} \to U\li\sem{A}$.
  \item If $M = M'$ are equal according to our equational theory, then $\sem{M} = \sem{M'}$
  \item For every type precision derivation $c : A \ltdyn A'$ we
    define a value relation $\sem{c} : \sem{A} \rel \sem{A'}$.
  \item For every type precision equivalence $c \equiv c'$ we have a
    quasi-equivalence of relations $\sem{c} \bisim \sem{c'}$.
  \item For every term precision $\Delta \vdash M \ltdyn M' : c$ we
    have an \emph{extensional} square
    $\sem{M}\ltsqbisim{\sem{\Delta}}{U\li\sem{c}} \sem{M'}$
\end{itemize}

For the term semantics $\sem{M}$, nothing really differs from the term
semantics in Section~\ref{sec:concrete-term-model}. The only difference is
that the definitions of $\sem{\upc c}$ and $\sem{\dnc c}$ can be
defined as the morphisms that left- and right-quasi-represent $\sem
c$, but upon inspection this definition agrees with the one given
before. Similarly, the validity of the equational theory follows
easily: $\beta\eta$ holds in our model. We next elaborate on each of
the remaining components.
% Interpretations of functions are different: one is arbitrary fucntions, the other is monotone functions that preserve bisimilarity
% Interpretation of the projection is different since we add a delay

\subsubsection{Interpreting types}\label{sec:perturbation-constructions}
% \max{this section needs prose}

% \eric{May be able to move some of this to the appendix}
For our value type semantics, we already have an interpretation as predomains;
we describe how we enhance each of the constructions we use ($U,\li,\to,\times,D$)
with a monoid of syntactic perturbation and a means of interpreting them as semantic
perturbations.

First consider the free error domain $\li-$. Given a value object
$(A, M_A, i_A)$ we define the syntactic perturbations $M_{\li A}$ to
be $\mathbb{N} \oplus M_A$, where $\oplus$ denotes the free product of
monoids (the coproduct in the category of monoids). The intuition
behind needing to include $\mathbb{N}$ comes from the example of the
downcast for $\iarr$. Recall that we adjusted the squares
corresponding to the DnL and DnR rules by adding $(\delta \circ
\eta)^\dagger$ on the side opposite the downcast. Thus, we need a
syntactic perturbation in $M_{\li A}$ that will be interpreted as
$(\delta \circ \eta)^\dagger$. We accomplish this by taking the
coproduct with $\mathbb{N}$.
%
The interpretation of the perturbations as endomorphisms is defined using the
universal property of the coproduct of monoids. Specifically, to define the
homomorphism $i_{\li A}$, by the universal property of the coproduct of monoids
it suffices to define two homomorphisms, one from $\mathbb{N} \to
\morbisimid{\li A}$ and one from $M_A \to \morbisimid{\li A}$. The first
homomorphism sends the generator $1 \in \mathbb{N}$ to the error domain
endomorpism $(\delta \circ \eta)^\dagger$, and the second sends $m_A \in M_A$ to
$\li(i_A(m_A))$. We observe in both cases that the resulting endomorphisms are
bisimilar to the identity, since in the first case, $-^\dagger$ preserves
bisimilarity, and in the second case, the action of $\li$ on morphisms preserves
bisimilarity.

Now we define the action of $U$ on objects. Given a computation object $(B, M_B,
i_B)$, we define $M_{UB}$ to be $\mathbb{N} \oplus M_B$. The reason for
requiring $\mathbb{N}$ is related to the Kleisli action of the arrow functor: to
establish quasi-representability of $U(c \arr d)$ given quasi-representability
of $c$ and $d$, we will need to turn a perturbation on $\li A$ into a
perturbation on $U(A \arr B)$. Since the perturbations for $\li A$ involve
$\mathbb{N}$, so must the perturbations for $UB$. The interpretation $i_{UB}$ of
the perturbations on $UB$ works in an analogous manner to that of $\li A$: we send
the generator $1 \in \mathbb{N}$ to the delay morphism $\delta_B \colon UB \to
UB$, and we send a perturbation $m_B \in M_B$ to $U(i_B(m_B))$.

The action of $\times$ on objects is as follows. Given $(A_1, M_{A_1}, i_{A_1})$
and $(A_2, M_{A_2}, i_{A_2})$, we define the monoid $M_{A_1 \times A_2} =
M_{A_1} \oplus M_{A_2}$. The interpretation $i_{A_1 \times A_2}$ is defined
using the universal property of the coproduct of monoids. That is, we define
homomorphisms $M_{A_1} \to \morbisimid{A_1 \times A_2}$ and $M_{A_2} \to
\morbisimid{A_1 \times A_2}$. The former takes $m_1 \in M_{A_1}$ to the morphism
$(i_{A_1}(m_1), \id)$, while the latter takes $m_2 \in M_{A_2}$ to the morphism
$(\id, i_{A_2}(m_2))$.
% Could state this using the functorial action of \times

The action of $\arr$ on objects is as follows. Given $(A, M_A, iA)$ and $(B,
M_B, i_B)$ we define the monoid $M_{A \arr B} = M_A^{op} \oplus M_B$ and the interpretation
is defined analogously to that of $\times$.
% Could state this using the functorial action of \arr

Finally, the most interesting type is of course the dynamic type. 
It may seem as though we need to define the perturbations for $D$ by
guarded recursion, but in fact we define them via least-fixpoint\footnote{
  The reason for defining the perturbations inductively is technical and has to
  do with the fact that we needed to define the perturbations corresponding to the
  predomain $\later A$ to be the perturbations of $A$, \emph{not} later of the
  perturbations of $A$. There may be a way to make this work by changing some
  definitions, but we leave this as future work}
in the category of monoids:
%
\( M_D \cong (M_{D \times D}) \oplus M_{U(D \to \li D)}. \)
%
We now explain how to interpret these perturbations as endomorphisms.
We define $i_D : M_D \to \{ f : D \to D \mid f \bisim \id \}$ by induction as follows:
%
\begin{align*}
  i_D(m_\times) &= \lambda d. \text{case $d$ of }
    \{ \itimes (d_1, d_2) \To \itimes (i_{D \times D}(m_\times)(d_1, d_2)) \alt x \To x \} \\
  i_D(m_\to) &= \lambda d. \text{case $d$ of }
    \{ \iarr (\tilde{f}) \To \iarr (\lambda t. i_{U(D \to \li D)}(m_\to)(\tilde{f}_t)) \alt x \To x \}
\end{align*}
%
In the case of a perturbation on $D \times D$, we use the interpretation for the
perturbations of $D \times D$ as defined earlier in this section, which in turn
will use $i_D$ inductively. Similarly, for a perturbation on $U(D \to \li D)$ we
use the interpretation for perturbations on $U(D \to \li D)$.
One can verify that this defines a homomorphism from $M_D \to \{ f : D \to D : f
\bisim \id \}$.

% \begin{align*}
%  i_D(m_{\text{times}}, m_{\text{fun}}) &= \lambda d.\text{case $d$ of}  \\
%  &\alt \tnat(m) \mapsto \tnat(m) \\
%     &\alt \ttimes(d_1, d_2) \mapsto {\ttimes(i_{D \times D}(p_\text{times})(d_1, d_2))} \\
%     &\alt \tfun(\tilde{f}) \mapsto {\tfun(\lambda t. i_{U(D \to \li D)}(\tilde{f}_t))}
% \end{align*}

\subsubsection{Interpreting type precision}

Next we need to confirm that our interpretation of type precision
derivations as predomain relations indeed extends to value relations,
i.e., that the relations are quasi-representable and that they satisfy
the push-pull property for perturbations. We include most of these technical
verifications in the appendix (Definitions
\ref{def:value-computation-rel-comp} and
\ref{def:functorial-actions-on-relations}).

We go into more detail on the three relations involving the dynamic
type $\inat$, $\itimes$, and $\iarr$. As an illustrative case, we
establish the push-pull property for the relation $\iarr$. We define
$\pull_{\iarr} : M_D \to M_{U(D \arr \li D)}$ by giving a homomorphism
from $M_{D \times D} \to M_{U(D \arr \li D)}$ and from $M_{U(D \to \li
  D)} \to M_{U(D \arr \li D)}$. The former is the trivial homomorphism
sending everything to the identity element, while the latter is the
identity homomorphism.
%
Conversely, we define $\push_{\iarr} : M_{U(D \arr \li D)} \to M_D$ as the
inclusion into the coproduct.
%
Showing that the relevant squares exist involving push and pull is
straightforward.

It is easy to see that the relations $\inat$, $\itimes$, and $\iarr$
are quasi-left-representable, where all perturbations are taken to be the
identity elements of the respective monoids.
%
For quasi-right-representability, the only nontrivial case is $\li(\iarr)$.
Recall the definition of the downcast for $\iarr$ given in Section
\ref{sec:term-interpretation}. We know that in order for the DnR and DnL squares
for $\li \iarr$ to exist, we must insert a delay on the side opposite the
downcast. In terms of syntactic perturbations, this means that we take $\dellp$
and $\delrp$ in the definition of quasi-right-representability to both be
$\inl\, 1$, where $\inl$ is the left injection into the coproduct of monoids. We
recall that the definition of syntactic perturbations for $\li$ involves a
coproduct with $\mathbb{N}$, and that the interpretation homomorphism maps the
generator $1$ to the endomorphism of error domains $(\delta \circ
\eta)^\dagger$.
%
With this choice for the perturbations, it is straightforward to show that the
DnL and DnR squares exist using the definition of the downcast and the
definition of the relation $\iarr$.

Lastly, the interpretation of the type precision equivalence rules $c \equiv c'$
as quasi-equivalence of the denoted relations $\sem{c} \bisim \sem{c'}$ is
justified by Lemma \ref{lem:quasi-order-equiv-functors} in the Appendix.

\subsubsection{Interpreting Term Precision: Extensional Squares}

Finally, we establish the core result of the semantics: interpreting
term precision as extensional squares. Fortunately, the hard work is
now complete, and the term precision rules follow from our
compositional constructions.
%
In particular, the congruence rules of term precision are modeled easily: congruence
squares exist both for bisimilarity and for the error ordering, and so
we also have these for extensional squares.
%
The rule involving error holds because $\mho$ is the least element in the
ordering on the free error domain. 
%
Next, the rule involving type-precision equivalence follows because $c \equiv c'$
implies quasi-equivalence of the denoted relations, and this in turn implies that
$\id \ltsqbisim{\sem{c}}{\sem{c'}} \id$.
%
Thus, it remains to verify the existence of the squares for the cast rules. For UpL, the
relevant extensional square is obtained as follows:
%
% https://q.uiver.app/#q=WzAsNixbMCwwLCJBXzEiXSxbMSwwLCJBXzIiXSxbMiwwLCJBXzMiXSxbMCwxLCJBXzIiXSxbMSwxLCJBXzIiXSxbMiwxLCJBXzMiXSxbMCwzLCJlX2MiLDIseyJjdXJ2ZSI6MX1dLFsxLDQsIlxcZGVscmVfYyIsMl0sWzIsNSwiXFxwdXNoX3tjJ30oXFxkZWxyZV9jKSIsMix7ImN1cnZlIjoxfV0sWzAsMSwiYyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsMiwiYyciLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFszLDQsInIoQV8yKSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzQsNSwiYyciLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsyLDUsIlxcaWQiLDAseyJjdXJ2ZSI6LTF9XSxbMCwzLCJlX2MiLDAseyJjdXJ2ZSI6LTF9XSxbOCwxMywiXFxiaXNpbSIsMSx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs2LDE0LCJcXGJpc2ltIiwxLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
\[\begin{tikzcd}[ampersand replacement=\&,column sep=large]
	{A_1} \& {A_2} \& {A_3} \\
	{A_2} \& {A_2} \& {A_3}
	\arrow["c", "\shortmid"{marking}, no head, from=1-1, to=1-2]
	\arrow[""{name=0, anchor=center, inner sep=0}, "{e_c}"', curve={height=6pt}, from=1-1, to=2-1]
	\arrow[""{name=1, anchor=center, inner sep=0}, "{e_c}", curve={height=-6pt}, from=1-1, to=2-1]
	\arrow["{c'}", "\shortmid"{marking}, no head, from=1-2, to=1-3]
	\arrow["{\delre_c}"', from=1-2, to=2-2]
	\arrow[""{name=2, anchor=center, inner sep=0}, "{\push_{c'}(\delre_c)}"', curve={height=6pt}, from=1-3, to=2-3]
	\arrow[""{name=3, anchor=center, inner sep=0}, "\id", curve={height=-6pt}, from=1-3, to=2-3]
	\arrow["{r(A_2)}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
	\arrow["{c'}"', "\shortmid"{marking}, no head, from=2-2, to=2-3]
	\arrow["\bisim"{description}, draw=none, from=0, to=1]
	\arrow["\bisim"{description}, draw=none, from=2, to=3]
\end{tikzcd}\]
%
% Note that the horizontal composition of the squares is defined, as they are
% intensional squares.
We have used the push-pull structure on $c'$ to turn the perturbation on $A_2$
into a perturbation on $A_3$. Lastly we note that the bottom edge of the square
is equal to $c'$ by the fact that $c'$ is downward closed. The squares for UpR,
DnL, and DnR are obtained analogously.

% Now that we have defined an intensional model with an interpretation for the
% dynamic type, we can apply the abstract constructions introduced in Section
% \ref{sec:extensional-model-construction}. Doing so, we obtain an extensional
% model of gradual typing, where the squares are given by the ``bisimilarity
% closure'' of the intensional error ordering.

\subsection{Relational Adequacy}\label{sec:adequacy}

Now that we have established our denotational model, we can, as in
Section~\ref{sec:big-step-term-semantics}, extract a big step semantics. Our final
goal then is to prove that the extensional squares in our model imply
the graduality property for this final big step semantics.
\begin{comment}
First we establish some notation. Fix a morphism $f : 1 \to \li \mathbb{N} \cong
\li \mathbb{N}$. We write $f \da n$ to mean that there exists $m$ such that $f =
\delta^m(\eta n)$ and $f \da \mho$ to mean that there exists $m$ such that $f =
\delta^m(\mho)$.

Recall that $\ltbisim$ denotes the relation on value morphisms defined as the
closure of the intensional error-ordering on morphisms under weak bisimilarity
on bboth sides. Specialized to the setting of morphisms from $1 \to U \li
\mathbb{N}$, we have $f \ltbisim g$ iff there exist $f'$ and $g'$ with
%
\[ f \bisim_{\li \mathbb{N}} f' \le_{\li \mathbb{N}} g' \bisim_{\li \mathbb{N}} g. \]\max{$\le$? I thought it was $\ltdyn$}
%
We first note that in this ordering, the semantics of error is not equivalent to
the semantics of the diverging term. The main result we would like to show is as
follows: If $f \ltbisim g : \li \mathbb{N}$, then:
\begin{itemize}
  \item If $f \da n$ then $g \da n$.
  \item If $g \da \mho$ then $f \da \mho$.
  \item If $g \da n$ then $f \da n$ or $f \da \mho$.
\end{itemize}
%
However, this is actually not provable! Intuitively, the issue is
that to prove this result we need to the above result is a ``global''\max{what does ``global'' mean?} result, and it is not possible to prove such results
in the guarded setting\max{isn't everything we do in a ``guarded setting''?}. In particular, if we tried to prove the above result in
the guarded setting we would run into a problem where we would have a natural
number ``stuck'' under a $\later$, with no way to get out the underlying number.
%
Thus, to prove our adequacy result, we need to leave the guarded
setting\max{``pass to leave the guarded setting''?}. We have seen in Section \ref{sec:big-step-term-semantics} that clock
quantification makes this possible.
\end{comment}
The result we seek to show is the following:
% If $f \bisim^{gl} f' \ltls^{gl} g' \bisim^{gl} g$, then
\begin{theorem}[adequacy]
  If $\cdot \vdash M \ltdyn N : \nat$, then:
  \begin{itemize}
    \item If $M \Downarrow n$ then $N \Downarrow n$.
    \item If $N \Downarrow \mho$ then $M \Downarrow \mho$.
    \item If $N \Downarrow n$ then $M \Downarrow n$ or $M \Downarrow \mho$.
  \end{itemize}
\end{theorem}
%
% Recall as discussed in that section that the definitions of our model are all
% parameterized by a clock $k$. 
%
It therefore remains to show that the denotation of term precision in our model
$f \ltsqbisim{}{} g$, where $f, g : \li \mathbb{N}$, implies a relationship
between the partial elements $\mathbb{N} + {\mho}$ corresponding to $f$ and $g$. Recall
that to define the big-step semantics we used the equivalence of the
globalization of the free error domain and Capretta's coinductive delay monad:
$\li^{gl} \mathbb{N} \cong \delay(\mathbb{N} + {\mho})$. We now extend this
correspondence to a relationship between a global version of our denotation of
term precision and the corresponding relation on the delay monad.

% We saw in Section \ref{sec:big-step-term-semantics} that there is an isomorphism
% between the globalization of the free error domain and Capretta's coinductive
% delay monad: $\li^{gl} \mathbb{N} \cong \delay(\mathbb{N} + {\mho})$. We now
% seek to extend this to a relatinoship between a global version of our semantic
% notion of term precision and the corresponding relation for the delay monad.

To that end, we define a version of our denotation of term precision
that relates terms of type $\li^{gl} \mathbb{N}$. More concretely, consider the
predomain $\mathbb{N}$ with ordering and bisimilarity both the equality
relation. We define a global version of the lock-step error ordering and the
weak bisimilarity relation on elements of $\li^{gl} \mathbb{N}$; the former is
defined by
%
\( x \ltls^{gl} y := \forall k. x[k] \ltls y[k], \)
%
and the latter is defined by
%
\( x \bisim^{gl} y := \forall k. x[k] \bisim y[k]. \)
%

Correspondingly, we define a version of the lock-step error ordering and weak
bisimilarity relation on $\delay(\mathbb{N} + {\mho})$ 
(see Section \ref{sec:relations-on-delay-monad} in the appendix for the definitions).
% \max{do these intermediate details matter for the main body of the paper?}
%
%
By adapting Theorem 4.3 of \cite{kristensen-mogelberg-vezzosi2022} to the
setting of inductively-defined relations, we can show that both the global
lock-step error ordering and the global weak bisimilarity admit coinductive
definitions. In particular, modulo the above isomorphism between $\li^{gl} X$
and $\delay(\mathbb{N} + {\mho})$, the global version of the lock-step error
ordering is equivalent to the lock-step error ordering on $\delay(\mathbb{N} +
{\mho})$, and the global version of weak bisimilarity is equivalent to weak
bisimilarity on $\delay(\mathbb{N} + {\mho})$.
%
This implies that the global denotation of the term precision semantics for
$\li^{gl} \mathbb{N}$ agrees with the corresponding relation $\ltsqbisim{}{}^\text{Delay}$ for $\delay(\mathbb{N} + {\mho})$, i.e.,
the closure of its lock-step ordering under weak bisimilarity on both sides.
%
Then to obtain the desired result, it suffices to show being related in
$\ltsqbisim{}{}^\text{Delay}$ implies that the corresponding partial elements of
$\mathbb{N} + {\mho}$ are related in the expected manner. That is, if $d
\ltsqbisim{}{}^\text{Delay} d'$, then $p(d) \ltdyn^{Partial} p(d')$ where $p$ is
a partial function from delays into $\mathbb{N} + {\mho}$ defined by existential
quantification over the number of steps $i$ in which $d$ terminates, and the
relation $\ltdyn^\text{Partial}$ is defined such that $\mho$ is the least
element, $\bot \ltdyn^\text{Partial} \bot$, and $n \ltdyn^\text{Partial} n$.
This implication follows from the definition of $\ltsqbisim{}{}^\text{Delay}$.

% Then our result follows by proving the corresponding result for
% $\delay(\mathbb{N} + {\mho})$ which in turn follows from the definitions of the
% relations.

% \max{this doesn't actually relate to our notion of big step semantics}

% We have been writing the type as $\li X$, but it is perhaps more accurate to write it as $\li^k X$ to
% emphasize that the construction is parameterized by a clock $k$.

% Need : nat is clock irrelevant, as well as the inputs and outputs of effects
% Axioms about forcing clock
% Adapt prior argument to get that the defining of the global bisim
% and global lock-step error ordering are coinductive
