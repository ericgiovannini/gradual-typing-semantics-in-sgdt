\section{Constructing a Concrete Model}\label{sec:concrete-model}

In this section, we complete the construction of a relational model of gradual
typing. To manage the complexity, we carry out the construction in phases,
beginning with a relational model consisting of partially-ordered sets with a
notion of bisimilarity and then adding requirements for a structured set of
delays on each type as well as a notion of representability for relations that
models the cast rules in the intensional setting.

\subsection{Phase One: Predomains and Error Domains}

In the previous section, we introduced the notion of weak bisimilarity as a
relation on the guarded lift monad. Recall that weak bisimilarity on $\li A$ is
parameterized by a relation on $A$. Thus, in order to define a compositional
model for all types, we need to equip the objects (i.e. the posets and error
domains) with a reflexive, symmetric bisimilarity relation. This leads to our
first new definition: 

\begin{definition}
A \textbf{predomain} $A$ consists of a set $A$ along with two relations:
\begin{itemize}
    \item A partial order $\le_A$.
    \item A reflexive, symmetric ``bisimilarity'' relation $\bisim_A$.
\end{itemize}
\end{definition}

We will generally write $A$ for both a predomain and its underlying set; if we
need to emphasize the difference we will write $|A|$ for the underlying set of
$A$.

Given a predomain $A$, we can form the predomain $\later A$. The underlying set
is $\later |A|$ and the relation is defined in the obvious way, i.e., $\tilde{x}
\le_{\later A} \tilde{x'}$ iff $\later_t(\tilde{x}_t \le_A \tilde{x'}_t)$.
Likewise for bisimilarity.
%
We also give a predomain structure to the natural numbers $\mathbb{N}$, where
both the ordering and the bisimilarity relation are equality.
%
Morphisms of predomains are functions between the underlying sets that preserve
the ordering and the bisimilarity relation. More formally:
%
\begin{definition}
Let $A$ and $A'$ be predomains. A \textbf{morphism of predomains} $f : A \to A'$
is a function between the underlying sets such that for all $x, x'$, if $x \le_A
x'$, then $f(x) \le f(x')$, and if $x \bisim_A x'$, then $f(x) \bisim_{A'}
f(x')$.
\end{definition}

We also equip error domains with a bisimilarity relation, and we impose a
condition relating the $\theta$ morphism to the bisimilarity relation. More
concretely:
%
\begin{definition}
An \textbf{error domain} $B$ consists of a predomain $B$ along with the following data:
\begin{itemize}
    \item A distinguished ``error'' element $\mho_B \in B$
    \item A morphism of predomains $\theta_B \colon \later B \to B$
    \item For all $x : B$ we have $\theta_B(\nxt\, x) \bisim_B x$
\end{itemize}
\end{definition}
%
For an error domain $B$, we define the predomain morphism $\delta_B := \theta_B
\circ \nxt$.
%
A \textbf{morphism of error domains} is simply a morphism of the underlying
predomains that preserves the error element and the $\theta$ map.

%
The definition of relations between predomains is the same as that between
posets introduced in the previous section, as the bisimilarity relations of the
predomains are not involved in the definition of monotone relation.

Next we define a notion of \emph{error domain relation} between error domains $B$ and
$B'$. An error domain relation $d : B \rel B'$ is a relation on the underlying
posets that preserves error and respects $\theta$. More formally:
%
\begin{definition}
  Let $B$ and $B'$ be error domains. An \textbf{error domain relation} between
  $B$ and $B'$ is a monotone relation $d$ on the underlying partially-ordered sets such that:
  \begin{enumerate}
     \item (Respects error): For all $y \in B'$, we have $(\mho_B, y) \in d$.
     \item (Preserves $\theta$): For all $\tilde{x}$ in $\laterhs B$ and
     $\tilde{y} \in \laterhs B'$, if $\laterhs_t ((\tilde{x}_t, \tilde{y}_t) \in
     d)$, then $(\theta_B (\tilde{x}), \theta_{B'} (\tilde{y})) \in d$. 
  \end{enumerate}
\end{definition}
% Likewise, the definition of error domain relations is unchanged.

The definitions of squares for predomains are also unchanged from the previous
section, except that the morphisms on the left and right, are now morphisms of
predomains. We likewise define a notion of \textbf{error domain square}: Let
$d_i : B_i \rel B_i'$ and $d_o : B_o \rel B_o'$ be error domain relations, and
let $\phi : B_i \multimap B_o$ and $\phi' : B_i' \multimap B_o'$ be morphisms of
error domains. We say that there is an error domain square $\phi \ltsq{d_i}{d_o}
\phi'$ exactly when there is a predomain square involving the underlying
predomain morphisms and relations.

\begin{comment}
We define a (monotone) relation on predomains $A$ and $A'$ to be a relation on
the underlying sets that is downward-closed under $\le_A$ and upward-closed
under $\le_{A'}$. More formally:
%
\begin{definition}
Let $A$ and $A'$ be predomains. A \emph{predomain relation} between $A$ and $A'$
is a relation $R$ between the underlying sets such that:
\begin{enumerate}
    \item (Downward closure): For all $x_1, x_2 \in A$ and $y \in A'$,
    if $x_1 \le_A x_2$ and $x_2 \mathbin{R} y$, then $x_1 \mathbin{R} y$.
    \item (Upward closure): For all $x \in A$ and $y_1, y_2 \in A'$,
    if $x \mathbin{R} y_1$ and $y_1 \le_{A'} y_2$, then $x \mathbin{R} y_2$.
\end{enumerate}
\end{definition}
%
Composition of relations on predomains is the usual relational composition
(which is truncated to be propositional). Similarly, we define a (monotone)
relation on error domains to be a relation on the underlying predomains that
respects error and preserves $\theta$:
%
\begin{definition}
    Let $B$ and $B'$ be error domains. An \emph{error domain relation} between
    $B$ and $B'$ is a relation $R$ between the underlying predomains such that
    \begin{enumerate}
       \item (Respects error): For all $y \in B'$, we have $\mho_B \mathbin{R} y$.
       \item (Preserves $\theta$): For all $\tilde{x}$ in $\later B$ and $\tilde{y} \in \later B'$,
       if $\later_t( \tilde{x}_t \mathbin{R} \tilde{y}_t )$ then
       $\theta_B(\tilde{x}) \mathbin{R} \theta_{B'}(\tilde{y})$.
    \end{enumerate}
\end{definition}
%
Because of a technical restriction involving the interaction between
propositional truncation and the later modality, we cannot define the
composition of error domain relations as simply the composition of their
underlying predomain relations. Instead, we define composition of error domain
relations $d$ on $B_1$ and $B_2$ and $d'$ on $B_2$ and $B_3$ to be the least
relation containing $d$ and $d'$ that is downward closed under $\le_{B_1}$,
upward-closed under $\le_{B_3}$, respects error, and preserves $\theta$.
Specifically, it is defined inductively by the following rules:
%
\begin{mathpar}
    \inferrule*[right = Comp]
    {b_1 \mathbin{d} b_2 \and b_2 \mathbin{d'} b_3}
    {b_1 \mathbin{d \relcomp d'} b_3}

    \inferrule*[right = DnClosed]
    {b_1' \le_{B_1} b_1 \and b_1 \mathbin{d \relcomp d'} b_3}
    {b_1' \mathbin{d \relcomp d'} b_3}

    \inferrule*[right = UpClosed]
    {b_1 \mathbin{d \relcomp d'} b_3 \and b_3 \le_{B_3} b_3'}
    {b_1 \mathbin{d \relcomp d'} b_3'}

    \inferrule*[right = PresErr]
    { }
    {\mho_{B_1} \mathbin{d \relcomp d'} b_3}

    \inferrule*[right = PresTheta]
    {\later_t( \tilde{b_1} \mathbin{d \relcomp d'} \tilde{b_3} ) }
    {\theta_{B_1}(\tilde{b_1}) \mathbin{d \relcomp d'} \theta_{B_3}(\tilde{b_3}) }
\end{mathpar}
%
% We note that this composition has the following universal property.
%



We now describe the squares. Suppose we are given predomains $A_i, A_o, A_i'$,
and $A_o'$, relations $c_i : A_i \rel A_i'$ and $c_o : A_o \rel A_o'$, and
morphisms $f : A_i \to A_o, f' : A_i' \to A_o'$ Given a square with these
morphisms and relations, we say that the square commutes, written $f \le f'$, if
for all $x \in A_i$ and $x' \in A_i'$ with $(x, x') \in c_i$, we have $(f(x),
f'(x')) \in c_o$. We make the analogous definition for error domains.

\end{comment}

\subsubsection{Functors}\label{sec:free-error-domain}

The functors $U$, $\li$, $\times$, and $\arr$ introduced in the previous section
extend to predomains, error domains, and their relations. The functor $U$ simply
takes the underlying poset relation of an error domain relation. Given a
relation $c_1 : A_1 \rel A_1'$ and $c_2 : A_2 \rel A_2'$, the relation $c_1
\times c_2 : (A_1 \times A_2) \rel (A_1' \times A_2')$ is defined by $((x, y),
(x', y')) \in (c_1 \times c_2)$ if and only if $(x, x') \in c_1$ and $(y, y')
\in c_2$. Given a relation $c : A \rel A'$ and an error domain relation $d : B
\rel B'$, the relation $c \arr d : (A \arr B) \rel (A' \arr B')$ is the error
domain relation defined by $(f, g) \in (c \arr d)$ if and only if for all $x :
A$ and $x' : A'$ with $(x , x') \in c$ we have $(f(x), g(x')) \in Ud$. The fact
that this relation preserves error and respects $\theta$ follows from the
corresponding properties for $d$.

% Free error domain
The functor $\li$ takes a predomain $A$ to the free error domain on $A$. We first
define the predomain $U\li A$. The underlying set of $U\li A$ is defined to be $\li
|A|$ (the guarded lift monad applied to $|A|$). The ordering relation is the
lock-step error ordering introduced in the previous section (taking $A = A'$ in
the definition), and the bisimilarity relation is the weak bisimilarity relation
on $\li |A|$ also defined in the previous section. With these relations, the
constructors $\eta$ and $\theta$ of the guarded lift monad are in fact morphisms
of predomains, i.e., they are monotone and preserve bisimilarity.

We observe that this predomain structure extends to an error domain structure by
noting that the required error element is given by the constructor $\mho$ and
the required $\theta$ map is the constructor $\theta$. Lastly, it can be shown
that the delay morphism $\delta = \theta \circ \nxt$ satisfies $x \bisim
\delta\, x$ for all $x$ as is required by the definition of error domain.

The monadic bind operation $-^\dagger$ takes a predomain morphism $f : A \to UB$
to an error domain morphism $\li A \to B$; with this we define the action of $\li$ on
morphisms: Given $f : A \to A'$ we observe that $\eta \circ f : A \to U\li A'$, so
we define $\li f = (\eta \circ f)^\dagger : \li A \to \li A'$.

Finally, we define the action of $\li$ on a relation $c$ to be the heterogeneous
lock-step error ordering between $U\li A$ and $U\li A'$ and note that it by
definition satisfies the additional requirements of being an error domain
relation between the error domains $\li A$ and $\li A'$. 

% The monad $\li$ decomposes into a free-forgetful adjunction $F \dashv U$. Given
% a predomain $A$, we define the error domain $FA$ whose underlying predomain is
% $\li A$, whose error element is $\mho$, and whose $\theta$ map is the
% constructor $\theta$. 


% It is easily verified that $\li A$ is the free error- and later-algebra on the
% predomain $A$, so we have that $\li$ is left-adjoint to $U$.
 

% i.e., error domain morphisms from $\li A$ to $B$ are in one-to-one correspondence with
% predomain morphisms from $A$ to $UB$.

% We define $\delta : U(\li A) \To U(\li A)$ by $\delta(x) = \theta(\nxt x)$.
% We define $\hat{\delta} : \li A \arr \li A$ by $\hat{\delta} = \ext{(\delta \circ \eta)}{}$.
% Note that by definition of $\text{ext}$, we have that $\hat{\delta}$ is a morphism of error domains.

%\subsubsection{Lock-Step Error Ordering}\label{sec:lock-step}


% We define the action of $\li$ on a relation $R$ between $A$ and $A'$ to be the
% ``heterogeneous" version of the lock-step error ordering.

% TODO action of \li on commuting squares

\begin{comment}

% internal hom for predomains and error domains
Given predomains $A$ and $A'$, we can form the predomain of
predomain morphisms from $A$ to $A'$, denoted $A \To A'$.
\begin{itemize}
    % Should we give the definition involving x and x'?
    \item The ordering is defined by $f \le_{A \To A'} f'$ iff for all
    $x \in A$, we have $f(x) \le_{A'} f'(x)$.
    \item The bisimilarity relation is defined by $f \bisim_{A \To A'} f'$ iff
    for all $x, x' \in A$ with $x \bisim_{A} x'$, we have $f(x) \bisim_{A'} f'(x')$. 
\end{itemize}
%
Given $f : A_1' \to A_1$ and $g : A_2 \to A_2'$ we define the predomain morphism
$f \To g : (A_1 \To A_2) \to (A_1' \To A_2')$ by $\lambda h. \lambda x'. g(h(f(x')))$.

% TODO: include this?
% The monadic extension operation $\ext{\cdot}{} : (A_1 \To U (\li A_2)) \To (\li A_1 \To U(\li A_2))$
% is a morphism of predomains from $A_1 \To U(\li A_2)$ to $U(\li A_1) \To U(\li A_2)$, i.e.,
% it preserves the ordering and bisimilarity relations.


% Given a predomain $A$ and error domain $B$, we define $A \arr B := A \To UB$.
We note that $A \To UB$ carries a natural error domain structure
(in the below, the lambda is a meta-theoretic notation):
\begin{itemize}
    \item The error is given by $\lambda x . \mho_B$
    \item The $\theta$ operation is defined by
      \[ \theta_{A \To UB}(\tilde{f}) = \lambda x . \theta_B(\lambda t . \tilde{f}_t(x)). \]
\end{itemize}

Given a predomain $A$ and error domain $B$, we define
$A \arr B$ to be the error domain such that $U(A \arr B) = A \To UB$,
and whose error and $\theta$ operations are as defined above.
We can define the functorial action of $\arr$ on morphisms
$f \arr \phi$ in the obvious way.
%
It is easily verified that $A \arr B$ is an exponential of $UB$ by $A$
in the category of predomains and their morphisms.

\end{comment}

\begin{comment}
Lastly, given a relation of predomains $c$ between $A$ and $A'$, and a relation
of error domains $d$ between $B$ and $B'$, we define the relation $c \arr d$
between $A \arr B$ and $A' \arr B'$ in the obvious way, i.e., $f \in A \arr B$
is related to $g \in A' \arr B'$ iff for all $x \in A$ and $x' \in A'$ with
$(x, x') \in c$, we have $(f(x), g(x')) \in Ud$.
%
One can verify that this relation is indeed a relation of error domains
in that it respects error and preserves $\theta$.
\end{comment}



\subsection{Phase Two: Perturbations and Quasi-Representable Relations}

We now introduce the additional definitions needed to complete the construction
of our model. Recall from Section \ref{sec:adjusting-cast-rules} that in order
to establish the DnL rule for the downcast of $\iarr$, we needed to adjust the
rule by inserting a ``delay'' on the right-hand side. A similar adjustment is
needed for the DnR rule for $\iarr$. Moreover, the need to insert delays impacts
the semantics of the cast rules for \emph{all} relations, because of the
functorial nature of casts. That is, the upcast at a function type $c_i \ra c_o$
involves a downcast in the domain and an upcast in the codomain. This has two
consequences: first, the squares corresponding to the rules UpL and UpR may also
require the insertion of a delay. Second, we need to be able to insert
``higher-order'' delays in a way that follows the structures of the casts.


To accomplish this, we equip every predomain $A$ with a monoid $M_A$ of
\emph{syntactic perturbations}, as well as a means of \emph{interpreting} these
perturbations as actual endomorphisms on $A$. Moreover, we want the resulting
endomorphisms to be extensionally equivalent to the identity function, a
condition we express by saying that they are weakly bisimilar to the identity
morphism on $A$. More formally, for every $A$ we require a homomorphism of
monoids $i_A : M_A \to \morbisimid{A} := \{ f : A \to A \mid f \bisim \id_A \}$.
We likewise equip every error domain $B$ with a monoid $M_B$ and interpretation
homomorphism $i_B : M_B \to \morbisimid{B}$. These concepts deserve their own
definitions: We call the triple $(A, M_A, iA)$ a \textbf{value object} as it
will be the denotation of value types in our final model. Likewise, the triple
$(B, M_B, i_B)$ will be called a \textbf{computation object}.

We must now impose an additional condition on predomain relations $c$ and error
domain relations $d$ that specify how they interact with these perturbations. In
particular, we need to be able to ``push'' and ``pull'' perturbations along
relations $c$ and $d$. The intuition for this requirement comes from the
construction of the square corresponding to the original UpL rule from the
square for the simplified version as was shown in Section
\ref{sec:towards-relational-model}. Recall that we horizontally composed the
simplified UpL square for $c$ with the identity square for $c'$ on the right.
Now that the square for UpL involves a perturbation on the right instead of the
identity, this construction will not work unless we can ``push'' the
perturbation on $A_2$ to one on $A_3$. That is, given a relation $c : A \rel A'$
and a perturbation $m_A \in M_A$, we need to be able to turn it into a
perturbation $m_{A'} \in M_{A'}$ such that the resulting endomorphisms obtained
by applying the respective homomorphisms $i_A$ and $i_{A'}$ to the perturbations
form a square. Dually, we will need to ``pull'' a perturbation from right to
left. This notion is made formal by the following definition:
%
\begin{definition}
    Let $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$ be value objects, and let $c
    : A \rel A'$ be a predomain relation. A \textbf{push-pull structure} for $c$
    consists of monoid homomorphisms $\push : M_A \to M_A'$ and $\pull : M_A'
    \to M_A$ such that for all $m_A \in M_A$ there is a square $i_A(m_A)
    \ltsq{c}{c} i_{A'}(\push\, m_A)$ and for all $m_{A'} \in M_{A'}$ there is a
    square $i_A(\pull\, m_{A'}) \ltsq{c}{c} i_{A'}(m_{A'})$.
\end{definition}
%
We make the analogous definition for computation objects.

With the notion of perturbation defined, we can now discuss the final aspect of
the model, namely the representability of relations.
%
\begin{definition}[quasi-left-representable relations]
Let $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$ be value objects, and let $c : A
\rel A'$ be a predomain relation. We say that $c$ is
\emph{quasi-left-representable} by a predomain morphism $e : A \to A'$ if there
are perturbations $\delle_c \in M_A$ and $\delre_c \in M_{A'}$ such that the
following two squares exist: (1) UpL: $e \ltsq{c}{r(A')} i_{A'}(\delre_c)$, and
(2) UpR: $i_A(\delle_c) \ltsq{r(A)}{c} e$.
\end{definition}
%
Observe that this generalizes the previous notion of representability, since
under that definition the perturbations were always the identity.
%
We make the analogous definition of quasi-left-representability for error domain
relations $d$.
%
Likewise, we define quasi-right-representability as follows:
%
\begin{definition}
Let $(B, M_B, i_B)$ and $(B', M_{B'}, i_{B'})$ be computation objects, and let
$d : B \rel B'$ be an error domain relation. We say that $d$ is
\emph{quasi-right-representable} by an error domain morphism $p : B' \to B$ if
there are perturbations $\dellp_d \in M_B$ and $\delrp_d \in M_{B'}$ such that
the following two squares exist: 
(1) DnL: $p \ltsq{r(B')}{d} i_{B'}(\delrp_d)$ and
(2) DnR: $i_B(\dellp_d) \ltsq{d}{r(B)} p$.
\end{definition}
%
We make the analogous definition of quasi-right-representability for predomain
relations $c$.

Although it makes sense to refer to the quasi-representability of an arbitrary
predomain or error domain relation, quasi-representable relations do not in
general compose. In order to construct the needed squares for the composition of
two relations, we require that the relations have push-pull structures.

We can now give the final definition of value and computation relations for our
model:
%
\begin{definition}[value relations]
A \textbf{value relation} between value objects $(A, M_A, i_A)$ and $(A',
M_{A'}, i_{A'})$ consists of a predomain relation $c : A \rel A'$ that has a
push-pull structure, is quasi-left-representable by a morphism $e_c : A \to A'$,
and is such that $\li c$ is quasi-right-representable by an error domain morphism
$p_c : \li A' \to \li A$.
\end{definition}

\begin{definition}[computation relations]
A \textbf{computation relation} between computation objects $(B, M_B, i_B)$ and
$(B', M_{B'}, i_{B'})$ consists of an error domain relation $d$ that has a
push-pull structure, is quasi-right-representable by a morphism $p_d : B' \to
B$, and is such that $Ud$ is quasi-left-representable by a morphism $e_d : UB
\to UB'$
\end{definition}

The reason for requiring $\li c$ to be quasi-right-representable in the definition
of value relations is so that we can define the action of the functor $\li$ on
relations. Similarly, we require $Ud$ to be quasi-left-representable in the
definition of computation relations so that we can define the action of $U$ on
relations.

It remains to specify the actions of the functors on value and computation
objects and relations.
% Because we have augmented the definitions of object and relation for our model,
% we need to specify the actions of the functors $F$, $U$, $\times$, and $\arr$ on
% these objects and relations. 
% For instance, the functor $F$ now acts on \emph{value objects} $(A, M_A, i_A)$,
% which means we need to specify the monoid $M_{FA}$ and interpretation $i_{FA}$
% corresponding to the error domain $FA$.

\subsubsection{Constructions involving Perturbations}\label{sec:perturbation-constructions}

We first discuss the action of $\li$ on objects. Given a value object $(A, M_A,
i_A)$ we define $M_{\li A}$ to be $\mathbb{N} \oplus M_A$, where $\oplus$
denotes the free product of monoids (the coproduct in the category of monoids).
The intuition behind needing to include $\mathbb{N}$ comes from the example of
the downcast for $\iarr$. Recall that we adjusted the squares corresponding to
the DnL and DnR rules by adding $(\delta \circ \eta)^\dagger$ on the side
opposite the downcast. Thus, we need a syntactic perturbation in $M_{\li A}$
that will be interpreted as $(\delta \circ \eta)^\dagger$. We accomplish this by
taking the coproduct with $\mathbb{N}$.
%
Then to interpret the perturbations as endomorphisms, by the universal property
of the coproduct of monoids it suffices to define two homomorphisms, one from
$\mathbb{N} \to \morbisimid{\li A}$ and one from $M_A \to \morbisimid{\li A}$.
The first homomorphism sends the generator $1 \in \mathbb{N}$ to the error
domain endomorpism $(\delta \circ \eta)^\dagger$, and the second sends $m_A \in
M_A$ to $\li(i_A(m_A))$ and we observe in both cases that the resulting
endomorphisms are bisimilar to the identity since the action of $\li$ on
morphisms preserves bisimilarity.

Now we discuss the action of $U$ on objects. Given a computation object $(B,
M_B, i_B)$, we define $M_{UB}$ to be $\mathbb{N} \oplus M_B$. The reason for
requiring $\mathbb{N}$ is related to the Kleisli arrow functor: to establish
quasi-representability of $U(c \arr d)$ given quasi-representability of $c$ and
$d$, we will need to turn a perturbation on $\li A$ into a perturbation on $U(A
\arr B)$. Since the perturbations for $\li A$ involve $\mathbb{N}$, so must the
perturbations for $UB$. The interpretation $i_{UB}$ of the perturbations on $UB$
works in the same manner as that of $\li A$.

The action of $\times$ on objects is as follows. Given $(A_1, M_{A_1}, i_{A_1})$
and $(A_2, M_{A_2}, i_{A_2})$, we define the monoid $M_{A_1 \times A_2} =
M_{A_1} \oplus M_{A_2}$. To construct the homomorphism $i_{A_1 \times A_2}$, we
appeal to the universal property and give homomorphisms $M_{A_1} \to
\morbisimid{A_1 \times A_2}$ and $M_{A_2} \to \morbisimid{A_1 \times A_2}$. The
former applies $i_{A_1}$ in the first component and the identity in the second
component, while the latter does the reverse with $i_{A_2}$.

The action of $\arr$ on objects is as follows. Given $(A, M_A, iA)$ and $(B,
M_B, i_B)$ we define the monoid $M_{A \arr B} = M_A^{op} \oplus M_B$. Then to
construct the interpretation as endomorphisms it suffices to define a
homomorphism $M_A^{op} \to \morbisimid{A \arr B}$ and $M_B \to \morbisimid{A
\arr B}$. The former takes an element $m_A$ and a predomain morphism $f : A \to
UB$ and returns the composition $f \circ i_A(m_A)$, while the latter is defined
similarly by post-composition with $i_B$.

\subsubsection{Constructions involving Value and Computation Relations}


\eric{What, if anything, should go here? Should we discuss composition of
value/computation relations? Actions of the functors on relations?}

\eric{TODO: Quasi-equivalence of the relations mentioned in the syntax section.}



\subsection{The Dynamic Type}
We now describe the denotation of the dynamic type. Analogously to how we
defined the dynamic type in Section \ref{sec:concrete-term-model}, the predomain
representing the dynamic type is defined using a combination of least fixpoint
and guarded recursion as the solution to the equation of \emph{predomains}
%
\[ D \cong \mathbb{N}\, + (D \times D)\, + \laterhs U(D \arr \li D). \]
%
As before, we name the constructors $\inat$, $\itimes$, and $\iarr$
respectively, and the upcasts $e_{\nat}$, $e_\times$, and $e_\to$ are the same
as the constructors except for $e_{\iarr}$ which includes a $\nxt$.

%
% We define $e_\mathbb{N} : \mathbb{N} \to D$ to be the $\text{nat}$ constructor,
% $e_\times : D \times D \to D$ to be $\text{times}$, and $e_\to : U(D \arr F D)$
% to be the morphism $\nxt$ followed by $\text{fun}$.

The ordering $\le_D$ is given by:
%
\begin{align*}
    \inat(n) \le \inat(n') 
        &\iff n = n' \\
    \itimes (d_1, d_2) \le \itimes (d_1', d_2')
        &\iff d_1 \le_D d_2 \text{ and } d_1' \le_D d_2'\\
    \iarr(\tilde{f}) \le \iarr(\tilde{f'}) 
        &\iff \later_t(\tilde{f}_t \le \tilde{f'}_t),
\end{align*}
%
and the bisimilarity relation is defined analogously.
%
We define three relations involving $D$ as follows. We define $\inat :
\mathbb{N} \rel D$ by $(n, d) \in \inat$ iff $e_\nat(n) \le_D d$. We similarly
define $\itimes : D \times D \rel D$ by $((d_1, d_2), d) \in \itimes$ iff
$e_\times(d_1, d_2) \le_D d$, and we define $\text{inj}_\to : U(D \arr \li D)
\rel D$ by $(f, d) \in \iarr$ iff $e_\to(f) \le_D d$.

Now we define the perturbations for $D$. Recall that to each predomain $A$ we
associate a monoid $M_A$ of perturbations and a homomorphism into the monoid of
endomorphisms bisimilar to the identity, and likewise for error domains. It may
seem as though we need to define the perturbations for $D$ by guarded recursion,
but in fact we define them via least-fixpoint in the category of monoids:
%
\( M_D \cong (M_{D \times D}) \oplus M_{U(D \to \li D)}. \)
%
% Unfolding the definitions, this is the same as
% %
% \( M_D \cong (M_D \times M_D) \oplus (\mathbb{N} \times M_D^{op} \times \mathbb{N} \times M_D). \)
% %
We now explain how to interpret these perturbations as endomorphisms.

\eric{Check this}

We define $i_D : M_D \to \{ f : D \to D \mid f \bisim \id \}$ by induction as follows:
%
\begin{align*}
  i_D(m_\times) &= \lambda d. \text{case $d$ of }
    \{ \itimes (d_1, d_2) \To \itimes (i_{D \times D}(m_\times)(d_1, d_2)) \alt x \To x \} \\
  i_D(m_\to) &= \lambda d. \text{case $d$ of }
    \{ \iarr (\tilde{f}) \To \iarr (\lambda t. i_{U(D \to \li D)}(m_\to)(\tilde{f}_t)) \alt x \To x \} \\
\end{align*}
%
In the case of a perturbation on $D \times D$, we use the interpretation for the
perturbations of $D \times D$ as defined earlier in this section, which in turn
will use $i_D$ inductively. Similarly, for a perturbation on $U(D \to \li D)$ we
use the interpretation for perturbations on $U(D \to \li D)$.

% \begin{align*}
%  i_D(m_{\text{times}}, m_{\text{fun}}) &= \lambda d.\text{case $d$ of}  \\
%  &\alt \tnat(m) \mapsto \tnat(m) \\
%     &\alt \ttimes(d_1, d_2) \mapsto {\ttimes(i_{D \times D}(p_\text{times})(d_1, d_2))} \\
%     &\alt \tfun(\tilde{f}) \mapsto {\tfun(\lambda t. i_{U(D \to \li D)}(\tilde{f}_t))}
% \end{align*}
 
One can verify that this defines a homomorphism from $M_D \to \{ f : D \to D : f
\bisim \id \}$. We claim that the three relations $\inat$, $\itimes$, and
$\iarr$ satisfy the push-pull property. As an illustrative case, we establish
the push-pull property for the relation $\iarr$. We define $\pull_{\iarr} : M_D
\to M_{U(D \arr \li D)}$ by giving a homomorphism from $M_{D \times D} \to
M_{U(D \arr \li D)}$ and from $M_{U(D \to \li D)} \to M_{U(D \arr \li D)}$. The
former is the trivial homomorphism sending everything to the identity element,
while the latter is the identity homomorphism.
%
Conversely, we define $\push_{\iarr} : M_{U(D \arr \li D)} \to M_D$ as the
inclusion into the coproduct.
%
Showing that the relevant squares exist involving push and pull is
straightforward.

We next claim that the relations $\inat$, $\itimes$, and $\iarr$ are
quasi-left-representable, and that their lifts are quasi-right-representable.
Indeed, it is straightforward to see that they are quasi-left-representable
where all of the perturbations are taken to be the identity elements of the
respective monoids.
%
For quasi-right-representability, the only nontrivial case is $\li(\iarr)$.
Recall the defintion of the downcast for $\iarr$ given in Section
\ref{sec:term-interpretation}.

We know that in order for the DnR and DnL squares for $\li \iarr$ to exist, we must
insert a delay on the side opposite the downcast. In terms of perturbations,
this means that we take the perturbations $\dellp$ and $\delrp$ in the
definition of quasi-right-representability to both be $\inl\, 1$, where $\inl$
is the injection into the coproduct of monoids. We recall that the monoid of
perturbations for $\li$ involves a coproduct with $\mathbb{N}$, and that the
interpretation homomorphism maps the generator $1$ to the endomorphism of error
domains $(\delta \circ \eta)^\dagger$.

With this choice for the perturbations, it is straightforward to show that the
DnL and DnR squares exist using the definition of the downcast and the
definition of the relation $\iarr$. 

% We define $\dellp_D = \delrp_D = \delta_{FD}$. Then it is easy to show using the
% definition of $\iarr$ that the squares for $\dnl$ and $\dnr$ commute.
% Then for $\dnr$, we need to show that if $(f, d) \in \iarr$ then
%
It is also straightforward to establish the retraction property for each of
these three relations. In the case of $\iarr$, we have that the property holds
up to a delay.

% \subsection{Obtaining an Extensional Model}

\subsection{Defining an Extensional Model}

To obtain a model for gradual typing that is oblivious to the stepping behavior
of terms, we apply the ``bisimilarity-closure'' construction introduced in the
previous section as follows. Let $c_i : A_i \rel A_i'$ and $c_o : A_o \rel
A_o'$.
%
% We define an extensional square between morphisms $f : A_i \to A_o$ and $g :
% A_i' \to A_o'$ to consist of:

% \begin{itemize}
%   \item A morphism $f' : A_i \to A_o$ with $f \bisim f'$.
%   \item A morphism $g' : A_i' \to A_o'$ with $g \bisim g'$.
%   \item A square $f' \ltsq{c_i}{c_o} g'$.
% \end{itemize}
%
We say that $f \ltsqbisim{c^i}{c_o} g$ if there exist $f'$ and $g'$ such that
%
\[ f \bisim f' \ltsq{c_i}{c_o} g' \bisim g. \]
%
If the relations $c_i$ and $c_o$ are obvious from the context, we will simply
write $f \ltbisim g$. We make the analogous construction for the computation
squares.
%
We now verify the existence of the squares for the cast rules. For UpL, the
square is obtained as follows:

% https://q.uiver.app/#q=WzAsNixbMCwwLCJBXzEiXSxbMSwwLCJBXzIiXSxbMiwwLCJBXzMiXSxbMCwxLCJBXzIiXSxbMSwxLCJBXzIiXSxbMiwxLCJBXzMiXSxbMCwzLCJlX2MiLDIseyJjdXJ2ZSI6MX1dLFsxLDQsIlxcZGVscmVfYyIsMl0sWzIsNSwiXFxwdXNoX3tjJ30oXFxkZWxyZV9jKSIsMix7ImN1cnZlIjoxfV0sWzAsMSwiYyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsMiwiYyciLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFszLDQsIlxcbGVfe0FfMn0iLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs0LDUsImMnIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiw1LCJcXGlkIiwwLHsiY3VydmUiOi0xfV0sWzAsMywiZV9jIiwwLHsiY3VydmUiOi0xfV0sWzgsMTMsIlxcYmlzaW0iLDEseyJzaG9ydGVuIjp7InNvdXJjZSI6MjAsInRhcmdldCI6MjB9LCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiwxNCwiXFxiaXNpbSIsMSx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\[\begin{tikzcd}[ampersand replacement=\&,column sep=large]
	{A_1} \& {A_2} \& {A_3} \\
	{A_2} \& {A_2} \& {A_3}
	\arrow["c", "\shortmid"{marking}, no head, from=1-1, to=1-2]
	\arrow[""{name=0, anchor=center, inner sep=0}, "{e_c}"', curve={height=6pt}, from=1-1, to=2-1]
	\arrow[""{name=1, anchor=center, inner sep=0}, "{e_c}", curve={height=-6pt}, from=1-1, to=2-1]
	\arrow["{c'}", "\shortmid"{marking}, no head, from=1-2, to=1-3]
	\arrow["{\delre_c}"', from=1-2, to=2-2]
	\arrow[""{name=2, anchor=center, inner sep=0}, "{\push_{c'}(\delre_c)}"', curve={height=6pt}, from=1-3, to=2-3]
	\arrow[""{name=3, anchor=center, inner sep=0}, "\id", curve={height=-6pt}, from=1-3, to=2-3]
	\arrow["{\le_{A_2}}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
	\arrow["{c'}"', "\shortmid"{marking}, no head, from=2-2, to=2-3]
	\arrow["\bisim"{description}, draw=none, from=0, to=1]
	\arrow["\bisim"{description}, draw=none, from=2, to=3]
\end{tikzcd}\]

Note that the horizontal composition of the squares is defined, as it takes
place in the intensional setting. We have used the push-pull structure on $c'$
to turn the perturbation on $A_2$ into a perturbation on $A_3$. Lastly we note
that the bottom edge of the square is equal to $c'$ by the fact that $c'$ is
downward closed. The squares for UpR, DnL, and DnR are obtained similarly.

% Now that we have defined an intensional model with an interpretation for the
% dynamic type, we can apply the abstract constructions introduced in Section
% \ref{sec:extensional-model-construction}. Doing so, we obtain an extensional
% model of gradual typing, where the squares are given by the ``bisimilarity
% closure'' of the intensional error ordering.

\eric{Order-equivalence of relations}



\subsection{Relational Adequacy}\label{sec:adequacy}

\eric{TODO: update this in light of the new section on adequacy of the term model.}

In this section, we prove an adequacy result for the extensional model of
gradual typing we obtained in the previous section. First we establish some
notation. Fix a morphism $f : 1 \to \li \mathbb{N} \cong \li \mathbb{N}$. We
write $f \da n$ to mean that there exists $m$ such that $f = \delta^m(\eta n)$
and $f \da \mho$ to mean that there exists $m$ such that $f = \delta^m(\mho)$.

Recall that $\ltbisim$ denotes the relation on value morphisms defined as the
bisimilarity-closure of the intensional error-ordering on morphisms. That is, we
have $f \ltbisim g$ iff there exist $f'$ and $g'$ with
%
\[ f \bisim_{\li \mathbb{N}} f' \le_{\li \mathbb{N}} g' \bisim_{\li \mathbb{N}} g. \]
%
Here $\le_{\li \mathbb{N}}$ is the lock-step error ordering, and $\bisim_{\li
\mathbb{N}}$ is weak bisimilarity. First observe that in this ordering, the
semantics of error is not equivalent to the semantics of the diverging term. The
main result we would like to show is as follows: If $f \ltbisim g : \li \mathbb{N}$, then:
\begin{itemize}
  \item If $f \da n$ then $g \da n$.
  \item If $g \da \mho$ then $f \da \mho$.
  \item If $g \da n$ then $f \da n$ or $f \da \mho$.
\end{itemize}

%
Unfortunately, this is actually not provable!
Roughly speaking, the issue is that this is a ``global'' result, and it is not possible
to prove such results inside of the guarded setting. 
In particular, if we tried to prove the above result in the guarded
setting, we would run into a problem where we would have a natural number
``stuck'' under a $\later$, with no way to get out the underlying number.
%
Thus, to prove our adequacy result, we need to leave the guarded setting and pass back
to the more familiar, set-theoretic world with no internal notion of step-indexing.
We can do this using a process known as \emph{clock quantification}.
Recall that all of the constructions we have made in SGDT take place in the context of a clock $k$.
All of our uses of the later modality and guarded recursion have taken place with respect to this clock.
For example, recall the definition of the lift monad by guarded recursion.
% We define the lift monad $\li^k X$ as the guarded fixpoint of $\lambda \tilde{T}. X + 1 + \later^k_t (\tilde{T}_t)$.
We can view this definition as being parameterized by a clock $k$: $\li^k : \type \to \type$.
Then for $X$ satisfying a certain technical requirement known as \emph{clock-irrelevance},
\footnote{A type $X$ is clock-irrelevant if there is an isomorphism $\forall k.X \cong X$.}
we can define the ``global lift'' monad as $\li^{gl} X := \forall k. \li^k X$.

It can be shown that there is an isomorphism between the global lift monad and the
delay monad of Capretta \cite{lmcs:2265}.
Recall that, given a type $X$, the delay monad $\text{Delay}(X)$ is defined as the coinductive
type generated by 
$\tnow : X \to \delay(X)$ and $\tlater : \delay(X) \to \delay(X)$.

% solution to the equation

% \[ \text{Delay}(X) \cong X + \text{Delay}(X). \]

It can be shown that for a clock-irrelevant type $X$, $\li^{gl} X$ is a final
coalgebra of the functor $F(Y) = X + 1 + Y$ (For example, this follows from Theorem 4.3 in
\cite{kristensen-mogelberg-vezzosi2022}.) 
\footnote{The proof relies on the existence of an operation  
$\mathsf{force} : \forall k. \later^k A \to \forall k. X$ that
allows us to eliminate the later operator under a clock quantifier.
This must be added as an axiom in guarded type theory.}
Since $\delay(X + 1)$ is also a final coalgebra
of this functor, then we have $\li^{gl} X \cong \delay(X + 1)$.

Given a predomain $X$ on a clock-irrelevant type, we can define a
``global'' version of the lock-step error ordering and the
weak bisimilarity relation on elements of the global lift; the former is defined by
%
\( x \le^{gl}_X y := \forall k. x[k] \le y[k], \)
%
and the latter is defined by
%
\( x \bisim^{gl}_X y := \forall k. x[k] \bisim y[k]. \)
%
On the other hand, we can define coinductively a ``lock-step error ordering"
relation on $\delay(X + 1)$:
%
\begin{mathpar}
  \inferrule*[]
  { }
  {\tnow (\inr\, 1) \ledelay d}

  \inferrule*[]
  {x_1 \le_X x_2}
  {\tnow (\inl\, x_1) \ledelay \tnow (\inl\, x_2)}

  \inferrule*[]
  {d_1 \ledelay d_2}
  {\tlater\, d_1 \ledelay \tlater\, d_2}
\end{mathpar}
%
And we similarly define by coinduction a ``weak bisimilarity'' relation on $\delay(X + 1)$, which uses
a relation $d \Da x_?$ between $\delay(X+1)$ and $X+1$ that is defined as 
$d \Da x_? := \Sigma_{m \in \mathbb{N}} d = \tlater^m(\tnow\, x_?)$.
Then weak bisimilarity is defined by the rules
%
\begin{mathpar}
  \inferrule*[]
  {x_? \bisim_{X + 1} y_?}
  {\tnow\, x_? \bisimdelay \tnow\, y_? }

  \inferrule*[]
  {d_1 \Da x_? \and x_? \bisim_{X + 1} y_?}
  {\tlater\, d_1 \bisimdelay \tnow\, y_? }

  \inferrule*[]
  {d_2 \Da y_? \and x_? \bisim_{X + 1} y_?}
  {\tnow\, x_? \bisimdelay \tlater\, d_2}

  \inferrule*[]
  {d_1 \bisimdelay d_2}
  {\tlater\, d_1 \bisimdelay \tlater\, d_2 }

  % \inferrule*[]
  % {d_1 \Da x_? \and d_2 \Da y_? \and x_? \bisim_{X + 1} y_?}
  % {d_1 \bisimdelay d_2}

  % \inferrule*[]
  % {d_1 \bisimdelay d_2}
  % {\tlater d_1 \bisimdelay \tlater d_2 }

\end{mathpar}
%
Note the similarity of these definitions to the corresponding guarded definitions.
By adapting the aforementioned theorem to the setting of inductively-defined relations,
we can show that both the global lock-step error ordering and the global weak bisimilarity
admit coinductive definitions. In particular, modulo the above isomorphism
between $\li^{gl} X$ and $\delay(X+1)$, the global version of the lock-step
error ordering is equivalent to the lock-step error ordering on $\delay(X + 1)$,
and likewise, the global version of the weak bisimilarity relation is equivalent to the
weak bisimilarity relation on $\delay(X + 1)$.

This implies that the global version of the extensional term precision semantics for
$\li^{gl} X$ agrees with the corresponding notion for $\delay(X + 1)$.
Then adequacy follows by proving the corresponding
result for $\delay(X + 1)$ which in turn follows from the definitions of the relations.


% We have been writing the type as $\li X$, but it is perhaps more accurate to write it as $\li^k X$ to
% emphasize that the construction is parameterized by a clock $k$.

% Need : nat is clock irrelevant, as well as the inputs and outputs of effects
% Axioms about forcing clock
% Adapt prior argument to get that the defining of the global bisim
% and global lock-step error ordering are coinductive
