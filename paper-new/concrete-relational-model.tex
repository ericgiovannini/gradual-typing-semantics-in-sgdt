\section{A Guarded Model of Graduality}\label{sec:concrete-relational-model}

In this section, we describe in detail our model of gradual typing. To manage
the complexity, we carry out the construction in two phases, beginning with a
relational model consisting of partially-ordered sets with a notion of
bisimilarity and then adding requirements for a structured set of syntactic
perturbations on each type as well as the notion of quasi-representability for
relations that models the cast rules. We then discuss the construction of the
dynamic type and the refined denotation of term precision that relates terms
that can be synchronized to be in lock-step. We conclude by demonstrating the
adequacy of our model with respect to the graduality property.

\subsection{Phase One: Predomains and Error Domains}

In the previous section, we introduced the notion of weak bisimilarity as a
relation on the guarded lift monad. Recall that weak bisimilarity on $\li A$ is
parameterized by a relation on $A$. To define a compositional model for all
types, we equip the posets and error domains with a reflexive, symmetric
bisimilarity relation. This leads to our first new definition: 

\begin{definition}
A \textbf{predomain} $A$ consists of a set $A$ along with two relations:
\begin{itemize}
    \item A partial order $\le_A$.
    \item A reflexive, symmetric ``bisimilarity'' relation $\bisim_A$.
\end{itemize}
\end{definition}

We will generally write $A$ for both a predomain and its underlying set; if we
need to emphasize the difference we will write $|A|$ for the underlying set of
$A$.

Given a predomain $A$, we can form the predomain $\later A$. The underlying set
is $\later |A|$ and the relation is defined in the obvious way, i.e., $\tilde{x}
\le_{\later A} \tilde{x'}$ iff $\later_t(\tilde{x}_t \le_A \tilde{x'}_t)$.
Likewise for bisimilarity.
%
We also give a predomain structure to the natural numbers $\mathbb{N}$, where
both the ordering and the bisimilarity relation are equality.
%
Morphisms of predomains are functions between the underlying sets that preserve
the ordering and the bisimilarity relation. More formally:
%
\begin{definition}
Let $A$ and $A'$ be predomains. A \textbf{morphism of predomains} $f : A \to A'$
is a function between the underlying sets such that for all $x, x'$, if $x \le_A
x'$, then $f(x) \le f(x')$, and if $x \bisim_A x'$, then $f(x) \bisim_{A'}
f(x')$.
\end{definition}

We also equip error domains with a bisimilarity relation, and we impose a
condition relating the $\theta$ morphism to the bisimilarity relation. More
concretely:
%
\begin{definition}
An \textbf{error domain} $B$ consists of a predomain $B$ along with the following data:
\begin{itemize}
    \item A distinguished ``error'' element $\mho_B \in B$
    \item A morphism of predomains $\theta_B \colon \later B \to B$
    \item For all $x : B$ we have $\theta_B(\nxt\, x) \bisim_B x$
\end{itemize}
\end{definition}
%
For an error domain $B$, we define the predomain morphism $\delta_B := \theta_B
\circ \nxt$.
%
A \textbf{morphism of error domains} is simply a morphism of the underlying
predomains that preserves the error element and the $\theta$ map.

%
The definition of relations between predomains is the same as that between
posets introduced in the previous section, as the bisimilarity relations of the
predomains are not involved in the definition of monotone relation.

Next we define an analogous notion of \emph{relation} between error domains $B$
and $B'$. An error domain relation $d : B \rel B'$ is a relation on the
underlying posets that preserves error and respects $\theta$. More formally:
%
\begin{definition}
  Let $B$ and $B'$ be error domains. An \textbf{error domain relation} between
  $B$ and $B'$ is a monotone relation $d$ on the underlying partially-ordered sets such that:
  \begin{enumerate}
     \item (Respects error): For all $y \in B'$, we have $(\mho_B, y) \in d$.
     \item (Preserves $\theta$): For all $\tilde{x}$ in $\laterhs B$ and
     $\tilde{y} \in \laterhs B'$, if $\laterhs_t ((\tilde{x}_t, \tilde{y}_t) \in
     d)$, then $(\theta_B (\tilde{x}), \theta_{B'} (\tilde{y})) \in d$. 
  \end{enumerate}
\end{definition}
%
As with predomain relations, we can compose error domain relations. However,
because of a technical restriction involving the interaction between
propositional truncation and the later modality, we cannot define the
composition of error domain relations as the composition of their underlying
predomain relations. Instead, we define composition of error domain relations
$d$ on $B_1$ and $B_2$ and $d'$ on $B_2$ and $B_3$ inductively to be the least
relation containing $d$ and $d'$ that is downward closed under $\le_{B_1}$,
upward-closed under $\le_{B_3}$, respects error, and preserves $\theta$.
Specifically, it is defined inductively by the following rules:
% %
% \begin{mathpar}
%     \inferrule*[right = Comp]
%     {b_1 \mathbin{d} b_2 \and b_2 \mathbin{d'} b_3}
%     {b_1 \mathbin{d \relcomp d'} b_3}

%     \inferrule*[right = DnClosed]
%     {b_1' \le_{B_1} b_1 \and b_1 \mathbin{d \relcomp d'} b_3}
%     {b_1' \mathbin{d \relcomp d'} b_3}

%     \inferrule*[right = UpClosed]
%     {b_1 \mathbin{d \relcomp d'} b_3 \and b_3 \le_{B_3} b_3'}
%     {b_1 \mathbin{d \relcomp d'} b_3'}

%     \inferrule*[right = PresErr]
%     { }
%     {\mho_{B_1} \mathbin{d \relcomp d'} b_3}

%     \inferrule*[right = PresTheta]
%     {\later_t( \tilde{b_1} \mathbin{d \relcomp d'} \tilde{b_3} ) }
%     {\theta_{B_1}(\tilde{b_1}) \mathbin{d \relcomp d'} \theta_{B_3}(\tilde{b_3}) }
% \end{mathpar}
% %

The definitions of squares for predomains are also unchanged from the previous
section, except that the morphisms on the left and right are now morphisms of
predomains. We likewise define a notion of \textbf{error domain square}: Let
$d_i : B_i \rel B_i'$ and $d_o : B_o \rel B_o'$ be error domain relations, and
let $\phi : B_i \multimap B_o$ and $\phi' : B_i' \multimap B_o'$ be morphisms of
error domains. We say that there is an error domain square $\phi \ltsq{d_i}{d_o}
\phi'$ exactly when there is a predomain square involving the underlying
predomain morphisms and relations.


\subsubsection{Functors}\label{sec:free-error-domain}

The functors $U$, $\li$, $\times$, and $\arr$ introduced in the previous section
extend to predomains, error domains, and their relations. The functor $U$ simply
takes the underlying predomain relation of an error domain relation. Given a
relation $c_1 : A_1 \rel A_1'$ and $c_2 : A_2 \rel A_2'$, the relation $c_1
\times c_2 : (A_1 \times A_2) \rel (A_1' \times A_2')$ is defined by $((x, y),
(x', y')) \in (c_1 \times c_2)$ if and only if $(x, x') \in c_1$ and $(y, y')
\in c_2$. Given a relation $c : A \rel A'$ and an error domain relation $d : B
\rel B'$, the relation $c \arr d : (A \arr B) \rel (A' \arr B')$ is the error
domain relation defined by $(f, g) \in (c \arr d)$ if and only if for all $x :
A$ and $x' : A'$ with $(x , x') \in c$ we have $(f(x), g(x')) \in Ud$. The fact
that this relation preserves error and respects $\theta$ follows from the
corresponding properties for $d$.

% Free error domain
The functor $\li$ takes a predomain $A$ to the free error domain on $A$. We first
define the predomain $U\li A$. The underlying set of $U\li A$ is defined to be $\li
|A|$ (the guarded lift monad applied to $|A|$). The ordering relation is the
lock-step error ordering introduced in the previous section (taking $A = A'$ in
the definition), and the bisimilarity relation is the weak bisimilarity relation
on $\li |A|$ also defined in the previous section. With these relations, the
constructors $\eta$ and $\theta$ of the guarded lift monad are in fact morphisms
of predomains, i.e., they are monotone and preserve bisimilarity.
%
We observe that this predomain structure extends to an error domain structure by
noting that the required error element is given by the constructor $\mho$ and
the required $\theta$ map is the constructor $\theta$. Lastly, it can be shown
that the delay morphism $\delta = \theta \circ \nxt : UB \to UB$ satisfies $x \bisim
\delta\, x$ for all $x$ as is required by the definition of error domain.

The monadic bind operation $-^\dagger$ takes a predomain morphism $f : A \to UB$
to an error domain morphism $\li A \multimap B$; with this we define the action of $\li$ on
morphisms: Given $f : A \to A'$ we define $\li f = (\eta \circ f)^\dagger : \li A \to \li A'$.

Finally, we define the action of $\li$ on a predomain relation $c$ to be the
heterogeneous lock-step error ordering between $U\li A$ and $U\li A'$ and note
that it by definition satisfies the additional requirements of being an error
domain relation between the error domains $\li A$ and $\li A'$.



\subsection{Phase Two: Perturbations and Quasi-Representable Relations}

We now introduce the additional definitions needed to complete the construction
of our model. Recall from Section \ref{sec:lock-step-and-weak-bisim} that in order
to establish the DnL rule for the downcast of $\iarr$, we needed to adjust the
rule by inserting a ``delay'' on the right-hand side. A similar adjustment is
needed for the DnR rule for $\iarr$. Moreover, the need to insert delays impacts
the semantics of the cast rules for \emph{all} relations, because of the
functorial nature of casts. That is, the upcast at a function type $c_i \ra c_o$
involves a downcast in the domain and an upcast in the codomain. This has two
consequences: first, the squares corresponding to the rules UpL and UpR may also
require the insertion of a delay. Second, we need to be able to insert
``higher-order'' delays in a way that follows the structures of the casts.

To accomplish this, we equip every predomain $A$ with a monoid $M_A$ of
\emph{syntactic perturbations}, as well as a means of \emph{interpreting} these
syntactic perturbations as \emph{semantic} perturbations on $A$, i.e., as
endomorphisms that are bisimilar to the identity.
% Moreover, we want the
% resulting endomorphisms to be extensionally equivalent to the identity function,
% a condition we express by saying that they are weakly bisimilar to the identity
% morphism on $A$. 
More formally, for every $A$ we require a homomorphism of monoids $i_A : M_A \to
\morbisimid{A} := \{ f : A \to A \mid f \bisim \id_A \}$. We likewise equip
every error domain $B$ with a monoid $M_B$ and interpretation homomorphism $i_B
: M_B \to \morbisimid{B}$. This grouping of data deserves its own definition: We
call the triple $(A, M_A, iA)$ a \textbf{value object} as it will be the
denotation of value types in our final model. Likewise, the triple $(B, M_B,
i_B)$ will be called a \textbf{computation object}.

We must impose an additional condition on predomain relations $c$ and error
domain relations $d$ that specify how they interact with these perturbations. In
particular, we need to be able to ``push'' and ``pull'' perturbations along
relations $c$ and $d$. The intuition for this requirement comes from the
construction of the square corresponding to the original UpL rule from the
square for the simplified version as was shown in Section
\ref{sec:towards-relational-model}. Recall that we horizontally composed the
simplified UpL square for $c$ with the identity square for $c'$ on the right.
Now that the square for UpL involves a perturbation on the right instead of the
identity, this construction will not work unless we can ``push'' the
perturbation on $A_2$ to one on $A_3$. That is, given a relation $c : A \rel A'$
and a syntactic perturbation $m_A \in M_A$, we need to be able to turn it into a
syntactic perturbation $m_{A'} \in M_{A'}$ such that the resulting semantic
perturbations obtained by applying the respective homomorphisms $i_A$ and
$i_{A'}$ form a square. Dually, we will need to ``pull'' a perturbation from
right to left. This notion is made formal by the following definition:
%
\begin{definition}
    Let $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$ be value objects, and let $c
    : A \rel A'$ be a predomain relation. A \textbf{push-pull structure} for $c$
    (with respect to $M_A$ and $M_{A'}$) consists of monoid homomorphisms $\push
    : M_A \to M_A'$ and $\pull : M_A' \to M_A$ such that for all $m_A \in M_A$
    there is a square $i_A(m_A) \ltsq{c}{c} i_{A'}(\push\, m_A)$ and for all
    $m_{A'} \in M_{A'}$ there is a square $i_A(\pull\, m_{A'}) \ltsq{c}{c}
    i_{A'}(m_{A'})$.
\end{definition}
%
We make the analogous definition for computation objects.

With the notion of syntactic perturbation defined, we can now make formal the
final aspect of the model: the notion of quasi-represntability of relations.
%
\begin{definition}[quasi-left-representable relations]
Let $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$ be value objects, and let $c : A
\rel A'$ be a predomain relation. We say that $c$ is
\emph{quasi-left-representable} by a predomain morphism $e : A \to A'$ if there
are perturbations $\delle_c \in M_A$ and $\delre_c \in M_{A'}$ such that the
following two squares exist: (1) $\upl$: $e \ltsq{c}{\le_{A'}} i_{A'}(\delre_c)$, and
(2) $\upr$: $i_A(\delle_c) \ltsq{\le_{A}}{c} e$.
\end{definition}
%
Observe that this weakens the previous notion of representability, since under
that definition the perturbations were required to be the identity.
%
We make the analogous definition of quasi-left-representability for error domain
relations $d$.

Likewise, we define quasi-right-representability as follows:
%
\begin{definition}
Let $(B, M_B, i_B)$ and $(B', M_{B'}, i_{B'})$ be computation objects, and let
$d : B \rel B'$ be an error domain relation. We say that $d$ is
\emph{quasi-right-representable} by an error domain morphism $p : B' \multimap B$ if
there are perturbations $\dellp_d \in M_B$ and $\delrp_d \in M_{B'}$ such that
the following two squares exist: 
(1) $\dnl$: $p \ltsq{\le_{B'}}{d} i_{B'}(\delrp_d)$ and
(2) $\dnr$: $i_B(\dellp_d) \ltsq{d}{\le_{B}} p$.
\end{definition}
%
We make the analogous definition of quasi-right-representability for predomain
relations $c$.

Given $(A, M_A, i_A)$ and $(A', M_{A'}, i_{A'})$, it makes sense to refer to the
quasi-representability of a predomain relation $c : A \rel A'$. However,
quasi-representable relations do not in general compose: in order to construct
the needed squares for the composition of two relations, we require that the
relations have push-pull structures.

We can now give the final definition of value and computation relations for our
model:
%
\begin{definition}[value relations]
A \textbf{value relation} between value objects $(A, M_A, i_A)$ and $(A',
M_{A'}, i_{A'})$ consists of a predomain relation $c : A \rel A'$ that has a
push-pull structure, is quasi-left-representable by a morphism $e_c : A \to A'$,
and is such that $\li c$ is quasi-right-representable by an error domain morphism
$p_c : \li A' \to \li A$.
\end{definition}

\begin{definition}[computation relations]
A \textbf{computation relation} between computation objects $(B, M_B, i_B)$ and
$(B', M_{B'}, i_{B'})$ consists of an error domain relation $d$ that has a
push-pull structure, is quasi-right-representable by a morphism $p_d : B' \to
B$, and is such that $Ud$ is quasi-left-representable by a morphism $e_d : UB
\to UB'$
\end{definition}

The reason for requiring $\li c$ to be quasi-right-representable in the
definition of value relations is so that we can define the action of the functor
$\li$ on relations, taking a value relation to a computation relation. Likewise,
we require $Ud$ to be quasi-left-representable in the definition of computation
relations so that we can define the action of $U$ on relations.

It remains to specify the actions of the functors on value and computation
objects and relations.
% Because we have augmented the definitions of object and relation for our model,
% we need to specify the actions of the functors $F$, $U$, $\times$, and $\arr$ on
% these objects and relations. 
% For instance, the functor $F$ now acts on \emph{value objects} $(A, M_A, i_A)$,
% which means we need to specify the monoid $M_{FA}$ and interpretation $i_{FA}$
% corresponding to the error domain $FA$.

\subsubsection{Constructions involving Perturbations}\label{sec:perturbation-constructions}

We first discuss the action of $\li$ on objects. Given a value object $(A, M_A,
i_A)$ we define the syntactic perturbations $M_{\li A}$ to be $\mathbb{N} \oplus
M_A$, where $\oplus$ denotes the free product of monoids (the coproduct in the
category of monoids). The intuition behind needing to include $\mathbb{N}$ comes
from the example of the downcast for $\iarr$. Recall that we adjusted the
squares corresponding to the DnL and DnR rules by adding $(\delta \circ
\eta)^\dagger$ on the side opposite the downcast. Thus, we need a syntactic
perturbation in $M_{\li A}$ that will be interpreted as $(\delta \circ
\eta)^\dagger$. We accomplish this by taking the coproduct with $\mathbb{N}$.
%
Then to interpret the perturbations as endomorphisms, by the universal property
of the coproduct of monoids it suffices to define two homomorphisms, one from
$\mathbb{N} \to \morbisimid{\li A}$ and one from $M_A \to \morbisimid{\li A}$.
The first homomorphism sends the generator $1 \in \mathbb{N}$ to the error
domain endomorpism $(\delta \circ \eta)^\dagger$, and the second sends $m_A \in
M_A$ to $\li(i_A(m_A))$ and we observe in both cases that the resulting
endomorphisms are bisimilar to the identity since the action of $\li$ on
morphisms preserves bisimilarity.

Now we discuss the action of $U$ on objects. Given a computation object $(B,
M_B, i_B)$, we define $M_{UB}$ to be $\mathbb{N} \oplus M_B$. The reason for
requiring $\mathbb{N}$ is related to the Kleisli arrow functor: to establish
quasi-representability of $U(c \arr d)$ given quasi-representability of $c$ and
$d$, we will need to turn a perturbation on $\li A$ into a perturbation on $U(A
\arr B)$. Since the perturbations for $\li A$ involve $\mathbb{N}$, so must the
perturbations for $UB$. The interpretation $i_{UB}$ of the perturbations on $UB$
works in the same manner as that of $\li A$.

The action of $\times$ on objects is as follows. Given $(A_1, M_{A_1}, i_{A_1})$
and $(A_2, M_{A_2}, i_{A_2})$, we define the monoid $M_{A_1 \times A_2} =
M_{A_1} \oplus M_{A_2}$. To construct the homomorphism $i_{A_1 \times A_2}$, we
appeal to the universal property and give homomorphisms $M_{A_1} \to
\morbisimid{A_1 \times A_2}$ and $M_{A_2} \to \morbisimid{A_1 \times A_2}$. The
former applies $i_{A_1}$ in the first component and the identity in the second
component, while the latter does the reverse with $i_{A_2}$.

The action of $\arr$ on objects is as follows. Given $(A, M_A, iA)$ and $(B,
M_B, i_B)$ we define the monoid $M_{A \arr B} = M_A^{op} \oplus M_B$. Then to
construct the interpretation as endomorphisms it suffices to define a
homomorphism $M_A^{op} \to \morbisimid{A \arr B}$ and $M_B \to \morbisimid{A
\arr B}$. The former takes an element $m_A$ and a predomain morphism $f : A \to
UB$ and returns the composition $f \circ i_A(m_A)$, while the latter is defined
similarly by post-composition with $i_B$.

\subsubsection{Constructions involving Value and Computation Relations}


\eric{What, if anything, should go here? Should we discuss composition of
value/computation relations? Actions of the functors on relations?}



\subsection{The Dynamic Type}
We now describe the denotation of the dynamic type. Analogously to how we
defined the dynamic type in Section \ref{sec:concrete-term-model}, the predomain
representing the dynamic type is defined using a combination of least fixpoint
and guarded recursion as the solution to the equation of \emph{predomains}
%
\[ D \cong \mathbb{N}\, + (D \times D)\, + \laterhs U(D \arr \li D). \]
%
As before, we name the constructors $\inat$, $\itimes$, and $\iarr$
respectively, and the upcasts $e_{\nat}$, $e_\times$, and $e_\to$ are the same
as the constructors except for $e_{\iarr}$ which includes a $\nxt$.

%
% We define $e_\mathbb{N} : \mathbb{N} \to D$ to be the $\text{nat}$ constructor,
% $e_\times : D \times D \to D$ to be $\text{times}$, and $e_\to : U(D \arr F D)$
% to be the morphism $\nxt$ followed by $\text{fun}$.

The ordering $\le_D$ is given by:
%
\begin{align*}
    \inat(n) \le \inat(n') 
        &\iff n = n' \\
    \itimes (d_1, d_2) \le \itimes (d_1', d_2')
        &\iff d_1 \le_D d_2 \text{ and } d_1' \le_D d_2'\\
    \iarr(\tilde{f}) \le \iarr(\tilde{f'}) 
        &\iff \later_t(\tilde{f}_t \le \tilde{f'}_t),
\end{align*}
%
and the bisimilarity relation is defined analogously.
%
We define three relations involving $D$ as follows. We define $\inat :
\mathbb{N} \rel D$ by $(n, d) \in \inat$ iff $e_\nat(n) \le_D d$. We similarly
define $\itimes : D \times D \rel D$ by $((d_1, d_2), d) \in \itimes$ iff
$e_\times(d_1, d_2) \le_D d$, and we define $\text{inj}_\to : U(D \arr \li D)
\rel D$ by $(f, d) \in \iarr$ iff $e_\to(f) \le_D d$.

Now we define the perturbations for $D$. Recall that to each predomain $A$ we
associate a monoid $M_A$ of perturbations and a homomorphism into the monoid of
endomorphisms bisimilar to the identity, and likewise for error domains. It may
seem as though we need to define the perturbations for $D$ by guarded recursion,
but in fact we define them via least-fixpoint in the category of monoids:
%
\( M_D \cong (M_{D \times D}) \oplus M_{U(D \to \li D)}. \)
%
We now explain how to interpret these perturbations as endomorphisms.

\eric{Check this}

We define $i_D : M_D \to \{ f : D \to D \mid f \bisim \id \}$ by induction as follows:
%
\begin{align*}
  i_D(m_\times) &= \lambda d. \text{case $d$ of }
    \{ \itimes (d_1, d_2) \To \itimes (i_{D \times D}(m_\times)(d_1, d_2)) \alt x \To x \} \\
  i_D(m_\to) &= \lambda d. \text{case $d$ of }
    \{ \iarr (\tilde{f}) \To \iarr (\lambda t. i_{U(D \to \li D)}(m_\to)(\tilde{f}_t)) \alt x \To x \} \\
\end{align*}
%
In the case of a perturbation on $D \times D$, we use the interpretation for the
perturbations of $D \times D$ as defined earlier in this section, which in turn
will use $i_D$ inductively. Similarly, for a perturbation on $U(D \to \li D)$ we
use the interpretation for perturbations on $U(D \to \li D)$.

% \begin{align*}
%  i_D(m_{\text{times}}, m_{\text{fun}}) &= \lambda d.\text{case $d$ of}  \\
%  &\alt \tnat(m) \mapsto \tnat(m) \\
%     &\alt \ttimes(d_1, d_2) \mapsto {\ttimes(i_{D \times D}(p_\text{times})(d_1, d_2))} \\
%     &\alt \tfun(\tilde{f}) \mapsto {\tfun(\lambda t. i_{U(D \to \li D)}(\tilde{f}_t))}
% \end{align*}
 
One can verify that this defines a homomorphism from $M_D \to \{ f : D \to D : f
\bisim \id \}$. We claim that the three relations $\inat$, $\itimes$, and
$\iarr$ satisfy the push-pull property. As an illustrative case, we establish
the push-pull property for the relation $\iarr$. We define $\pull_{\iarr} : M_D
\to M_{U(D \arr \li D)}$ by giving a homomorphism from $M_{D \times D} \to
M_{U(D \arr \li D)}$ and from $M_{U(D \to \li D)} \to M_{U(D \arr \li D)}$. The
former is the trivial homomorphism sending everything to the identity element,
while the latter is the identity homomorphism.
%
Conversely, we define $\push_{\iarr} : M_{U(D \arr \li D)} \to M_D$ as the
inclusion into the coproduct.
%
Showing that the relevant squares exist involving push and pull is
straightforward.

We next claim that the relations $\inat$, $\itimes$, and $\iarr$ are
quasi-left-representable, and that their lifts are quasi-right-representable.
Indeed, it is straightforward to see that they are quasi-left-representable
where all of the perturbations are taken to be the identity elements of the
respective monoids.
%
For quasi-right-representability, the only nontrivial case is $\li(\iarr)$.
Recall the defintion of the downcast for $\iarr$ given in Section
\ref{sec:term-interpretation}.

We know that in order for the DnR and DnL squares for $\li \iarr$ to exist, we
must insert a delay on the side opposite the downcast. In terms of syntactic
perturbations, this means that we take $\dellp$ and $\delrp$ in the definition
of quasi-right-representability to both be $\inl\, 1$, where $\inl$ is the
injection into the coproduct of monoids. We recall that the definition of
syntactic perturbations for $\li$ involves a coproduct with $\mathbb{N}$, and
that the interpretation homomorphism maps the generator $1$ to the endomorphism
of error domains $(\delta \circ \eta)^\dagger$.
%
With this choice for the perturbations, it is straightforward to show that the
DnL and DnR squares exist using the definition of the downcast and the
definition of the relation $\iarr$. 

It is also straightforward to establish the retraction property for each of
these three relations. In the case of $\iarr$, we have that the property holds
up to a delay.

\subsection{Interpreting Term Precision: Extensional Squares}

As introduced in the previous section, to obtain a model of term precision that
is oblivious to the stepping behavior of terms, we weaken our notion of square
to allow for the morphisms on either side to be synchronized to be in lock-step.
More formally, let $c_i : A_i \rel A_i'$ and $c_o : A_o \rel A_o'$.
%
% We define an extensional square between morphisms $f : A_i \to A_o$ and $g :
% A_i' \to A_o'$ to consist of:
%
% \begin{itemize}
%   \item A morphism $f' : A_i \to A_o$ with $f \bisim f'$.
%   \item A morphism $g' : A_i' \to A_o'$ with $g \bisim g'$.
%   \item A square $f' \ltsq{c_i}{c_o} g'$.
% \end{itemize}
%
We say that $f \ltsqbisim{c^i}{c_o} g$ if there exist $f'$ and $g'$ such that
%
\[ f \bisim f' \ltsq{c_i}{c_o} g' \bisim g. \]
%
We call a square $f \ltsqbisim{c^i}{c_o} g$ an \emph{extensional square}, and we
will call a square $f \ltsq{c^i}{c_o} g$ an \emph{intensional square}. If the
relations $c_i$ and $c_o$ are obvious from the context, we will simply write $f
\ltbisim g$. We make the analogous construction for the computation squares.
%
We now verify the existence of the squares for the cast rules. For UpL, the
relevant extensional square is obtained as follows:
%
% https://q.uiver.app/#q=WzAsNixbMCwwLCJBXzEiXSxbMSwwLCJBXzIiXSxbMiwwLCJBXzMiXSxbMCwxLCJBXzIiXSxbMSwxLCJBXzIiXSxbMiwxLCJBXzMiXSxbMCwzLCJlX2MiLDIseyJjdXJ2ZSI6MX1dLFsxLDQsIlxcZGVscmVfYyIsMl0sWzIsNSwiXFxwdXNoX3tjJ30oXFxkZWxyZV9jKSIsMix7ImN1cnZlIjoxfV0sWzAsMSwiYyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsMiwiYyciLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFszLDQsIlxcbGVfe0FfMn0iLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs0LDUsImMnIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiw1LCJcXGlkIiwwLHsiY3VydmUiOi0xfV0sWzAsMywiZV9jIiwwLHsiY3VydmUiOi0xfV0sWzgsMTMsIlxcYmlzaW0iLDEseyJzaG9ydGVuIjp7InNvdXJjZSI6MjAsInRhcmdldCI6MjB9LCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiwxNCwiXFxiaXNpbSIsMSx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\[\begin{tikzcd}[ampersand replacement=\&,column sep=large]
	{A_1} \& {A_2} \& {A_3} \\
	{A_2} \& {A_2} \& {A_3}
	\arrow["c", "\shortmid"{marking}, no head, from=1-1, to=1-2]
	\arrow[""{name=0, anchor=center, inner sep=0}, "{e_c}"', curve={height=6pt}, from=1-1, to=2-1]
	\arrow[""{name=1, anchor=center, inner sep=0}, "{e_c}", curve={height=-6pt}, from=1-1, to=2-1]
	\arrow["{c'}", "\shortmid"{marking}, no head, from=1-2, to=1-3]
	\arrow["{\delre_c}"', from=1-2, to=2-2]
	\arrow[""{name=2, anchor=center, inner sep=0}, "{\push_{c'}(\delre_c)}"', curve={height=6pt}, from=1-3, to=2-3]
	\arrow[""{name=3, anchor=center, inner sep=0}, "\id", curve={height=-6pt}, from=1-3, to=2-3]
	\arrow["{\le_{A_2}}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
	\arrow["{c'}"', "\shortmid"{marking}, no head, from=2-2, to=2-3]
	\arrow["\bisim"{description}, draw=none, from=0, to=1]
	\arrow["\bisim"{description}, draw=none, from=2, to=3]
\end{tikzcd}\]
%
% Note that the horizontal composition of the squares is defined, as they are
% intensional squares.
We have used the push-pull structure on $c'$ to turn the perturbation on $A_2$
into a perturbation on $A_3$. Lastly we note that the bottom edge of the square
is equal to $c'$ by the fact that $c'$ is downward closed. The squares for UpR,
DnL, and DnR are obtained similarly.

% Now that we have defined an intensional model with an interpretation for the
% dynamic type, we can apply the abstract constructions introduced in Section
% \ref{sec:extensional-model-construction}. Doing so, we obtain an extensional
% model of gradual typing, where the squares are given by the ``bisimilarity
% closure'' of the intensional error ordering.

\eric{TODO: Does this belong here?}

Recall the equivalence rules for type precision given in Section \ref{sec:GTLC},
for example the rule that $(c_i \ra c_o)(c_i' \ra c_o')\equiv (c_ic_i' \ra
c_oc_o')$ To validate this rule in the model, we construct two squares $\id
\ltsqbisim{(c_i \ra c_o)(c_i' \ra c_o')}{(c_ic_i' \ra c_oc_o')} \id$ and $\id
\ltsqbisim{(c_ic_i' \ra c_oc_o')}{(c_i \ra c_o)(c_i' \ra c_o')} \id$. Since the
definition of extensional square allows us to specify intermediate morphisms
that are synchronized in the lock-step error ordering, it will be sufficient to
construct two intensional squares involving perturbations on both sides. This
motivates the definition of \emph{quasi-order-equivalence}.

\begin{definition}[quasi-order-equivalence]\label{def:quasi-order-equivalent}
  Let $c, c' : A \rel A'$. We say that $c$ and $c'$ are
  \textbf{quasi-order-equivalent}, written $c \qordeq c'$, if there exist
  perturbations $\delta^l_1, \delta^l_2 \in \pv_A$ and $\delta^r_1, \delta^r_2
  \in \pv_{A'}$ such that there is a square $\delta^l_1 \ltsq{c}{c'} \delta^r_1$
  and a square $\delta^l_2 \ltsq{c'}{c} \delta^r_2$.
\end{definition}
We make the analogous definition for error domain relations $d, d' : B \rel B'$.

Then we have the following result that shows that the functors
$U,\li,\times,\to$ are \emph{quasi-functorial} on relations:

\begin{lemma}
\begin{itemize}
  \item $U(d \comp d') \qordeq U(d) \comp U(d')$
  \item $F(c \comp c') \qordeq F(c) \comp F(c')$
  \item $(c \comp c') \to (d \comp d') \qordeq (c \to d) \comp (c' \to d')$
  \item $(c_1 \comp c_1') \times (c_2 \comp c_2') \qordeq (c_1 \times c_2) \comp (c_1'\times c_2')$
\end{itemize}
\end{lemma}
\begin{proof} See appendix \eric{TODO: make sure this is in the appendix}
\end{proof}


\subsection{Relational Adequacy}\label{sec:adequacy}

In this section, we prove the adequacy of the interpretation of term precision.
First we establish some notation. Fix a morphism $f : 1 \to \li \mathbb{N} \cong
\li \mathbb{N}$. We write $f \da n$ to mean that there exists $m$ such that $f =
\delta^m(\eta n)$ and $f \da \mho$ to mean that there exists $m$ such that $f =
\delta^m(\mho)$.

Recall that $\ltbisim$ denotes the relation on value morphisms defined as the
closure of the intensional error-ordering on morphisms under weak bisimilarity
on bboth sides. Specialized to the setting of morphisms from $1 \to U \li
\mathbb{N}$, we have $f \ltbisim g$ iff there exist $f'$ and $g'$ with
%
\[ f \bisim_{\li \mathbb{N}} f' \le_{\li \mathbb{N}} g' \bisim_{\li \mathbb{N}} g. \]
%

We first note that in this ordering, the semantics of error is not equivalent to
the semantics of the diverging term. The main result we would like to show is as
follows: If $f \ltbisim g : \li \mathbb{N}$, then:
\begin{itemize}
  \item If $f \da n$ then $g \da n$.
  \item If $g \da \mho$ then $f \da \mho$.
  \item If $g \da n$ then $f \da n$ or $f \da \mho$.
\end{itemize}

%
Unfortunately, this is actually not provable! Roughly speaking, the issue is
that this is a ``global'' result, and it is not possible to prove such results
in the guarded setting. In particular, if we tried to prove the above result in
the guarded setting we would run into a problem where we would have a natural
number ``stuck'' under a $\later$, with no way to get out the underlying number.
%
Thus, to prove our adequacy result, we need to pass to leave the guarded
setting. We have seen in Section \ref{sec:big-step-term-semantics} that clock
quantification makes this possible.

Recall that the definitions of our model, e.g., the free error domain, the
lock-step ordering, and weak bisimilarity, have all been parameterized by a
clock $k$. We saw in previously that there is an isomorphism between the
globalization of the free error domain and Capretta's coinductive delay monad:
$\li^{gl} \mathbb{N} \cong \delay(\mathbb{N} + {\mho})$.

Now consider the predomain $\mathbb{N}$ with ordering and bisimilarity both the
equality relation. We can define a ``global'' version of the lock-step error
ordering and the weak bisimilarity relation on elements of the $\li^{gl}
\mathbb{N}$; the former is defined by
%
\( x \ltls^{gl}_X y := \forall k. x[k] \ltls y[k], \)
%
and the latter is defined by
%
\( x \bisim^{gl}_X y := \forall k. x[k] \bisim y[k]. \)
%
On the other hand, we can define coinductively a ``lock-step error ordering''
relation on $\delay(\mathbb{N} + {\mho})$:
%
\begin{mathpar}
  \inferrule*[]
  { }
  {\tnow (\inr\, 1) \ledelay d}

  \inferrule*[]
  {x_1 \le_X x_2}
  {\tnow (\inl\, x_1) \ledelay \tnow (\inl\, x_2)}

  \inferrule*[]
  {d_1 \ledelay d_2}
  {\tlater\, d_1 \ledelay \tlater\, d_2}
\end{mathpar}
%
And we similarly define by coinduction a ``weak bisimilarity'' relation on
$\delay(\mathbb{N} + {\mho})$. This uses a relation $d \Da x_?$ between
$\delay(\mathbb{N} + {\mho})$ and $\mathbb{N} + {\mho}$ that is defined as $d
\Da n_? := \Sigma_{i \in \mathbb{N}} d = \tlater^i(\tnow\, n_?)$. Then weak
bisimilarity for the delay monad is defined coinductively by the rules
%
\begin{mathpar}
  \inferrule*[]
  {n_? \bisim_{\mathbb{N} + {\mho}} m_?}
  {\tnow\, n_? \bisimdelay \tnow\, m_? }

  \inferrule*[leftskip=1.5em]
  {d_1 \Da n_? \and n_? \bisim_{\mathbb{N} + {\mho}} m_?}
  {\tlater\, d_1 \bisimdelay \tnow\, m_? }

  \inferrule*[leftskip=1.5em]
  {d_2 \Da m_? \and n_? \bisim_{\mathbb{N} + {\mho}} m_?}
  {\tnow\, n_? \bisimdelay \tlater\, d_2}

  \inferrule*[leftskip=1.5em]
  {d_1 \bisimdelay d_2}
  {\tlater\, d_1 \bisimdelay \tlater\, d_2 }
  %
  % \inferrule*[]
  % {d_1 \Da x_? \and d_2 \Da y_? \and x_? \bisim_{X + 1} y_?}
  % {d_1 \bisimdelay d_2}
  %
  % \inferrule*[]
  % {d_1 \bisimdelay d_2}
  % {\tlater d_1 \bisimdelay \tlater d_2 }
\end{mathpar}
%
Note the similarity of these definitions to the corresponding guarded
definitions. By adapting Theorem 4.3 of \cite{kristensen-mogelberg-vezzosi2022}
to the setting of inductively-defined relations, we can show that both the
global lock-step error ordering and the global weak bisimilarity admit
coinductive definitions. In particular, modulo the above isomorphism between
$\li^{gl} X$ and $\delay(\mathbb{N} + {\mho})$, the global version of the
lock-step error ordering is equivalent to the lock-step error ordering on
$\delay(\mathbb{N} + {\mho})$, and likewise, the global version of the weak
bisimilarity relation is equivalent to the weak bisimilarity relation on
$\delay(\mathbb{N} + {\mho})$.

This implies that the global version of the term precision semantics for
$\li^{gl} \mathbb{N}$ agrees with the corresponding notion for
$\delay(\mathbb{N} + {\mho})$. Then adequacy follows by proving the
corresponding result for $\delay(\mathbb{N} + {\mho})$ which in turn follows
from the definitions of the relations.


% We have been writing the type as $\li X$, but it is perhaps more accurate to write it as $\li^k X$ to
% emphasize that the construction is parameterized by a clock $k$.

% Need : nat is clock irrelevant, as well as the inputs and outputs of effects
% Axioms about forcing clock
% Adapt prior argument to get that the defining of the global bisim
% and global lock-step error ordering are coinductive
