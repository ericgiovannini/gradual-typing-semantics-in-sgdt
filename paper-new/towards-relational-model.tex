\section{Challenges to a Guarded Model of Graduality}\label{sec:towards-relational-model}

% In the previous section, we gave a denotational semantics to the terms of the
% gradually-typed lambda calculus using the tools of SGDT. We defined a big-step
% semantics for closed terms of type $\nat$, as functions from $\mathbb{N} \to
% ((\mathbb{N} + 1) + 1)$.

Now that we have seen how to model the terms without regards to
graduality, we next turn to how to enhance this model to provide a
compositional semantics that additionally satisfies graduality. By a
compositional semantics, we mean that we want to provide a
compositional interpretation of \emph{type} and \emph{term precision}
such that we can extract the graduality relation from our model of
term precision.

\subsection{A first attempt: Modeling Term Precision with Posets}

In prior work, New and Licata model the term precision relation by
equipping $\omega$-CPOs with a second ordering $\ltdyn$ they call the
``error ordering'' such that a term precision relationship at a fixed
type $M \ltdyn M' : r(A)$ implies the error ordering $\sem{M} \ltdyn
\sem{M'}$ in the semantics. Then the error ordering on the free error
domain $\li A$ is based on the graduality property: essentially either
$\sem{M}$ errors or both terms diverge or both terms terminate with
values related by the ordering relation on $A$.
%
The obvious first try at a guarded semantics that models graduality
would be to similarly enhance our value types and computation types to
additionally carry a poset structure. For most type formers this
ordering can be defined as lifting poset structures on the
subformulae; the key design choice is in the ordering on the free
error domain $\li A$.

The ordering on $\li A$ should model the graduality property, but how
to interpret this is not so straightforward. The graduality property
as stated mentions divergence, but we only work indirectly with
diverging computations in the form of the think maps. The closest
direct encoding of the graduality property is an ordering we call the
\emph{step-insensitive error ordering}, defined by guarded recursion
in Figure~\ref{fig:step-insensitive-error-ordering}.
%
Firstly, to model graduality, $\mho$ is the least element. Next, two
returned values are related just when they are in the ordering $\ltdyn$
on $A$.
%
Two thinking elements are related just when they are related later.
%
The interesting cases are then those where one side is thinking and
the other has completed to either an error or a value.
%
Since the graduality property is \emph{extensional}, i.e., oblivious
to the number of steps taken, it is sensible to say that if one side
has terminated and the other side is thinking, that we must require
the thinking side to eventually terminate with a related behavior,
which is the content of the final three cases of the definition.
\begin{figure*}
      \begin{align*}
        \mho \semltbad l &\text{ iff } \top \\
        %
        \eta\, x \semltbad \eta\, y &\text{ iff } 
            x \ltdyn y \\
        %		
        \theta\, \tilde{l} \semltbad \theta\, \tilde{l'} &\text{ iff } 
            \later_t (\tilde{l}_t \semltbad \tilde{l'}_t) \\
        %	
        \theta\, \tilde{l} \semltbad \mho &\text{ iff } \exists n. \theta\, \tilde{l} = \delta^n(\mho) \\
        %	
        \theta\, \tilde{l} \semltbad \eta\, y &\text{ iff } \exists n. \exists x \ltdyn y.
            (\theta\, \tilde{l} = \delta^n(\eta\, x)) \\
        %	
        \eta\, x \semltbad \theta\, \tilde{l'} &\text { iff }
            \exists n. \exists y \gtdyn x. (\theta\, \tilde{l'} = \delta^n (\eta\, y))
    \end{align*}
    \caption{Step-insensitive error ordering}
    \label{fig:step-insensitive-error-ordering}
\end{figure*}

This definition of $\semltbad$ is sufficient to model the graduality
property in that if $l \semltbad l'$ for $l,l' : \li \mathbb{N}$ where
$\mathbb{N}$ is the flat poset whose ordering is equality, then the
big-step semantics we derive for $l, l'$ does in fact satisfy the
intended graduality relation.
%
However, there is a major issue with this definition: it's not a poset
at all: it is not anti-symmetric, but more importantly it is
\emph{not} transitive!
%
To see why, we observe the following undesirable property of any
relation that is transitive and ``step-insensitive'' on one side:
\begin{theorem}\label{thm:no-go}
  Let $R$ be a binary relation on the free error domain $U(\li A)$. If
  $R$ satisfies the following properties
  \begin{enumerate}
  \item Transitivity
  \item $\theta$-congruence: If $\later_t (\tilde{x}_t \binrel{R} \tilde{y}_t)$, then $\theta(\tilde{x}) \binrel{R} \theta(\tilde{y})$.
  \item Right step-insensitivity: If $x \binrel{R} y$ then $x \binrel{R} \delta y$.
  \end{enumerate}
  Then for any $l : U(\li A)$, we have $l \binrel{R} \Omega$. If $R$ is left
  step-insensitive instead then $\Omega \binrel{R} x$.
\end{theorem}
\begin{proof}
  By L\"ob induction, in the appendix.
\end{proof}
\begin{corollary}
  Let $R$ be a binary relation on $U(\li A)$. If $R$ satisfies
  transitivity, $\theta$-congruence and left and right
  step-insensitivity, then $R$ is the total relation: $\forall x, y. x
  \binrel{R} y$.
\end{corollary}
\begin{proof}
  $x \binrel{R} \Omega$ and $\Omega \binrel{R} y$ by the previous
  theorem. Then by transitivity $x \binrel R y$.
\end{proof}

This in turn implies $\semltbad$ is not transitive, since it is a
$\theta$-congruence and step-insensitive on both sides, but not
trivial: e.g., for the flat poset on $\mathbb N$, $\eta 0 \semltbad
\eta 1$ is false.
%
This shows definitively that we cannot provide a compositional
semantic graduality proof based on types as posets if we use this
step-insensitive ordering on $\li A$.

\subsection{Why transitivity is essential}

At this point we might try to weaken from our initial attempt at
providing a poset semantics to a semantics where types are equipped
with merely a reflexive relation, and continue using the
step-insensitive ordering. However, some level of transitivity is
absolutely essential to providing compositional reasoning, and
transitivity is used pervasively in the prior work by New and Licata.
%
The reason that it is essential becomes clear by examining the details of the
graduality proof, so first we expand on how we prove graduality compositionally.
First, we need to extend our compositional semantics of types and terms to a
compositional semantics of \emph{type precision derivations} and \emph{term
precision}.
%
Sticking to a poset-based semantics, if our value types are interpreted as
posets, then we want our precision derivations $c : A \ltdyn A'$ to be
interpreted as a \emph{relation} between $A$ and $A'$. It is also natural to
ask that the relation $c$ interact with the orderings on $A$ and $A'$. More
specifically, if $x' \ltdyn_{A} x$ and $x \mathrel{c} y$, then $x' \mathrel{c}
y$. Similarly, if $x \mathrel{c} y$ and $y \ltdyn_{A'} y'$, then $x \mathrel{c}
y'$. We summarize this requirement by saying $c$ is \emph{downward-closed} in
$A$ and $\emph{upward-closed}$ in $A'$. We will see below why this requirement
is necessary for the graduality proof.

% ...we then want our precision derivations $c : A \ltdyn A'$ to be \emph{poset relations} on $A,
% A'$, that is, relations between the underlying sets of $A, A'$ that are
% \emph{downward-closed} in $A$ and \emph{upward-closed} in $A'$.
% The former means that if $x' \ltdyn_{A} x$ and $x \mathrel{c} y$, then $x' \mathrel{c} y$,
% while the latter says that if $x \mathrel{c} y$ and $y \ltdyn_{A'} y'$, then $x \mathrel{c} y'$.

We call such a relation between $A$ and $A'$ a \emph{poset relation}, and we
write $c : A \rel A'$. The paradigmatic example of a poset relation is the poset
ordering itself, $\ltdyn_A : A \rel A$, which is a poset relation because it is
transitive.

%
Given two poset relations $c : A_1 \rel A_2$ and $c' : A_2 \rel A_3$, we can
form their \emph{composition} in the usual manner, i.e., $x \binrel{c \comp c'} y$ if and
only if there is an element $z : A_2$ with $x \binrel{c} z$ and $z \binrel{c'} y$.
%We write the composition of relations as $c \comp c'$.

% \max{TODO: Eric pick
%   up from here. Go into the squares for casts and how representability
%   gives us a compositional approach to proving them}

% \eric{Picked up here; Max, please read this.}

These relations are then used to model term precision. For closed programs $M \ltdyn M' :
c$ where $c : A \ltdyn A'$, the terms denote elements of the
free error domain $\sem{M},\sem{M'} : U\li \sem{A}$, and we model the term precision semantically as the relation holding between those denoted elements $\sem{M} \binrel{(U\li\sem{c})} \sem{M'}$ where
$U\li\sem{c}$ is a relational lifting of $U\circ\li$.
%
More generally, $M$ and $M'$ can be \emph{open} terms, in which case
they denote functions, not just elements. We model that as not simply
elements being related but in a typical logical-relations style as
\emph{preserving} relatedness: if they are passed in inputs related by
the domain relations then their output is related by the codomain
relation.
%
To capture this preservation of relations property, we use the notion of a
\emph{square}, which specifies a relation between two monotone functions. The
definition of square is as follows. Let $A_i, A_o, A_i', A_o'$ be
partially-ordered sets. Let $c_i : A_i \rel A_i'$ and $c_o : A_o \rel A_o'$ be
poset relations, and let $f : A_i \to A_o$ and $g : A_i' \to A_o'$ be monotone
functions. We say that $f \ltsq{c_i}{c_o} g$ if for all $x : A_i$ and $y : A_i'$
with $x \binrel{c_i} y$, we have $f(x) \binrel{c_o} g(y)$. We call this a
\emph{square} because we visualize this situation as follows:
%
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJBX2kiXSxbMCwxLCJBX28iXSxbMSwwLCJBX2knIl0sWzEsMSwiQV9vJyJdLFsyLDMsImciXSxbMCwxLCJmIiwyXSxbMCwyLCJjX2kiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxLDMsImNfbyIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
\[\begin{tikzcd}[ampersand replacement=\&]
  {A_i} \& {A_i'} \\
  {A_o} \& {A_o'}
  \arrow["{c_i}", "\shortmid"{marking}, no head, from=1-1, to=1-2]
  \arrow["f"', from=1-1, to=2-1]
  \arrow["g", from=1-2, to=2-2]
  \arrow["{c_o}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
\end{tikzcd}\]
%
Squares are then used to model the term precision ordering in that
$\Delta \vdash M \ltdyn N : c$ implies $\sem{M}
\ltsq{\sem{\Delta}}{U\li\sem{c}} \sem{N}$ where here $\sem{\Delta =
  x_1:c_1,\ldots}$ is the action of the product on the relations
$c_1,\ldots$.

%% % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXEdhbW1hIl0sWzAsMSwiVVxcbGkgQSJdLFsxLDAsIlxcR2FtbWEnIl0sWzEsMSwiVVxcbGkgQSciXSxbMiwzLCJcXHNlbXtOfSJdLFswLDEsIlxcc2Vte019IiwyXSxbMCwyLCJcXEdhbW1hXntcXGx0ZHlufSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsMywiVVxcbGkgYyIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
%% \[\begin{tikzcd}[ampersand replacement=\&]
%% 	\Gamma \& {\Gamma'} \\
%% 	{U\li A} \& {U\li A'}
%% 	\arrow["{\Gamma^{\ltdyn}}", "\shortmid"{marking}, no head, from=1-1, to=1-2]
%% 	\arrow["{\sem{M}}"', from=1-1, to=2-1]
%% 	\arrow["{\sem{N}}", from=1-2, to=2-2]
%% 	\arrow["{U\li c}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
%% \end{tikzcd}\]

% \max{This needs to also talk about relational composition and horizontal pasting squares, since that's transitivity!}
We note that for any $c$, there is a ``vertical identity'' square $\id
\ltsq{c}{c} \id$, as can be seen by unfolding the
definition. Similarly, for any monotone function $f : A_i \to A_o$,
there is a ``horizontal identity'' square $f
\ltsq{\le_{A_i}}{\le_{A_o}} f$ arising from the fact that $f$ is
monotone.
%
We can \emph{compose} squares vertically, i.e., if we have $f
\ltsq{c_1}{c_2} f'$ and $g \ltsq{c_2}{c_3} g'$ then we obtain a square
$g \circ f \ltsq{c_1}{c_3} g' \circ f'$. Likewise, we can compose
squares horizontally: If $f \ltsq{c_i}{c_o} g$ and $g
\ltsq{c_i'}{c_o'} h$, then we obtain a square $f \ltsq{c_i \comp
  c_i'}{c_o \comp c_o'} h$. Horizontal composition of squares
corresponds to transitivity of term precision. While we do not dwell
on categorical abstractions in this work, we note that this structure
of functions, relations and squares forms a locally thin \emph{double
category} as used in previous work \cite{new-licata18}.

Now that we have an intended model of term precision in the form of
squares, we can see what is required to give a compositional proof of
graduality. Most of the cases of term precision are just congruence
and follow easily. The core of the proof of the graduality property is
in proving the validity of the \emph{cast rules} UpL, UpR, DnL and
DnR.
%
These rules specify a relationship between the semantics of type
precision derivations $c$ and the corresponding casts $\upc c, \dnc c$ (see Section
\ref{sec:GTLC}).
%
To prove graduality compositionally then, we will need to codify in an
extra property on $\sem{c}$ that the relation $\sem{c}$ has some
correspondence with the casts $\sem{\upc c}, \sem{\dnc c}$.
%
What property should we require?

Consider the UpL rule. It states that if
$c : A_1 \ltdyn A_2$ and $c' : A_2 \ltdyn A_3$ and $M : A_1$ is
related to $N : A_3$ via the composition $c \comp c'$, then the upcast
$\upc{c} M$ is related to $N$ via $c'$. Since the upcasts are pure
functions in the semantics this can be deduced from the existence of
the following square, where the relation on the top is $\sem{c} \comp \sem{c'}$:
% \max{the square doesn't make sense because we
%   haven't discussed horizontal composition of relations or that this
%   notation means horizontal composition of relations}
%
% https://q.uiver.app/#q=WzAsNSxbMCwwLCJBXzEiXSxbMSwwLCJBXzIiXSxbMiwwLCJBXzMiXSxbMCwxLCJBXzIiXSxbMiwxLCJBXzMiXSxbMyw0LCJjJyIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsMywiXFx1cGN7Y30iLDJdLFsyLDQsIlxcaWQiXSxbMCwxLCJjIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwyLCJjJyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
\[\begin{tikzcd}[ampersand replacement=\&]
  {\sem{A_1}} \& {\sem{A_2}} \& {\sem{A_3}} \\
  {\sem{A_2}} \&\& {\sem{A_3}}
  \arrow["\sem{c}", "\shortmid"{marking}, no head, from=1-1, to=1-2]
  \arrow["{\sem{\upc{c}}}"', from=1-1, to=2-1]
  \arrow["{\sem{c'}}", "\shortmid"{marking}, no head, from=1-2, to=1-3]
  \arrow["\id", from=1-3, to=2-3]
  \arrow["{\sem{c'}}"', "\shortmid"{marking}, no head, from=2-1, to=2-3]
\end{tikzcd}\]
While at first look this seems to be specifying a relationship between
$\sem{c}$ and $\sem{\upc c}$, there is a problem: it also quantifies
involves an arbitrary other relation $\sem{c'}$! This means we cannot
require the existence of this square as part of the definition of a
relation between value types, as it is self-referential. This would
seem to imply that we cannot give a compositional model for
graduality. However, New and Licata observed that in the presence of
transitivity, we can \emph{derive} the above squares from simpler ones
that do not involve composition of relations. Below are the simpler squares
corresponding to UpL, UpR, DnL, and DnR:
\begin{center}
  \begin{tabular}{ c | c | c | c} 
    % UpL
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJBXzEiXSxbMCwxLCJBXzIiXSxbMSwwLCJBXzIiXSxbMSwxLCJBXzIiXSxbMCwyLCJjIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJcXGx0ZHluX3tBXzJ9IiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMCwxLCJcXHVwY3tjfSIsMl0sWzIsMywiXFxpZCJdLFs2LDcsIlxcdGV4dHtVcEx9IiwzLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
    \begin{tikzcd}[ampersand replacement=\&]
      {A_1} \& {A_2} \\
      {A_2} \& {A_2}
      \arrow["c", "\shortmid"{marking}, no head, from=1-1, to=1-2]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\upc{c}}"', from=1-1, to=2-1]
      \arrow[""{name=1, anchor=center, inner sep=0}, "\id", from=1-2, to=2-2]
      \arrow["{\ltdyn_{A_2}}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
      \arrow["{\text{UpL}}"{marking, allow upside down}, draw=none, from=0, to=1]
  \end{tikzcd} &
    %
    % UpR
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJBXzEiXSxbMCwxLCJBXzEiXSxbMSwwLCJBXzEiXSxbMSwxLCJBXzIiXSxbMCwyLCJcXGx0ZHluX3tBXzF9IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJjIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMCwxLCJcXGlkIiwyXSxbMiwzLCJcXHVwYyBjIl0sWzYsNywiXFx0ZXh0e1VwUn0iLDMseyJzaG9ydGVuIjp7InNvdXJjZSI6MjAsInRhcmdldCI6MjB9LCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
    \begin{tikzcd}[ampersand replacement=\&]
      {A_1} \& {A_1} \\
      {A_1} \& {A_2}
      \arrow["{\ltdyn_{A_1}}", "\shortmid"{marking}, no head, from=1-1, to=1-2]
      \arrow[""{name=0, anchor=center, inner sep=0}, "\id"', from=1-1, to=2-1]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{\upc c}", from=1-2, to=2-2]
      \arrow["c"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
      \arrow["{\text{UpR}}"{marking, allow upside down}, draw=none, from=0, to=1]
    \end{tikzcd} &
    %
    %
    %
    % DnL
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJBXzIiXSxbMCwxLCJBXzEiXSxbMSwwLCJBXzIiXSxbMSwxLCJBXzIiXSxbMCwyLCJcXGx0ZHluX3tBXzJ9IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJjIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMCwxLCJcXGRuYyBjIiwyXSxbMiwzLCJcXGlkIl0sWzYsNywiXFx0ZXh0e0RuTH0iLDMseyJzaG9ydGVuIjp7InNvdXJjZSI6MjAsInRhcmdldCI6MjB9LCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
    \begin{tikzcd}[ampersand replacement=\&]
      {A_2} \& {A_2} \\
      {A_1} \& {A_2}
      \arrow["{\ltdyn_{A_2}}", "\shortmid"{marking}, no head, from=1-1, to=1-2]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\dnc c}"', from=1-1, to=2-1]
      \arrow[""{name=1, anchor=center, inner sep=0}, "\id", from=1-2, to=2-2]
      \arrow["c"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
      \arrow["{\text{DnL}}"{marking, allow upside down}, draw=none, from=0, to=1]
    \end{tikzcd} &
    %
    % DnR
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJBXzEiXSxbMCwxLCJBXzEiXSxbMSwwLCJBXzIiXSxbMSwxLCJBXzEiXSxbMCwyLCJjIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwzLCJcXGx0ZHluX3tBXzF9IiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMCwxLCJcXGlkIiwyXSxbMiwzLCJcXGRuYyBjIl0sWzYsNywiXFx0ZXh0e0RuUn0iLDMseyJzaG9ydGVuIjp7InNvdXJjZSI6MjAsInRhcmdldCI6MjB9LCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
    \begin{tikzcd}[ampersand replacement=\&]
      {A_1} \& {A_2} \\
      {A_1} \& {A_1}
      \arrow["c", "\shortmid"{marking}, no head, from=1-1, to=1-2]
      \arrow[""{name=0, anchor=center, inner sep=0}, "\id"', from=1-1, to=2-1]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{\dnc c}", from=1-2, to=2-2]
      \arrow["{\ltdyn_{A_1}}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
      \arrow["{\text{DnR}}"{marking, allow upside down}, draw=none, from=0, to=1]
    \end{tikzcd}
  \end{tabular}
\end{center}
%
These squares say that the relation $c$ is \emph{representable} by the upcast
morphism $\upc{c}$, essentially that the relation is a kind of \emph{graph} of
the function in that $x \binrel{\sem c} y$ if and only if $\sem{\upc c}(x)
\leq_{A_2} y$ \cite{shulman2007}.

We can use the simpler UpL square to derive the original UpL square by
horizontally composing with the identity square for $c'$:
%
% https://q.uiver.app/#q=WzAsNixbMCwwLCJBXzEiXSxbMSwwLCJBXzIiXSxbMiwwLCJBXzMiXSxbMCwxLCJBXzIiXSxbMiwxLCJBXzMiXSxbMSwxLCJBXzIiXSxbMCwxLCJjIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiYmFycmVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSwyLCJjJyIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzMsNSwiXFxsdGR5bl97QV8yfSIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImJhcnJlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzUsNCwiYyciLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDMsIlxcdXBje2N9IiwyXSxbMiw0LCJcXGlkIl0sWzEsNSwiXFxpZCIsMl1d
\[\begin{tikzcd}[ampersand replacement=\&]
	{A_1} \& {A_2} \& {A_3} \\
	{A_2} \& {A_2} \& {A_3}
	\arrow["c", "\shortmid"{marking}, no head, from=1-1, to=1-2]
	\arrow["{\upc{c}}"', from=1-1, to=2-1]
	\arrow["{c'}", "\shortmid"{marking}, no head, from=1-2, to=1-3]
	\arrow["\id"', from=1-2, to=2-2]
	\arrow["\id", from=1-3, to=2-3]
	\arrow["{\ltdyn_{A_2}}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
	\arrow["{c'}"', "\shortmid"{marking}, no head, from=2-2, to=2-3]
\end{tikzcd}\]
%
Then to complete the proof, we observe that the composition of $\ltdyn_{A_2}$ with $c'$ is equal to
$c'$, because $c'$ is \emph{downward-closed} under the relation on $A_2$.
An analogous argument shows that we can derive the original UpR square from the simpler version of UpR,
this time using the fact that poset relations are \emph{upward-closed}.
% Thus, we
% obtain the original UpL square by vertically composing the square shown above
% with the square $\id \ltsq{\le_{A_2}\, c'}{c'} \id$ on the bottom.

To recap, we have shown that in order to carry out the graduality proof
compositionally, we need that the relations are closed under the ordering on
each side. In particular, this implies that the ordering relations $\ltdyn_{A}$
must be transitive. Thus, we cannot entirely drop posets from our semantics.

% The actual place where transitivity of the relations on the value types is
% needed in this argument occurs when $A_3 = A_2$ and we take $c'$ to be
% $\ltdyn_{A_2}$ (recall that $c'$ is universally quantified, so it can be any
% relation). The fact that $\ltdyn_{A_2}$ is downward-closed is equivalent to it
% being transitive. In other words, the relations $\ltdyn_A$ on value types must be
% poset relations in order to carry out the above compositional construction.

% So we see that in order to get a sensible condition that can give us a
% compositional definition of a well-behaved relation, some amount of
% transitive reasoning on squares is required, and so we cannot entirely
% drop posets from our semantics.

\subsection{Resolution: Splitting Error Ordering and Bisimilarity}\label{sec:lock-step-and-weak-bisim}

Given that some amount of transitive reasoning is essential for
modeling type and term precision compositionally, we need to revisit
our ordering relation on $\li A$ to get one that is
transitive. Theorem \ref{thm:no-go} tells us, however, that any non-trivial such
relation must either not be a congruence with respect to $\theta$, or
must not be left- and right-step-insensitive.
\footnote{Technically, the theorem only implies that we need to drop
one of left- or right-step-insensitivity. We might then attempt
to work with two separate ``step-semi-sensitive'' relations on $\li
A$, each closed under delays on the left and right respectively. This
has some similarities to prior work on logical relations models
\cite{new-licata-ahmed2019,new-giovannini-licata-2022}, but we do not take this
approach because the relations still do not seem to be provably
transitive, though we have not been able to prove that they are not
transitive either.}
% \max{Eric check if this footnote is correct}}
%
We cannot forego the property of being a $\theta$-congruence, as
without this we would not be able to prove basic properties of the
relation using \lob-induction, e.g., that the extension $f^\dagger$ is
\emph{monotone}, which is used pervasively in the proof of graduality.
%
Thus, we choose to sacrifice left and right step-insensitivity. That
is, we will define an ordering relation that requires terms to be in
``lock-step''. In order for two computations to be related in this
ordering, they must have the exact same stepping behavior
(unless/until the left-hand side results in an error).

More formally, we define the \emph{lock-step error-ordering}, with the idea
being that two computations $l$ and $l'$ are related if they are in lock-step
with regard to their intensional behavior, up to $l$ erroring. Figure
\ref{fig:lock-step-error-ordering} gives the definition of this relation.

\begin{figure}
  \begin{minipage}{0.5\textwidth}
    \fbox{$l_1 \ltls l_2$}
    \begin{align*}
        &\eta\, x \ltls \eta\, y \text{ if } 
            x \mathbin{\ltdyn_A} y \\
        %		
        &\mho \ltls l' \\
        %
        &\theta\, \tilde{l} \ltls \theta\, \tilde{l'} \text{ if } 
            \later_t (\tilde{l}_t \ltls \tilde{l'}_t)
  \end{align*}\end{minipage}\begin{minipage}{0.5\textwidth}
\fbox{$l_1 \bisim l_2$}
    \begin{align*}
        \mho \bisim \mho &\text{ iff } \top \\
      %
        \eta\, x \bisim \eta\, y &\text{ iff } x \bisim_A y \\
      %		
        \theta\, \tilde{x} \bisim \theta\, \tilde{y} &\text{ iff } \later_t (\tilde{x}_t \bisim \tilde{y}_t) \\
      %	
        \theta\, \tilde{x} \bisim \mho &\text{ iff } \exists n. \theta\, \tilde{x} = \delta^n(\mho)\\
      %	
        \theta\, \tilde{x} \bisim \eta\, y &\text{ iff } \exists n. \exists x \bisim_A y.
          (\theta\, \tilde{x} = \delta^n(\eta\, x))\\
      %
        \mho \bisim \theta\, \tilde{y} &\text{ iff } \exists n. \theta\, \tilde{y} = \delta^n(\mho) \\
      %	
        \eta\, x \bisim \theta\, \tilde{y} &\text { iff } \exists n. \exists y \bisim_A x. (\theta\, \tilde{y} = \delta^n (\eta\, y))
      \end{align*}
  \end{minipage}
    \caption{lock-step error ordering and weak bisimilarity}
    \label{fig:lock-step-error-ordering}
\end{figure}

When both sides are $\eta$, then we check that the returned values are related
in $\ltdyn_A$. The error term $\mho$ is the least element. Lastly, if both sides step
(i.e., are a $\theta$) then we compare the resulting computations one time step
later.
%
It is straightforward to prove using \lob-induction that this relation is
reflexive, transitive and anti-symmetric given that the underlying relation $R$
has those properties. The lock-step ordering is therefore the partial ordering
we will associate with $\li A$.
%
More generally we can define a heterogeneous version of this ordering that lifts
poset relation $c : A \rel A'$ to a poset relation $\li c : \li A \rel \li A'$.

However, we also cannot completely drop step-\emph{insensitivity} from
our model. The graduality property itself is not sensitive to steps,
and in fact there are terms related by term precision that take
differing numbers of steps.
%
The offending step arises precisely from the place where our
definition of $D$ uses a $\later$: the function case.
%
Consider the representability condition corresponding to the DnL rule
for $\iarr \colon \dyntodyn \ltdyn\, \dyn$. This is the square $\sem{\dnc{\iarr}} \ltsq{r({\li D})}{\li\sem{\iarr}} \id$.
%% % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGxpIEQiXSxbMCwxLCJcXGxpIFUoRCBcXGFyciBcXGxpIEQpIl0sWzEsMCwiXFxsaSBEIl0sWzEsMSwiXFxsaSBEIl0sWzAsMiwiXFxsZXFfe1xcbGkgRH0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxLDMsIlxcbGlcXGlhcnIiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJiYXJyZWQifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDEsIlxcZG5je1xcaWFycn0iLDJdLFsyLDMsIlxcaWQiXV0=
%% \[\begin{tikzcd}[ampersand replacement=\&]
%% 	{\li D} \& {\li D} \\
%% 	{\li U(D \arr \li D)} \& {\li D}
%% 	\arrow["{\leq_{\li D}}", "\shortmid"{marking}, no head, from=1-1, to=1-2]
%% 	\arrow["{\sem{\dnc{\iarr}}}"', from=1-1, to=2-1]
%% 	\arrow["\id", from=1-2, to=2-2]
%% 	\arrow["\li\sem{\iarr}"', "\shortmid"{marking}, no head, from=2-1, to=2-2]
%% \end{tikzcd}\]
For this square to be valid with the lock-step ordering the left and
right hand side would need to take the same number of steps, at least
when the left-hand side does not error.
%
However the right hand side \emph{always} takes $0$ steps, as it is
the identity function, whereas on the left, our definition of
$\sem{\dnc{\iarr}}$ had to take an observable step when its input is a
function: this was inherent to the fact that the function case of the
dynamic type is guarded by a later.

However, observe that we can remedy this particular situation by
replacing the $\id$ on the right hand side by an innocuous function
$\delta^* = (\delta \circ \eta)^\dagger$ that on an input value takes
a single computational step, but is otherwise the identity
function. If we were to ignore computational steps, then this function
\emph{would} be the identity function. We call such a function that is
the identity function except for the introduction of computational
steps a \emph{perturbation}.

We formalize this property of being equivalent ``except for steps''
with a second relation on the free error domain $\li A$: \emph{weak
bisimilarity}, defined in Figure~\ref{fig:lock-step-error-ordering}, which is
parameterized by a binary relation $\bisim_A$ on $A$
\cite{mogelberg-paviotti2016}.
% For a type $X$, we define a relation on $\li X$, called ``weak bisimilarity",
% written $l \bisim l'$. 
Two errors are bisimilar, and when both sides are $\eta$, we ensure
that the underlying values are bisimilar in the underlying
bisimilarity relation on $A$. When both sides are thinking, we ensure
the terms are bisimilar later.  Most importantly, when one side is
thinking but the other terminates at $\eta x$ (i.e., one side steps),
we stipulate that the $\theta$-term runs to $\eta y$ where $x$ is
related to $y$. And similarly, if one side is thinking and the other
errors, we ensure the thinking side eventually errors.

It can be shown (by \lob-induction) that weak bisimilarity is
reflexive and symmetric. Since it is non-trivial, a $\theta$
congruence and step-insensitive on both sides, by
Theorem~\ref{thm:no-go}, we also know that it is \emph{not}
transitive.
%
We will then require our denotations of types to be not just posets,
but posets additionally equipped with a reflexive symmetric relation
$\bisim_A$.

Then we can refine our denotation of term precision $\Delta \vdash M
\ltdyn N : c$ to mean not that $\sem{M}$ and $\sem{N}$ are necessarily
in a lock-step error ordering directly, but that they can be
``synchronized'' to do so, that is that there exist $f \bisim \sem{M}$
and $g \bisim \sem{N}$ such that $f \ltsq{\sem{\Delta}}{U\li\sem{c}}
g$.
%
Note that this in turn implies that $\sem{M}$ and $\sem{N}$ are
related in the original \emph{step-insensitive} error ordering that we
sought to prove!
%
We additionally weaken our representability squares so that our
upcasts and downcasts are not required to be in a lock-step ordering
with an identity but instead to be in a lock-step ordering with some
perturbation, that is a function \emph{bisimilar to} the identity. We
call this weakened form of representability
\emph{quasi}-representability.
%
Then if our relations are quasi-representable we can in fact prove the
validity of our cast rules.
%
The remainder of the proof of graduality then is to show that this
property of being quasi-representable is itself compositional: that
all of the constructions we have on type precision preserve the
property of being quasi-representable.
%
While this is true for representability, it is not quite true for
quasi-representability. The reason is that perturbations are not quite
as well behaved as \emph{actual} identity functions. To solve this
final issue, we attach one final piece of information to our types
$A$: a type of \emph{syntactic} perturbations that represent functions
bisimilar to the identity, but are presented as data so that we can
perform operations such as composition and functorial actions on them.
%
With this notion of syntactic perturbation, and additional
requirements that the relations interact well with perturbations, we
finally achieve our desired result: a compositional,
syntax-independent proof of graduality.


%% Importantly, we note that as with the original ordering $\semltbad$ defined at
%% the beginning of this section, the relation just defined is not transitive
%% (again as a result of the above no-go theorem). It may therefore seem that we
%% have not solved the original issue we faced. In a sense, this is true. The model
%% of gradual typing that we end up with will not support \emph{extensional}
%% compositional reasoning. However, by decomposing the denotation of term
%% precision in the above manner, we can employ \emph{intensional} compositional
%% reasoning by working with the lock-step error ordering. Thus, the tentative plan
%% going forward will be to carry out the proofs compositionally using the
%% lock-step ordering. We will then apply the closure under weak bisimilarity in
%% the denotation of term precision given above to handle the aspects involving
%% stepping.

%% Notice that this delay
%% function is weakly bisimilar to the identity function in that $\delta^*\, x
%% \bisim x$ for all $x$. \footnote{This follows from the fact that $\delta$ is
%% weakly bisimilar to the identity ($\delta\, x \bisim x$ for all $x$) and that
%% $-^\dagger$ preserves weak bisimilarity.} Thus, it will disappear when we apply
%% the bisimilarity-closure construction described above. That is, this delay makes
%% no difference in the extensional setting, but its presence is crucial in the
%% intensional setting.


%% The precise definition of $\iarr$ as a poset relation is not important
%% for this discussion.
%% %

%% \eric{We may want to introduce error domain relations and squares at this point,
%% since the squares for DnL and DnR involve lift.}
%
%% We now recall the definition of the semantics of a downcast given in Section
%% \ref{sec:term-interpretation}. The downcast on the left will insert a $\theta$
%% in the case where the value of type $D$ is a later-function $\tilde{f}$.
%% %
%% Thus, in order for the downcast to be related to the RHS in the lock-step error
%% ordering on $\li (D \to \li D)$, the RHS must be of the form $\theta(\dots)$,
%% and moreover, after one time step, the argument of $\theta$ on the LHS must be
%% related to the argument of $\theta$ on the RHS. As it stands now, this need not
%% be the case, e.g., if the RHS is of the form $\eta(\dots)$. Thus, we conclude
%% that the DnL rule does not in general hold under the lock-step error ordering.


%% \max{resume here}
%% To deal with
%% terms that take differing numbers of steps, we then define a separate
%% relation called \emph{weak bisimilarity} that relates terms that are
%% extensionally equal and may differ by a finite number of delays. Then,
%% the semantics of the error ordering for the guarded lift monad will
%% involve a combination of these two relations: a ``closure'' of the
%% lock-step error ordering under weak bisimilarity on both sides.
%% % Although the combined relation will not be transitive (for the same reason that
%% % $\semltbad$ is not transitive), this...
%% This decomposition has the advantage that we can recover some transitive
%% reasoning and push much of the reasoning about stepping to the margins of the
%% development.

%% % ...to carry out the proofs using the lock-step ordering and handle the stepping
%% % behavior separately via weak bisimilarity. In the end we combine everything
%% % together using the above denotation for term precision


%% \subsection{Extending the Model to Higher-Order Types}
%% \max{this subsection doesn't really say anything concrete. If we want to talk about perturbations, actually talk about them}

%% % At this point, we could carry out the full construction of a concrete relational
%% % model with these additional features. 

%% The above techniques give a semantic interpretation of term precision for closed
%% terms of base type. We now consider how to extend these constructions to
%% potentially-open terms of \emph{all} types. In particular, in order to model
%% higher-order data types (i.e., functions) we need to equip \emph{every} semantic
%% object with not only a partial ordering relation but also a ``bisimilarity''
%% relation that is reflexive and symmetric. We must similarly equip every object
%% with a structured set of delays that can be inserted and manipulated to ensure
%% the appropriate cast rules hold at all higher-order types. For example, the
%% upcast for a derivation $c_i \ra c_o$ involves the downcast corresponding to
%% $c_i$ and the upcast corresponding to $c_o$. We must be able to insert delays in
%% a functorial manner to mimic the structure of the casts. In the next section, we
%% will make the necessary definitions and describe the relevant constructions.

% For the sake of reusability and modularity, rather than carry out this
% construction in the concrete setting developed here, we will instead return to
% the abstract setting and adjust our definition of model to account for these
% requirements. We will break the construction into smaller steps and isolate the
% pieces that require the techniques of SGDT from those that do not. Then with
% this framework at our disposal, we will return to the construction of a concrete
% model in Section \ref{sec:concrete-model}.
% , taking as a starting point the definitions introduced in the current section.

% Thus in the next section we define revised notions of a model of
% gradual typing based on the lessons learned in the present section. 

% The lack of transitivity presents a major barrier towards giving a compositional
% semantics to gradual typing: if our relations are not transitive, then we cannot
% compose squares horizontally. But we have argued above that horizontal
% composition is essential for modelling the axioms of gradual typing in a
% syntax-independent manner.

% In particular, to model the UpL/UpR/DnL/DnR rules
% for casts in the presence of transitivity, it is sufficient to establish the
% validity of simpler rules that do not ``build in'' composition. We can then use
% transitivity to derive the original versions of the rules. On the other hand,
% without transitivity we must instead validate the cast rules in the model ``from
% scratch''. In fact, we cannot even define the semantic interpretation of type
% precision in a syntax-independent manner. The issue is that in the definition of
% relation, the requirement that it be representable now involves quantifying over
% all other relations, which is circular.
 
% So, although this approach would suffice for proving graduality, it lacks the
% compositionality that we seek in a reusable framework for the semantics of
% gradual typing.

%Because it is convenient to make use of transitive reasoning in proving graduality, ...


% Doing so, we define a \emph{lock-step} error ordering, where roughly speaking,
% in order for computations to be related, they must have the same stepping
% behavior. We then formulate a separate relation, \emph{weak bisimilarity}, that
% relates computations that are extensionally equal and may differ only in their
% stepping behavior. % up to a finite number of \delta's
% Finally, the semantics of term precision will involve a combination of these two
% relations, a sort of closure of the lock-step ordering under weak bisimilarity
% on both sides. This decomposition has the advantage that we can recover some
% transitive reasoning and push the parts involving stepping to the margins of the
% development.



\begin{comment}
\subsection{Modeling Type and Term Precision}
\max{TODO: figure out where this stuff goes}
% We will model type precision $c : A \ltdyn A'$ as a relation between the sets
% $\sem{A}$ and $\sem{A'}$. 

To model term precision, we begin by equipping the denotation of every type with
an ordering relation. Since term precision is reflexive and transitive, and
since we identify terms that are equi-precise, we model value types as
partially-ordered sets and values $\Gamma \vdash V : A$ as \emph{monotone}
functions. Analogously, every error domain is now equipped with a partial
ordering for which the error element is the bottom element, and the map
$\theta_B : \laterhs B \to B$ is now required to be monotone. 
%
Morphisms of error domains are morphisms of the underlying partially-ordered
sets that preserve the error element and $\theta$ map, as was the case in the
previous section.

We model a type precision relation $c : A \ltdyn A'$ as a \emph{monotone
relation}, i.e., a relation $c$ that is upward-closed under the relation on $A'$
and downward-closed under the relation on $A$. We denote such a relation between
$A$ and $A'$ by $c : A \rel A'$. The relation on the poset $A$ is denoted
$r(A)$.
% This extends to products $c_1 \times c_2$ in the obvious way.
Composition of relations on predomains is the usual relational composition
(which is truncated to be propositional).



\subsubsection{Modelling Term Precision}\label{sec:modeling-term-precision}




It remains to define $Fc$, i.e., the action of $F$ on relations.
%
% However, lifting a relation between $A$ and $A'$ to a relation between $\li A$
% and $\li A'$ proves problematic if we allow computations that take different
% numbers of steps to be related. To illustrate the issue, let us define an
% ordering $\semltbad$ between $\li A$ and $\li A'$; we call this the
% \emph{step-insensitive error ordering}. 
%
We note that the graduality property and the axioms of the inequational theory
are independent of the intensional stepping behavior of terms, so our ultimate
notion that interprets term precision will need to be oblivious to stepping as
well.
%
To that end, let us define a \emph{step-insensitive error ordering} $\semltbad$
between $\li A$ and $\li A'$; The ordering is parameterized by an ordering
relation $\le$ between $A$ and $A'$. The definition is by guarded recursion and
is shown in Figure \ref{fig:step-insensitive-error-ordering}. Recall that
$\delta : \li A \to \li A$ is defined by $\delta = \theta_A \circ \nxt$.

Two computations that immediately return $(\eta)$ are related if the returned
values are related in the underlying ordering. The computation that errors
$(\mho)$ is the least term in the ordering. If both sides step (i.e., both sides
are $\theta$), then we allow one time step to pass and compare the resulting
terms (this is where use the relation defined ``later'' and is why we employ
guarded recursion to define the relation).
%
Lastly, if one side steps and the other immediately returns a value, then in
order for these terms to be related, the side that steps must terminate with a
value in some finite number of steps $n$, and that value must be related to the
value returned by the other side. Likewise, if the LHS steps and the RHS
immediately errors, then in order to be related, the LHS must eventually
terminate with error.

\end{comment}
